# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

# Rules for generating BinSource-auto.cpp
cpp:
    header: |
        /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
        * vim: set ts=8 sts=4 et sw=4 tw=99:
        * This Source Code Form is subject to the terms of the Mozilla Public
        * License, v. 2.0. If a copy of the MPL was not distributed with this
        * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

        // FIXME: Verify that identifiers are valid.

        #include "frontend/BinSource.h"

        #include "mozilla/ArrayUtils.h"
        #include "mozilla/Casting.h"
        #include "mozilla/Maybe.h"
        #include "mozilla/Move.h"
        #include "mozilla/PodOperations.h"
        #include "mozilla/Vector.h"

        #include "frontend/BinTokenReaderTester.h"
        #include "frontend/FullParseHandler.h"
        #include "frontend/Parser.h"
        #include "frontend/SharedContext.h"

        #include "vm/RegExpObject.h"

        #include "frontend/ParseContext-inl.h"
        #include "frontend/ParseNode-inl.h"

        namespace js {
        namespace frontend {

        using AutoList = BinTokenReaderTester::AutoList;
        using AutoTaggedTuple = BinTokenReaderTester::AutoTaggedTuple;
        using AutoTuple = BinTokenReaderTester::AutoTuple;
        using BinFields = BinTokenReaderTester::BinFields;
        using Chars = BinTokenReaderTester::Chars;
        using NameBag = GCHashSet<JSString*>;
        using Names = GCVector<JSString*, 8>;
        using UsedNamePtr = UsedNameTracker::UsedNameMap::Ptr;
            
        // Evaluate an expression, checking that the result is not 0.
        //
        // Throw `cx->alreadyReportedError()` if it returns 0/nullptr.
        #define TRY(EXPR) \
            do { \
                if (!EXPR) \
                    return cx_->alreadyReportedError(); \
            } while(false)


        #define TRY_VAR(VAR, EXPR) \
            do { \
                VAR = EXPR; \
                if (!VAR) \
                    return cx_->alreadyReportedError(); \
            } while (false)

        #define TRY_DECL(VAR, EXPR) \
            auto VAR = EXPR; \
            if (!VAR) \
            return cx_->alreadyReportedError();

        #define TRY_EMPL(VAR, EXPR) \
            do { \
                auto _tryEmplResult = EXPR; \
                if (!_tryEmplResult) \
                    return cx_->alreadyReportedError(); \
                VAR.emplace(_tryEmplResult.unwrap()); \
            } while (false)

        #define MOZ_TRY_EMPLACE(VAR, EXPR) \
            do { \
                auto _tryEmplResult = EXPR; \
                if (_tryEmplResult.isErr()) \
                    return ::mozilla::Err(_tryEmplResult.unwrapErr()); \
                VAR.emplace(_tryEmplResult.unwrap()); \
            } while (false)

        #define MOZ_TRY_DECL(VAR, EXPR) \
            auto _##VAR = EXPR; \
            if (_##VAR.isErr()) \
                return ::mozilla::Err(_##VAR.unwrapErr()); \
            auto VAR = _##VAR.unwrap(); 

        // Ensure that we are visiting the right fields.
        template<size_t N>
        JS::Result<Ok, JS::Error&>
        BinASTParser::checkFields(const BinKind kind, const BinFields& actual, const BinField (&expected)[N])
        {
            if (actual.length() != N)
                return raiseInvalidNumberOfFields(kind, N, actual.length());
    
            for (size_t i = 0; i < N; ++i) {
                if (actual[i] != expected[i])
                    return raiseInvalidField(describeBinKind(kind), actual[0]);
            }
    
            return Ok();
        }
        // Special case for N=0, as empty arrays are not permitted in C++
        JS::Result<Ok, JS::Error&>
        BinASTParser::checkFields0(const BinKind kind, const BinFields& actual)
        {
            if (actual.length() != 0)
                return raiseInvalidNumberOfFields(kind, 0, actual.length());
    
            return Ok();
        }

        // Compare a bunch of `uint8_t` values (as returned by the tokenizer_) with
        // a string literal (and ONLY a string literal).
        template<size_t N>
        bool operator==(const Chars& left, const char (&right)[N]) {
            return BinTokenReaderTester::equals(left, right);
        }
    
    footer: |
        } // namespace frontend
        } // namespace js    

hpp:
    class:
        header: |
            // This file is autogenerated. It is meant to be included from the declaration
            // of class `BinASTParser`. The include may be public or private.

    tokens:
        kind:
            doc: |
                /**
                 * The different kinds of Binary AST nodes, as per the specifications of
                 * Binary AST.
                 *
                 * These kinds match roughly with the `ParseNodeKind` used internally.
                 *
                 * Usage:
                 *
                 * ```c++
                 * #define WITH_KIND(CPP_NAME, SPEC_NAME) ...
                 * FOR_EACH_BIN_KIND(WITH_KIND)
                 * ```
                 *
                 *
                 * (sorted by alphabetical order)
                 */
        field:
            doc: |
                /**
                 * The different fields of Binary AST nodes, as per the specifications of
                 * Binary AST.
                 *
                 * Usage:
                   *
                 * ```c++
                 * #define WITH_FIELD(CPP_NAME, SPEC_NAME) ...
                 * FOR_EACH_BIN_FIELD(WITH_FIELD)
                 * ```
                 *
                 * (sorted by alphabetical order)
                 */
           
        header: |
            #ifndef frontend_BinToken_h
            #define frontend_BinToken_h

            /**
             * Definition of Binary AST tokens.
             *
             * In the Binary AST world, an AST is composed of nodes, where a node is
             * defined by:
             * - a Kind (see `BinKind`);
             * - a list of fields, where each field is:
             *    - a Name (see `BinField`);
             *    - a Value, which may be either a node or a primitive value.
             *
             * The mapping between Kind and list of fields is determined entirely by
             * the grammar of Binary AST. The mapping between (Kind, Name) and the structure
             * of Value is also determined entirely by the grammar of Binary AST.
             *
              * As per the specifications of Binary AST, kinds may be added as the language
             * grows, but never removed. The mapping between Kind and list of fields may
             * also change to add new fields or make some fields optional, but may never
             * remove a field. Finally, the mapping between (Kind, Name) and the structure
             * of Value may be modified to add new possible values, but never to remove a
             * value.
             *
             * A Binary AST parser must be able to fail gracefully when confronted with
             * unknown Kinds or Names.
             */

            namespace js {
            namespace frontend {
        footer: |
            const char* describeBinKind(const BinKind& kind);
            const char* describeBinField(const BinField& kind);

            } // namespace frontend
            } // namespace js

            #endif // frontend_BinToken_h


ArrayExpression:
    build:
        auto result = elements;

AssertedScope:
    type-ok:
        Ok
    build:
        auto result = Ok();
    fields:
        capturedNames:
            before: |
                // FIXME: Ignored for the moment.
        hasDirectEval:
            before: |
                // FIXME: Ignored for the moment.
        lexicallyDeclaredNames:
            block:
                replace:
                    MOZ_TRY(parseAndUpdateScopeNames(*parseContext_->innermostScope(), DeclarationKind::Let));                
        varDeclaredNames:
            block:
                replace:
                    MOZ_TRY(parseAndUpdateScopeNames(parseContext_->varScope(), DeclarationKind::Var));


BinaryExpression:
    build: |
        ParseNodeKind pnk;
        switch (operator_) {
            case BinaryOperator::Comma:
            pnk = ParseNodeKind::Comma;
            break;
            case BinaryOperator::LogicalOr:
            pnk = ParseNodeKind::Or;
            break;
            case BinaryOperator::LogicalAnd:
            pnk = ParseNodeKind::And;
            break;
            case BinaryOperator::BitOr:
            pnk = ParseNodeKind::BitOr;
            break;
            case BinaryOperator::BitXor:
            pnk = ParseNodeKind::BitXor;
            break;
            case BinaryOperator::BitAnd:
            pnk = ParseNodeKind::BitAnd;
            break;
            case BinaryOperator::Eq:
            pnk = ParseNodeKind::Eq;
            break;
            case BinaryOperator::Neq:
            pnk = ParseNodeKind::Ne;
            break;
            case BinaryOperator::StrictEq:
            pnk = ParseNodeKind::StrictEq;
            break;
            case BinaryOperator::StrictNeq:
            pnk = ParseNodeKind::StrictNe;
            break;
            case BinaryOperator::LessThan:
            pnk = ParseNodeKind::Lt;
            break;
            case BinaryOperator::LeqThan:
            pnk = ParseNodeKind::Le;
            break;
            case BinaryOperator::GreaterThan:
            pnk = ParseNodeKind::Gt;
            break;
            case BinaryOperator::GeqThan:
            pnk = ParseNodeKind::Ge;
            break;
            case BinaryOperator::In:
            pnk = ParseNodeKind::In;
            break;
            case BinaryOperator::Instanceof:
            pnk = ParseNodeKind::InstanceOf;
            break;
            case BinaryOperator::Lsh:
            pnk = ParseNodeKind::Lsh;
            break;
            case BinaryOperator::Rsh:
            pnk = ParseNodeKind::Rsh;
            break;
            case BinaryOperator::Ursh:
            pnk = ParseNodeKind::Ursh;
            break;
            case BinaryOperator::Plus:
            pnk = ParseNodeKind::Add;
            break;
            case BinaryOperator::Minus:
            pnk = ParseNodeKind::Sub;
            break;
            case BinaryOperator::Mul:
            pnk = ParseNodeKind::Star;
            break;
            case BinaryOperator::Div:
            pnk = ParseNodeKind::Div;
            break;
            case BinaryOperator::Mod:
            pnk = ParseNodeKind::Mod;
            break;
            case BinaryOperator::Pow:
            pnk = ParseNodeKind::Pow;
            break;
        }

        ParseNode* result;
        if (left->isKind(pnk) &&
            pnk != ParseNodeKind::Pow /* ParseNodeKind::Pow is not left-associative */)
        {
            // Regroup left-associative operations into lists.
            left->appendWithoutOrderAssumption(right);
            result = left;
        } else {
            TRY_DECL(list, factory_.newList(pnk, tokenizer_->pos(start)));

            list->appendWithoutOrderAssumption(left);
            list->appendWithoutOrderAssumption(right);
            result = list;
        }

Block:
    init: |
        ParseContext::Statement stmt(parseContext_, StatementKind::Block);
        ParseContext::Scope currentScope(cx_, parseContext_, usedNames_);
        TRY(currentScope.init(parseContext_));
    build: |
        TRY_DECL(bindings, NewLexicalScopeData(cx_, currentScope, alloc_, parseContext_));
        TRY_DECL(result, factory_.newLexicalScope(*bindings, statements));

BreakStatement:
    build: |
        if (label && !label->isKind(ParseNodeKind::Name)) {
            // The grammar does not differentiate between a label and any other string.
            return raiseError("BreakStatement - Label MUST be an identifier");
        }

        auto validity = parseContext_->checkBreakStatement(label ? label->name() : nullptr);

        if (validity.isErr()) {
            switch (validity.unwrapErr()) {
              case ParseContext::BreakStatementError::ToughBreak:
                 return raiseError(kind, "Not in a loop");
              case ParseContext::BreakStatementError::LabelNotFound:
                 return raiseError(kind, "Label not found");
            }
        }

        TRY_DECL(result, factory_.newBreakStatement(label ? label->name() : nullptr, tokenizer_->pos(start)));

CallExpression:
    build: |
        auto result = arguments;
        result->setKind(ParseNodeKind::New);
        result->prepend(callee);
        
CatchClause:
    init: |
        ParseContext::Statement stmt(parseContext_, StatementKind::Catch);
        ParseContext::Scope currentScope(cx_, parseContext_, usedNames_);
        TRY(currentScope.init(parseContext_));
    build: |
        TRY_DECL(bindings, NewLexicalScopeData(cx_, currentScope, alloc_, parseContext_));
        TRY_DECL(result, factory_.newLexicalScope(*bindings, body));
        TRY(factory_.setupCatchScope(result, binding, body));

CompoundAssignmentExpression:
    build: |
        ParseNodeKind pnk;
        switch (operator_){
          case CompoundAssignmentOperator::PlusAssign:
            pnk = ParseNodeKind::AddAssign;
            break;
          case CompoundAssignmentOperator::MinusAssign:
            pnk = ParseNodeKind::SubAssign;
            break;
          case CompoundAssignmentOperator::MulAssign:
            pnk = ParseNodeKind::MulAssign;
            break;
          case CompoundAssignmentOperator::DivAssign:
            pnk = ParseNodeKind::DivAssign;
            break;
          case CompoundAssignmentOperator::ModAssign:
            pnk = ParseNodeKind::ModAssign;
            break;
          case CompoundAssignmentOperator::PowAssign:
            pnk = ParseNodeKind::PowAssign;
            break;
          case CompoundAssignmentOperator::LshAssign:
            pnk = ParseNodeKind::LshAssign;
            break;
          case CompoundAssignmentOperator::RshAssign:
            pnk = ParseNodeKind::RshAssign;
            break;
          case CompoundAssignmentOperator::UrshAssign:
            pnk = ParseNodeKind::UrshAssign;
            break;
          case CompoundAssignmentOperator::BitOrAssign:
            pnk = ParseNodeKind::BitOrAssign;
            break;
          case CompoundAssignmentOperator::BitXorAssign:
            pnk = ParseNodeKind::BitXorAssign;
            break;
          case CompoundAssignmentOperator::BitAndAssign:
            pnk = ParseNodeKind::BitAndAssign;
            break;
        }
        TRY_DECL(result, factory_.newAssignment(pnk, binding, expression));

ComputedMemberExpression:
    build: |
        TRY_DECL(result, factory_.newPropertyByValue(object, expression, start));

ConditionalExpression:
    build: |
        TRY_DECL(result, factory_.newConditional(test, consequent, alternate));

ContinueStatement:
    build: |
        if (label && !label->isKind(ParseNodeKind::Name)) {
            // The grammar does not differentiate between a label and any other string.
            return raiseError("ContinueStatement - Label MUST be an identifier");
        }

        auto validity = parseContext_->checkContinueStatement(label ? label->name() : nullptr);
        if (validity.isErr()) {
            switch (validity.unwrapErr()) {
              case ParseContext::ContinueStatementError::NotInALoop:
                return raiseError(kind, "Not in a loop");
              case ParseContext::ContinueStatementError::LabelNotFound:
                return raiseError(kind, "Label not found");
            }
        }

        TRY_DECL(result, factory_.newContinueStatement(label ? label->name() : nullptr, tokenizer_->pos(start)));

DataProperty:
    build: |
        if (!factory_.isUsableAsObjectPropertyName(name))
            return raiseError("DataProperty key kind");

        TRY_DECL(result, factory_.newObjectMethodOrPropertyDefinition(name, expression, AccessorType::None));

Directive:
    build: |
        TokenPos pos = tokenizer_->pos(start);
        TRY_DECL(result, factory_.newStringLiteral(rawValue, pos));

DoWhileStatement:
    init:        
        ParseContext::Statement stmt(parseContext_, StatementKind::DoLoop);
    build:
        TRY_DECL(result, factory_.newDoWhileStatement(body, test, tokenizer_->pos(start)));

ExpressionStatement:
    build:
        TRY_DECL(result, factory_.newExprStatement(expression, tokenizer_->offset()));

ForInStatement:
    init: |
        ParseContext::Statement stmt(parseContext_, StatementKind::ForInLoop);

        // Implicit scope around the `for`, used to store `for (let x in  ...)`
        // or `for (const x in ...)`-style declarations. Detail on the
        // declaration is stored as part of `BINJS_Scope`.
        ParseContext::Scope scope(cx_, parseContext_, usedNames_);
        TRY(scope.init(parseContext_));
    build: |
        TRY_DECL(forHead, factory_.newForInOrOfHead(ParseNodeKind::ForIn, left, right, tokenizer_->pos(start)));
        TRY_DECL(result, factory_.newForStatement(start, forHead, body, /*flags*/ 0));

        if (!scope.isEmpty()) {
            TRY_DECL(bindings, NewLexicalScopeData(cx_, scope, alloc_, parseContext_));
            TRY_VAR(result, factory_.newLexicalScope(*bindings, result));
        }


ForStatement:
    init: |
        ParseContext::Statement stmt(parseContext_, StatementKind::ForLoop);

        // Implicit scope around the `for`, used to store `for (let x; ...; ...)`
        // or `for (const x; ...; ...)`-style declarations. Detail on the
        // declaration is stored as part of `BINJS_Scope`.
        ParseContext::Scope scope(cx_, parseContext_, usedNames_);
        TRY(scope.init(parseContext_));
    build: |
        TRY_DECL(forHead, factory_.newForHead(init, test, update, tokenizer_->pos(start)));
        TRY_DECL(result, factory_.newForStatement(start, forHead, body, /* iflags = */ 0));

        if (!scope.isEmpty()) {
            TRY_DECL(bindings, NewLexicalScopeData(cx_, scope, alloc_, parseContext_));
            TRY_VAR(result, factory_.newLexicalScope(*bindings, result));
        }

FunctionExpression:
    fields:
        params:
            after: |
                MOZ_TRY_DECL(funbox, buildFunctionBox(params, name, isGenerator, isAsync));

                // Container scopes.
                ParseContext::Scope& varScope = parseContext_->varScope();
                ParseContext::Scope* letScope = parseContext_->innermostScope();
            
                // Push a new ParseContext.
                BinParseContext funpc(cx_, this, funbox, /* newDirectives = */ nullptr);
                TRY(funpc.init());
                parseContext_->functionScope().useAsVarScope(parseContext_);
                MOZ_ASSERT(parseContext_->isFunctionBox());
    build: |
        MOZ_TRY_DECL(result, buildFunction(start, kind, params, body, funbox));

ListOfDirective:
    init:
        TRY_DECL(result, factory_.newStatementList(tokenizer_->pos(start)));
    append:
        factory_.addStatementToList(result, item);

ListOfObjectProperty:
    init:
        TRY_DECL(result, factory_.newObjectLiteral(start));

ListOfOptionalSpreadElementOrExpression:
    init:
        TRY_DECL(result, factory_.newArrayLiteral(start));
    append: |
        if (item)
            factory_.addArrayElement(result, item); // Infallible.
        else
            TRY(factory_.addElision(result, tokenizer_->pos(start)));

ListOfStatement:
    init:
        TRY_DECL(result, factory_.newStatementList(tokenizer_->pos(start)));
    append:
        factory_.addStatementToList(result, item);
            
#ListOfSpreadElementOrExpression:
#    init:
#        ParseNode* result = new_<ListNode>(ParseNodeKind::ParamsBody, tokenizer_->pos());
#    append:
#        result->appendWithoutOrderAssumption(item);
                        
ListOfSwitchCase:
    init:
        TRY_DECL(result, factory_.newStatementList(tokenizer_->pos(start)));
    append:
        factory_.addCaseStatementToList(result, item);

ListOfVariableDeclarator:
    init: |
        TRY_DECL(result, factory_.newDeclarationList(ParseNodeKind::Const /*Placeholder*/,
            tokenizer_->pos(start)));

LiteralBooleanExpression:
    build:
        TRY_DECL(result, factory_.newBooleanLiteral(value, tokenizer_->pos(start)));

LiteralNumericExpression:
    build:
        TRY_DECL(result, factory_.newNumber(value, DecimalPoint::HasDecimal, tokenizer_->pos(start)));

LiteralNullExpression:
    build:
        TRY_DECL(result, factory_.newNullLiteral(tokenizer_->pos(start)));

LiteralPropertyName:
    build: |
        ParseNode* result;
        uint32_t index;
        if (value->isIndex(&index))
            TRY_VAR(result, factory_.newNumber(index, NoDecimal, TokenPos(start, tokenizer_->offset())));
        else
            TRY_VAR(result, factory_.newStringLiteral(value, tokenizer_->pos(start)));
        
LiteralRegExpExpression:
    fields:
        flags:
            block:
                replace:
                    Chars flags((cx_));
                    MOZ_TRY(readString(flags));
    build: |
        RegExpFlag reflags = NoFlags;
        for (auto c : flags) {
            if (c == 'g' && !(reflags & GlobalFlag))
                reflags = RegExpFlag(reflags | GlobalFlag);
            else if (c == 'i' && !(reflags & IgnoreCaseFlag))
                reflags = RegExpFlag(reflags | IgnoreCaseFlag);
            else if (c == 'm' && !(reflags & MultilineFlag))
                reflags = RegExpFlag(reflags | MultilineFlag);
            else if (c == 'y' && !(reflags & StickyFlag))
                reflags = RegExpFlag(reflags | StickyFlag);
            else if (c == 'u' && !(reflags & UnicodeFlag))
                reflags = RegExpFlag(reflags | UnicodeFlag);
            else
                return raiseInvalidEnum("RegExpLiteral", flags);
        }


        Rooted<RegExpObject*> reobj(cx_);
        TRY_VAR(reobj, RegExpObject::create(cx_,
            pattern,
            reflags,
            alloc_,
            TenuredObject));

        TRY_DECL(result, factory_.newRegExp(reobj, tokenizer_->pos(start), *this));
        
LiteralStringExpression:
    build:
        TRY_DECL(result, factory_.newStringLiteral(value, tokenizer_->pos(start)));
        
Method:
    fields:
        params:
            after: |
                MOZ_TRY_DECL(funbox, buildFunctionBox(params, name, isGenerator, isAsync));

                // Container scopes.
                ParseContext::Scope& varScope = parseContext_->varScope();
                ParseContext::Scope* letScope = parseContext_->innermostScope();
            
                // Push a new ParseContext.
                BinParseContext funpc(cx_, this, funbox, /* newDirectives = */ nullptr);
                TRY(funpc.init());
                parseContext_->functionScope().useAsVarScope(parseContext_);
                MOZ_ASSERT(parseContext_->isFunctionBox());
    build: |
        MOZ_TRY_DECL(result, buildFunction(start, kind, params, body, funbox));

NewExpression:
    build: |
        auto result = arguments;
        result->setKind(ParseNodeKind::New);
        result->prepend(callee);

ObjectExpression:
    build:
        auto result = properties;

OptionalAssertedScope:
    type-ok:
        Ok
        
ReturnStatement:
    init: |
        if (!parseContext_->isFunctionBox()) {
            // Return statements are permitted only inside functions.
            return raiseInvalidKind("Toplevel Statement", kind);
        }

        parseContext_->functionBox()->usesReturn = true;
    build: 
        TRY_DECL(result, factory_.newReturnStatement(expression, tokenizer_->pos(start)));

Script:
    build:
        MOZ_TRY_DECL(result, appendDirectivesToBody(/* body = */ statements, /* directives = */ directives));

Setter:
    fields:
        param:
            after:
                TRY_DECL(params, factory_.newList(ParseNodeKind::ParamsBody, param));
                
        body:
            before: |
                MOZ_TRY_DECL(funbox, buildFunctionBox(params, name, /* isGenerator = */ false, /* isAsync = */ false));

                // Container scopes.
                ParseContext::Scope& varScope = parseContext_->varScope();
                ParseContext::Scope* letScope = parseContext_->innermostScope();
            
                // Push a new ParseContext.
                BinParseContext funpc(cx_, this, funbox, /* newDirectives = */ nullptr);
                TRY(funpc.init());
                parseContext_->functionScope().useAsVarScope(parseContext_);
                MOZ_ASSERT(parseContext_->isFunctionBox());
    build: |
        MOZ_TRY_DECL(method, buildFunction(start, kind, params, body, funbox));
        TRY_DECL(result, factory_.newObjectMethodOrPropertyDefinition(name, method, AccessorType::Setter));
        
ShorthandProperty:
    build: |
        if (!factory_.isUsableAsObjectPropertyName(name))
            return raiseError("shorthandProperty key kind");

        TRY_DECL(result, factory_.newObjectMethodOrPropertyDefinition(name, name, AccessorType::None));

SwitchCase:
    build: |
        TRY_DECL(result, factory_.newCaseOrDefault(start, test, consequent));

SwitchDefault:
    build: |
        TRY_DECL(result, factory_.newCaseOrDefault(start, nullptr, consequent));
        
SwitchStatement:
    build: |
        TRY_DECL(scope, factory_.newLexicalScope(nullptr, cases));
        TRY_DECL(result, factory_.newSwitchStatement(start, discriminant, scope));

StaticMemberExpression:
    build: |
        TRY_DECL(result, factory_.newPropertyAccess(object, property->asPropertyName(), start));
    
ThisExpression:
    build: |
        if (parseContext_->isFunctionBox())
            parseContext_->functionBox()->usesThis = true;

        TokenPos pos = tokenizer_->pos(start);
        ParseNode* thisName(nullptr);
        if (parseContext_->sc()->thisBinding() == ThisBinding::Function)
            TRY_VAR(thisName, factory_.newName(cx_->names().dotThis, pos, cx_));

        TRY_DECL(result, factory_.newThisLiteral(pos, thisName));

ThrowStatement:
    build: 
        TRY_DECL(result, factory_.newThrowStatement(expression, tokenizer_->pos(start)));

TryCatchStatement:
    fields:
        body:
            block:
                declare:
                    ParseNode* body;
                before: |
                    ParseContext::Statement stmt(parseContext_, StatementKind::Try);
                    ParseContext::Scope scope(cx_, parseContext_, usedNames_);
                    TRY(scope.init(parseContext_));
    build:
        TRY_DECL(result, factory_.newTryStatement(start, body, catchClause, /* finally = */ nullptr));

TryFinallyStatement:
    fields:
        body:
            block:
                declare:
                    ParseNode* body;
                before: |
                    ParseContext::Statement stmt(parseContext_, StatementKind::Try);
                    ParseContext::Scope scope(cx_, parseContext_, usedNames_);
                    TRY(scope.init(parseContext_));
        finalizer:
            block:
                declare:
                    ParseNode* finalizer;
                before: |
                    ParseContext::Statement stmt(parseContext_, StatementKind::Finally);
                    ParseContext::Scope scope(cx_, parseContext_, usedNames_);
                    TRY(scope.init(parseContext_));            
    build:
        TRY_DECL(result, factory_.newTryStatement(start, body, catchClause, finalizer));

UnaryExpression:
    build: |
        ParseNodeKind pnk;
        switch (operator_) {
          case UnaryOperator::Minus:
            pnk = ParseNodeKind::Neg;
            break;
          case UnaryOperator::Plus:
            pnk = ParseNodeKind::Add;
            break;
          case UnaryOperator::Not:
            pnk = ParseNodeKind::Not;
            break;
          case UnaryOperator::BitNot:
            pnk = ParseNodeKind::BitNot;
            break;
          case UnaryOperator::Typeof: {
            if (operand->isKind(ParseNodeKind::Name))
                pnk = ParseNodeKind::TypeOfName;
            else
                pnk = ParseNodeKind::TypeOfExpr;
            break;
            }
          case UnaryOperator::Void:
            pnk = ParseNodeKind::Void;
            break;
          case UnaryOperator::Delete: {
            switch (operand->getKind()) {
              case ParseNodeKind::Name:
                operand->setOp(JSOP_DELNAME);
                pnk = ParseNodeKind::DeleteName;
                break;
              case ParseNodeKind::Dot:
                pnk = ParseNodeKind::DeleteProp;
                break;
              case ParseNodeKind::Elem:
                pnk = ParseNodeKind::DeleteElem;
                break;
              default:
                pnk = ParseNodeKind::DeleteExpr;
            }
            break;
          } 
        }
        TRY_DECL(result, factory_.newUnary(pnk, start, operand));

UpdateExpression:
    build: |
        ParseNodeKind pnk;
        switch (operator_) {
          case UpdateOperator::Incr:
            pnk = isPrefix ? ParseNodeKind::PreIncrement
                           : ParseNodeKind::PostIncrement;
            break;
          case UpdateOperator::Decr:
            pnk = isPrefix ? ParseNodeKind::PreDecrement
                           : ParseNodeKind::PostDecrement;
            break;
        }
        TRY_DECL(result, factory_.newUnary(pnk, start, operand));

VariableDeclaration:
    build: |
        ParseNodeKind pnk;
        switch (kind_) {
          case VariableDeclarationKind::Var:
            pnk = ParseNodeKind::Var;
            break;
          case VariableDeclarationKind::Let:
            pnk = ParseNodeKind::Let;
            break;
          case VariableDeclarationKind::Const:    
            pnk = ParseNodeKind::Const;
            break;
        }
        // FIXME Check that `declarators` is not empty.
        declarators->setKind(pnk);
        auto result = declarators;

VariableDeclarator:
    build: |
        ParseNode* result;
        if (binding->isKind(ParseNodeKind::Name)) {
            // `var foo [= bar]``
            TRY_VAR(result, factory_.newName(binding->pn_atom->asPropertyName(), tokenizer_->pos(start), cx_));

            if (init)
                result->pn_expr = init;
        } else {
            // `var pattern = bar`
            if (!init) {
                // Here, `init` is required.
                return raiseMissingField("VariableDeclarator (with non-trivial pattern)", BinField::Init);
            }

            TRY_VAR(result, factory_.newAssignment(ParseNodeKind::Assign, binding, init));
        }

WhileStatement:
    init: 
        ParseContext::Statement stmt(parseContext_, StatementKind::WhileLoop);
    build: 
        TRY_DECL(result, factory_.newWhileStatement(start, test, body));

WithStatement:
    build: 
        TRY_DECL(result, factory_.newWithStatement(start, object, body));
