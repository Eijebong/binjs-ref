// This file is autogenerated.
use ast::grammar::*;


pub mod ast {
    use ::util::{ FromJSON, FromJSONError, ToJSON };
    use std;
    use json;
    use json::JsonValue as JSON;


     // String enums (by lexicographical order)
    #[derive(PartialEq, Debug, Clone)]
    pub enum BinaryOperator {
         Comma,
         LogicalOr,
         LogicalAnd,
         BitOr,
         BitXor,
         BitAnd,
         Eq,
         Neq,
         StrictEq,
         StrictNeq,
         LessThan,
         LeqThan,
         GreaterThan,
         GeqThan,
         In,
         Instanceof,
         Lsh,
         Rsh,
         Ursh,
         Plus,
         Minus,
         Mul,
         Div,
         Mod,
         Pow
    }

    impl FromJSON for BinaryOperator {
        fn import(source: &JSON) -> Result<Self, FromJSONError > {
            match source.as_str() {
                Some(",") => Ok(BinaryOperator::Comma),
                Some("||") => Ok(BinaryOperator::LogicalOr),
                Some("&&") => Ok(BinaryOperator::LogicalAnd),
                Some("|") => Ok(BinaryOperator::BitOr),
                Some("^") => Ok(BinaryOperator::BitXor),
                Some("&") => Ok(BinaryOperator::BitAnd),
                Some("==") => Ok(BinaryOperator::Eq),
                Some("!=") => Ok(BinaryOperator::Neq),
                Some("===") => Ok(BinaryOperator::StrictEq),
                Some("!==") => Ok(BinaryOperator::StrictNeq),
                Some("<") => Ok(BinaryOperator::LessThan),
                Some("<=") => Ok(BinaryOperator::LeqThan),
                Some(">") => Ok(BinaryOperator::GreaterThan),
                Some(">=") => Ok(BinaryOperator::GeqThan),
                Some("in") => Ok(BinaryOperator::In),
                Some("instanceof") => Ok(BinaryOperator::Instanceof),
                Some("<<") => Ok(BinaryOperator::Lsh),
                Some(">>") => Ok(BinaryOperator::Rsh),
                Some(">>>") => Ok(BinaryOperator::Ursh),
                Some("+") => Ok(BinaryOperator::Plus),
                Some("-") => Ok(BinaryOperator::Minus),
                Some("*") => Ok(BinaryOperator::Mul),
                Some("/") => Ok(BinaryOperator::Div),
                Some("%") => Ok(BinaryOperator::Mod),
                Some("**") => Ok(BinaryOperator::Pow),
                _ => Err(FromJSONError {
                    expected: "Instance of BinaryOperator".to_string(),
                    got: source.dump(),
                })
            }
        }
    }


    impl ToJSON for BinaryOperator {
        fn export(&self) -> JSON {
            json::from(match *self {
               BinaryOperator::Comma => ",",
               BinaryOperator::LogicalOr => "||",
               BinaryOperator::LogicalAnd => "&&",
               BinaryOperator::BitOr => "|",
               BinaryOperator::BitXor => "^",
               BinaryOperator::BitAnd => "&",
               BinaryOperator::Eq => "==",
               BinaryOperator::Neq => "!=",
               BinaryOperator::StrictEq => "===",
               BinaryOperator::StrictNeq => "!==",
               BinaryOperator::LessThan => "<",
               BinaryOperator::LeqThan => "<=",
               BinaryOperator::GreaterThan => ">",
               BinaryOperator::GeqThan => ">=",
               BinaryOperator::In => "in",
               BinaryOperator::Instanceof => "instanceof",
               BinaryOperator::Lsh => "<<",
               BinaryOperator::Rsh => ">>",
               BinaryOperator::Ursh => ">>>",
               BinaryOperator::Plus => "+",
               BinaryOperator::Minus => "-",
               BinaryOperator::Mul => "*",
               BinaryOperator::Div => "/",
               BinaryOperator::Mod => "%",
               BinaryOperator::Pow => "**"
            })
        }
    }


    impl Walker for BinaryOperator {
        fn walk<V, E>(&mut self, _: &mut ASTPath, _: &mut V) -> Result<(), E> where V: Visitor<E> {
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub enum CompoundAssignmentOperator {
         PlusAssign,
         MinusAssign,
         MulAssign,
         DivAssign,
         ModAssign,
         PowAssign,
         LshAssign,
         RshAssign,
         UrshAssign,
         BitOrAssign,
         BitXorAssign,
         BitAndAssign
    }

    impl FromJSON for CompoundAssignmentOperator {
        fn import(source: &JSON) -> Result<Self, FromJSONError > {
            match source.as_str() {
                Some("+=") => Ok(CompoundAssignmentOperator::PlusAssign),
                Some("-=") => Ok(CompoundAssignmentOperator::MinusAssign),
                Some("*=") => Ok(CompoundAssignmentOperator::MulAssign),
                Some("/=") => Ok(CompoundAssignmentOperator::DivAssign),
                Some("%=") => Ok(CompoundAssignmentOperator::ModAssign),
                Some("**=") => Ok(CompoundAssignmentOperator::PowAssign),
                Some("<<=") => Ok(CompoundAssignmentOperator::LshAssign),
                Some(">>=") => Ok(CompoundAssignmentOperator::RshAssign),
                Some(">>>=") => Ok(CompoundAssignmentOperator::UrshAssign),
                Some("|=") => Ok(CompoundAssignmentOperator::BitOrAssign),
                Some("^=") => Ok(CompoundAssignmentOperator::BitXorAssign),
                Some("&=") => Ok(CompoundAssignmentOperator::BitAndAssign),
                _ => Err(FromJSONError {
                    expected: "Instance of CompoundAssignmentOperator".to_string(),
                    got: source.dump(),
                })
            }
        }
    }


    impl ToJSON for CompoundAssignmentOperator {
        fn export(&self) -> JSON {
            json::from(match *self {
               CompoundAssignmentOperator::PlusAssign => "+=",
               CompoundAssignmentOperator::MinusAssign => "-=",
               CompoundAssignmentOperator::MulAssign => "*=",
               CompoundAssignmentOperator::DivAssign => "/=",
               CompoundAssignmentOperator::ModAssign => "%=",
               CompoundAssignmentOperator::PowAssign => "**=",
               CompoundAssignmentOperator::LshAssign => "<<=",
               CompoundAssignmentOperator::RshAssign => ">>=",
               CompoundAssignmentOperator::UrshAssign => ">>>=",
               CompoundAssignmentOperator::BitOrAssign => "|=",
               CompoundAssignmentOperator::BitXorAssign => "^=",
               CompoundAssignmentOperator::BitAndAssign => "&="
            })
        }
    }


    impl Walker for CompoundAssignmentOperator {
        fn walk<V, E>(&mut self, _: &mut ASTPath, _: &mut V) -> Result<(), E> where V: Visitor<E> {
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub enum UnaryOperator {
         Plus,
         Minus,
         Not,
         BitNot,
         Typeof,
         Void,
         Delete
    }

    impl FromJSON for UnaryOperator {
        fn import(source: &JSON) -> Result<Self, FromJSONError > {
            match source.as_str() {
                Some("+") => Ok(UnaryOperator::Plus),
                Some("-") => Ok(UnaryOperator::Minus),
                Some("!") => Ok(UnaryOperator::Not),
                Some("~") => Ok(UnaryOperator::BitNot),
                Some("typeof") => Ok(UnaryOperator::Typeof),
                Some("void") => Ok(UnaryOperator::Void),
                Some("delete") => Ok(UnaryOperator::Delete),
                _ => Err(FromJSONError {
                    expected: "Instance of UnaryOperator".to_string(),
                    got: source.dump(),
                })
            }
        }
    }


    impl ToJSON for UnaryOperator {
        fn export(&self) -> JSON {
            json::from(match *self {
               UnaryOperator::Plus => "+",
               UnaryOperator::Minus => "-",
               UnaryOperator::Not => "!",
               UnaryOperator::BitNot => "~",
               UnaryOperator::Typeof => "typeof",
               UnaryOperator::Void => "void",
               UnaryOperator::Delete => "delete"
            })
        }
    }


    impl Walker for UnaryOperator {
        fn walk<V, E>(&mut self, _: &mut ASTPath, _: &mut V) -> Result<(), E> where V: Visitor<E> {
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub enum UpdateOperator {
         Incr,
         Decr
    }

    impl FromJSON for UpdateOperator {
        fn import(source: &JSON) -> Result<Self, FromJSONError > {
            match source.as_str() {
                Some("++") => Ok(UpdateOperator::Incr),
                Some("--") => Ok(UpdateOperator::Decr),
                _ => Err(FromJSONError {
                    expected: "Instance of UpdateOperator".to_string(),
                    got: source.dump(),
                })
            }
        }
    }


    impl ToJSON for UpdateOperator {
        fn export(&self) -> JSON {
            json::from(match *self {
               UpdateOperator::Incr => "++",
               UpdateOperator::Decr => "--"
            })
        }
    }


    impl Walker for UpdateOperator {
        fn walk<V, E>(&mut self, _: &mut ASTPath, _: &mut V) -> Result<(), E> where V: Visitor<E> {
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub enum VariableDeclarationKind {
         Var,
         Let,
         Const
    }

    impl FromJSON for VariableDeclarationKind {
        fn import(source: &JSON) -> Result<Self, FromJSONError > {
            match source.as_str() {
                Some("var") => Ok(VariableDeclarationKind::Var),
                Some("let") => Ok(VariableDeclarationKind::Let),
                Some("const") => Ok(VariableDeclarationKind::Const),
                _ => Err(FromJSONError {
                    expected: "Instance of VariableDeclarationKind".to_string(),
                    got: source.dump(),
                })
            }
        }
    }


    impl ToJSON for VariableDeclarationKind {
        fn export(&self) -> JSON {
            json::from(match *self {
               VariableDeclarationKind::Var => "var",
               VariableDeclarationKind::Let => "let",
               VariableDeclarationKind::Const => "const"
            })
        }
    }


    impl Walker for VariableDeclarationKind {
        fn walk<V, E>(&mut self, _: &mut ASTPath, _: &mut V) -> Result<(), E> where V: Visitor<E> {
            Ok(())
        }
    }





    // Type sums (by lexicographical order)
    #[derive(PartialEq, Debug, Clone)]
    pub enum AssignmentTarget {
        ObjectAssignmentTarget(Box<ObjectAssignmentTarget>),
        StaticMemberAssignmentTarget(Box<StaticMemberAssignmentTarget>),
        ArrayAssignmentTarget(Box<ArrayAssignmentTarget>),
        AssignmentTargetIdentifier(Box<AssignmentTargetIdentifier>),
        ComputedMemberAssignmentTarget(Box<ComputedMemberAssignmentTarget>)
    }

    impl FromJSON for AssignmentTarget {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("ObjectAssignmentTarget") => Ok(AssignmentTarget::ObjectAssignmentTarget(Box::new(FromJSON::import(value)?))),
               Some("StaticMemberAssignmentTarget") => Ok(AssignmentTarget::StaticMemberAssignmentTarget(Box::new(FromJSON::import(value)?))),
               Some("ArrayAssignmentTarget") => Ok(AssignmentTarget::ArrayAssignmentTarget(Box::new(FromJSON::import(value)?))),
               Some("AssignmentTargetIdentifier") => Ok(AssignmentTarget::AssignmentTargetIdentifier(Box::new(FromJSON::import(value)?))),
               Some("ComputedMemberAssignmentTarget") => Ok(AssignmentTarget::ComputedMemberAssignmentTarget(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of AssignmentTarget".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for AssignmentTarget {
        fn export(&self) -> JSON {
            match *self {
               AssignmentTarget::ObjectAssignmentTarget(box ref value) => value.export(),
               AssignmentTarget::StaticMemberAssignmentTarget(box ref value) => value.export(),
               AssignmentTarget::ArrayAssignmentTarget(box ref value) => value.export(),
               AssignmentTarget::AssignmentTargetIdentifier(box ref value) => value.export(),
               AssignmentTarget::ComputedMemberAssignmentTarget(box ref value) => value.export()
            }
        }
    }


    impl Walker for AssignmentTarget {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               AssignmentTarget::ObjectAssignmentTarget(box ref mut value) => value.walk(path, visitor),
               AssignmentTarget::StaticMemberAssignmentTarget(box ref mut value) => value.walk(path, visitor),
               AssignmentTarget::ArrayAssignmentTarget(box ref mut value) => value.walk(path, visitor),
               AssignmentTarget::AssignmentTargetIdentifier(box ref mut value) => value.walk(path, visitor),
               AssignmentTarget::ComputedMemberAssignmentTarget(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum AssignmentTargetOrAssignmentTargetWithInitializer {
        ObjectAssignmentTarget(Box<ObjectAssignmentTarget>),
        ArrayAssignmentTarget(Box<ArrayAssignmentTarget>),
        ComputedMemberAssignmentTarget(Box<ComputedMemberAssignmentTarget>),
        StaticMemberAssignmentTarget(Box<StaticMemberAssignmentTarget>),
        AssignmentTargetWithInitializer(Box<AssignmentTargetWithInitializer>),
        AssignmentTargetIdentifier(Box<AssignmentTargetIdentifier>)
    }

    impl FromJSON for AssignmentTargetOrAssignmentTargetWithInitializer {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("ObjectAssignmentTarget") => Ok(AssignmentTargetOrAssignmentTargetWithInitializer::ObjectAssignmentTarget(Box::new(FromJSON::import(value)?))),
               Some("ArrayAssignmentTarget") => Ok(AssignmentTargetOrAssignmentTargetWithInitializer::ArrayAssignmentTarget(Box::new(FromJSON::import(value)?))),
               Some("ComputedMemberAssignmentTarget") => Ok(AssignmentTargetOrAssignmentTargetWithInitializer::ComputedMemberAssignmentTarget(Box::new(FromJSON::import(value)?))),
               Some("StaticMemberAssignmentTarget") => Ok(AssignmentTargetOrAssignmentTargetWithInitializer::StaticMemberAssignmentTarget(Box::new(FromJSON::import(value)?))),
               Some("AssignmentTargetWithInitializer") => Ok(AssignmentTargetOrAssignmentTargetWithInitializer::AssignmentTargetWithInitializer(Box::new(FromJSON::import(value)?))),
               Some("AssignmentTargetIdentifier") => Ok(AssignmentTargetOrAssignmentTargetWithInitializer::AssignmentTargetIdentifier(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of AssignmentTargetOrAssignmentTargetWithInitializer".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for AssignmentTargetOrAssignmentTargetWithInitializer {
        fn export(&self) -> JSON {
            match *self {
               AssignmentTargetOrAssignmentTargetWithInitializer::ObjectAssignmentTarget(box ref value) => value.export(),
               AssignmentTargetOrAssignmentTargetWithInitializer::ArrayAssignmentTarget(box ref value) => value.export(),
               AssignmentTargetOrAssignmentTargetWithInitializer::ComputedMemberAssignmentTarget(box ref value) => value.export(),
               AssignmentTargetOrAssignmentTargetWithInitializer::StaticMemberAssignmentTarget(box ref value) => value.export(),
               AssignmentTargetOrAssignmentTargetWithInitializer::AssignmentTargetWithInitializer(box ref value) => value.export(),
               AssignmentTargetOrAssignmentTargetWithInitializer::AssignmentTargetIdentifier(box ref value) => value.export()
            }
        }
    }


    impl Walker for AssignmentTargetOrAssignmentTargetWithInitializer {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               AssignmentTargetOrAssignmentTargetWithInitializer::ObjectAssignmentTarget(box ref mut value) => value.walk(path, visitor),
               AssignmentTargetOrAssignmentTargetWithInitializer::ArrayAssignmentTarget(box ref mut value) => value.walk(path, visitor),
               AssignmentTargetOrAssignmentTargetWithInitializer::ComputedMemberAssignmentTarget(box ref mut value) => value.walk(path, visitor),
               AssignmentTargetOrAssignmentTargetWithInitializer::StaticMemberAssignmentTarget(box ref mut value) => value.walk(path, visitor),
               AssignmentTargetOrAssignmentTargetWithInitializer::AssignmentTargetWithInitializer(box ref mut value) => value.walk(path, visitor),
               AssignmentTargetOrAssignmentTargetWithInitializer::AssignmentTargetIdentifier(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum AssignmentTargetPattern {
        ArrayAssignmentTarget(Box<ArrayAssignmentTarget>),
        ObjectAssignmentTarget(Box<ObjectAssignmentTarget>)
    }

    impl FromJSON for AssignmentTargetPattern {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("ArrayAssignmentTarget") => Ok(AssignmentTargetPattern::ArrayAssignmentTarget(Box::new(FromJSON::import(value)?))),
               Some("ObjectAssignmentTarget") => Ok(AssignmentTargetPattern::ObjectAssignmentTarget(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of AssignmentTargetPattern".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for AssignmentTargetPattern {
        fn export(&self) -> JSON {
            match *self {
               AssignmentTargetPattern::ArrayAssignmentTarget(box ref value) => value.export(),
               AssignmentTargetPattern::ObjectAssignmentTarget(box ref value) => value.export()
            }
        }
    }


    impl Walker for AssignmentTargetPattern {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               AssignmentTargetPattern::ArrayAssignmentTarget(box ref mut value) => value.walk(path, visitor),
               AssignmentTargetPattern::ObjectAssignmentTarget(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum AssignmentTargetProperty {
        AssignmentTargetPropertyIdentifier(Box<AssignmentTargetPropertyIdentifier>),
        AssignmentTargetPropertyProperty(Box<AssignmentTargetPropertyProperty>)
    }

    impl FromJSON for AssignmentTargetProperty {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("AssignmentTargetPropertyIdentifier") => Ok(AssignmentTargetProperty::AssignmentTargetPropertyIdentifier(Box::new(FromJSON::import(value)?))),
               Some("AssignmentTargetPropertyProperty") => Ok(AssignmentTargetProperty::AssignmentTargetPropertyProperty(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of AssignmentTargetProperty".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for AssignmentTargetProperty {
        fn export(&self) -> JSON {
            match *self {
               AssignmentTargetProperty::AssignmentTargetPropertyIdentifier(box ref value) => value.export(),
               AssignmentTargetProperty::AssignmentTargetPropertyProperty(box ref value) => value.export()
            }
        }
    }


    impl Walker for AssignmentTargetProperty {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               AssignmentTargetProperty::AssignmentTargetPropertyIdentifier(box ref mut value) => value.walk(path, visitor),
               AssignmentTargetProperty::AssignmentTargetPropertyProperty(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum Binding {
        ObjectBinding(Box<ObjectBinding>),
        ArrayBinding(Box<ArrayBinding>),
        BindingIdentifier(Box<BindingIdentifier>)
    }

    impl FromJSON for Binding {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("ObjectBinding") => Ok(Binding::ObjectBinding(Box::new(FromJSON::import(value)?))),
               Some("ArrayBinding") => Ok(Binding::ArrayBinding(Box::new(FromJSON::import(value)?))),
               Some("BindingIdentifier") => Ok(Binding::BindingIdentifier(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of Binding".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for Binding {
        fn export(&self) -> JSON {
            match *self {
               Binding::ObjectBinding(box ref value) => value.export(),
               Binding::ArrayBinding(box ref value) => value.export(),
               Binding::BindingIdentifier(box ref value) => value.export()
            }
        }
    }


    impl Walker for Binding {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               Binding::ObjectBinding(box ref mut value) => value.walk(path, visitor),
               Binding::ArrayBinding(box ref mut value) => value.walk(path, visitor),
               Binding::BindingIdentifier(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum BindingOrBindingWithInitializer {
        BindingWithInitializer(Box<BindingWithInitializer>),
        ArrayBinding(Box<ArrayBinding>),
        BindingIdentifier(Box<BindingIdentifier>),
        ObjectBinding(Box<ObjectBinding>)
    }

    impl FromJSON for BindingOrBindingWithInitializer {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("BindingWithInitializer") => Ok(BindingOrBindingWithInitializer::BindingWithInitializer(Box::new(FromJSON::import(value)?))),
               Some("ArrayBinding") => Ok(BindingOrBindingWithInitializer::ArrayBinding(Box::new(FromJSON::import(value)?))),
               Some("BindingIdentifier") => Ok(BindingOrBindingWithInitializer::BindingIdentifier(Box::new(FromJSON::import(value)?))),
               Some("ObjectBinding") => Ok(BindingOrBindingWithInitializer::ObjectBinding(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of BindingOrBindingWithInitializer".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for BindingOrBindingWithInitializer {
        fn export(&self) -> JSON {
            match *self {
               BindingOrBindingWithInitializer::BindingWithInitializer(box ref value) => value.export(),
               BindingOrBindingWithInitializer::ArrayBinding(box ref value) => value.export(),
               BindingOrBindingWithInitializer::BindingIdentifier(box ref value) => value.export(),
               BindingOrBindingWithInitializer::ObjectBinding(box ref value) => value.export()
            }
        }
    }


    impl Walker for BindingOrBindingWithInitializer {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               BindingOrBindingWithInitializer::BindingWithInitializer(box ref mut value) => value.walk(path, visitor),
               BindingOrBindingWithInitializer::ArrayBinding(box ref mut value) => value.walk(path, visitor),
               BindingOrBindingWithInitializer::BindingIdentifier(box ref mut value) => value.walk(path, visitor),
               BindingOrBindingWithInitializer::ObjectBinding(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum BindingPattern {
        ArrayBinding(Box<ArrayBinding>),
        ObjectBinding(Box<ObjectBinding>)
    }

    impl FromJSON for BindingPattern {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("ArrayBinding") => Ok(BindingPattern::ArrayBinding(Box::new(FromJSON::import(value)?))),
               Some("ObjectBinding") => Ok(BindingPattern::ObjectBinding(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of BindingPattern".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for BindingPattern {
        fn export(&self) -> JSON {
            match *self {
               BindingPattern::ArrayBinding(box ref value) => value.export(),
               BindingPattern::ObjectBinding(box ref value) => value.export()
            }
        }
    }


    impl Walker for BindingPattern {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               BindingPattern::ArrayBinding(box ref mut value) => value.walk(path, visitor),
               BindingPattern::ObjectBinding(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum BindingProperty {
        BindingPropertyIdentifier(Box<BindingPropertyIdentifier>),
        BindingPropertyProperty(Box<BindingPropertyProperty>)
    }

    impl FromJSON for BindingProperty {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("BindingPropertyIdentifier") => Ok(BindingProperty::BindingPropertyIdentifier(Box::new(FromJSON::import(value)?))),
               Some("BindingPropertyProperty") => Ok(BindingProperty::BindingPropertyProperty(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of BindingProperty".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for BindingProperty {
        fn export(&self) -> JSON {
            match *self {
               BindingProperty::BindingPropertyIdentifier(box ref value) => value.export(),
               BindingProperty::BindingPropertyProperty(box ref value) => value.export()
            }
        }
    }


    impl Walker for BindingProperty {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               BindingProperty::BindingPropertyIdentifier(box ref mut value) => value.walk(path, visitor),
               BindingProperty::BindingPropertyProperty(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum ExportDeclaration {
        ExportAllFrom(Box<ExportAllFrom>),
        ExportLocals(Box<ExportLocals>),
        ExportFrom(Box<ExportFrom>),
        Export(Box<Export>),
        ExportDefault(Box<ExportDefault>)
    }

    impl FromJSON for ExportDeclaration {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("ExportAllFrom") => Ok(ExportDeclaration::ExportAllFrom(Box::new(FromJSON::import(value)?))),
               Some("ExportLocals") => Ok(ExportDeclaration::ExportLocals(Box::new(FromJSON::import(value)?))),
               Some("ExportFrom") => Ok(ExportDeclaration::ExportFrom(Box::new(FromJSON::import(value)?))),
               Some("Export") => Ok(ExportDeclaration::Export(Box::new(FromJSON::import(value)?))),
               Some("ExportDefault") => Ok(ExportDeclaration::ExportDefault(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of ExportDeclaration".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for ExportDeclaration {
        fn export(&self) -> JSON {
            match *self {
               ExportDeclaration::ExportAllFrom(box ref value) => value.export(),
               ExportDeclaration::ExportLocals(box ref value) => value.export(),
               ExportDeclaration::ExportFrom(box ref value) => value.export(),
               ExportDeclaration::Export(box ref value) => value.export(),
               ExportDeclaration::ExportDefault(box ref value) => value.export()
            }
        }
    }


    impl Walker for ExportDeclaration {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               ExportDeclaration::ExportAllFrom(box ref mut value) => value.walk(path, visitor),
               ExportDeclaration::ExportLocals(box ref mut value) => value.walk(path, visitor),
               ExportDeclaration::ExportFrom(box ref mut value) => value.walk(path, visitor),
               ExportDeclaration::Export(box ref mut value) => value.walk(path, visitor),
               ExportDeclaration::ExportDefault(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum Expression {
        LiteralRegExpExpression(Box<LiteralRegExpExpression>),
        ArrowExpression(Box<ArrowExpression>),
        BinaryExpression(Box<BinaryExpression>),
        IdentifierExpression(Box<IdentifierExpression>),
        NewTargetExpression(Box<NewTargetExpression>),
        ThisExpression(Box<ThisExpression>),
        UnaryExpression(Box<UnaryExpression>),
        TemplateExpression(Box<TemplateExpression>),
        ArrayExpression(Box<ArrayExpression>),
        LiteralStringExpression(Box<LiteralStringExpression>),
        CallExpression(Box<CallExpression>),
        ClassExpression(Box<ClassExpression>),
        StaticMemberExpression(Box<StaticMemberExpression>),
        YieldStarExpression(Box<YieldStarExpression>),
        LiteralNumericExpression(Box<LiteralNumericExpression>),
        NewExpression(Box<NewExpression>),
        ObjectExpression(Box<ObjectExpression>),
        AssignmentExpression(Box<AssignmentExpression>),
        FunctionExpression(Box<FunctionExpression>),
        LiteralBooleanExpression(Box<LiteralBooleanExpression>),
        ConditionalExpression(Box<ConditionalExpression>),
        LiteralNullExpression(Box<LiteralNullExpression>),
        AwaitExpression(Box<AwaitExpression>),
        LiteralInfinityExpression(Box<LiteralInfinityExpression>),
        YieldExpression(Box<YieldExpression>),
        CompoundAssignmentExpression(Box<CompoundAssignmentExpression>),
        UpdateExpression(Box<UpdateExpression>),
        ComputedMemberExpression(Box<ComputedMemberExpression>)
    }

    impl FromJSON for Expression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("LiteralRegExpExpression") => Ok(Expression::LiteralRegExpExpression(Box::new(FromJSON::import(value)?))),
               Some("ArrowExpression") => Ok(Expression::ArrowExpression(Box::new(FromJSON::import(value)?))),
               Some("BinaryExpression") => Ok(Expression::BinaryExpression(Box::new(FromJSON::import(value)?))),
               Some("IdentifierExpression") => Ok(Expression::IdentifierExpression(Box::new(FromJSON::import(value)?))),
               Some("NewTargetExpression") => Ok(Expression::NewTargetExpression(Box::new(FromJSON::import(value)?))),
               Some("ThisExpression") => Ok(Expression::ThisExpression(Box::new(FromJSON::import(value)?))),
               Some("UnaryExpression") => Ok(Expression::UnaryExpression(Box::new(FromJSON::import(value)?))),
               Some("TemplateExpression") => Ok(Expression::TemplateExpression(Box::new(FromJSON::import(value)?))),
               Some("ArrayExpression") => Ok(Expression::ArrayExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralStringExpression") => Ok(Expression::LiteralStringExpression(Box::new(FromJSON::import(value)?))),
               Some("CallExpression") => Ok(Expression::CallExpression(Box::new(FromJSON::import(value)?))),
               Some("ClassExpression") => Ok(Expression::ClassExpression(Box::new(FromJSON::import(value)?))),
               Some("StaticMemberExpression") => Ok(Expression::StaticMemberExpression(Box::new(FromJSON::import(value)?))),
               Some("YieldStarExpression") => Ok(Expression::YieldStarExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralNumericExpression") => Ok(Expression::LiteralNumericExpression(Box::new(FromJSON::import(value)?))),
               Some("NewExpression") => Ok(Expression::NewExpression(Box::new(FromJSON::import(value)?))),
               Some("ObjectExpression") => Ok(Expression::ObjectExpression(Box::new(FromJSON::import(value)?))),
               Some("AssignmentExpression") => Ok(Expression::AssignmentExpression(Box::new(FromJSON::import(value)?))),
               Some("FunctionExpression") => Ok(Expression::FunctionExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralBooleanExpression") => Ok(Expression::LiteralBooleanExpression(Box::new(FromJSON::import(value)?))),
               Some("ConditionalExpression") => Ok(Expression::ConditionalExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralNullExpression") => Ok(Expression::LiteralNullExpression(Box::new(FromJSON::import(value)?))),
               Some("AwaitExpression") => Ok(Expression::AwaitExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralInfinityExpression") => Ok(Expression::LiteralInfinityExpression(Box::new(FromJSON::import(value)?))),
               Some("YieldExpression") => Ok(Expression::YieldExpression(Box::new(FromJSON::import(value)?))),
               Some("CompoundAssignmentExpression") => Ok(Expression::CompoundAssignmentExpression(Box::new(FromJSON::import(value)?))),
               Some("UpdateExpression") => Ok(Expression::UpdateExpression(Box::new(FromJSON::import(value)?))),
               Some("ComputedMemberExpression") => Ok(Expression::ComputedMemberExpression(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of Expression".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for Expression {
        fn export(&self) -> JSON {
            match *self {
               Expression::LiteralRegExpExpression(box ref value) => value.export(),
               Expression::ArrowExpression(box ref value) => value.export(),
               Expression::BinaryExpression(box ref value) => value.export(),
               Expression::IdentifierExpression(box ref value) => value.export(),
               Expression::NewTargetExpression(box ref value) => value.export(),
               Expression::ThisExpression(box ref value) => value.export(),
               Expression::UnaryExpression(box ref value) => value.export(),
               Expression::TemplateExpression(box ref value) => value.export(),
               Expression::ArrayExpression(box ref value) => value.export(),
               Expression::LiteralStringExpression(box ref value) => value.export(),
               Expression::CallExpression(box ref value) => value.export(),
               Expression::ClassExpression(box ref value) => value.export(),
               Expression::StaticMemberExpression(box ref value) => value.export(),
               Expression::YieldStarExpression(box ref value) => value.export(),
               Expression::LiteralNumericExpression(box ref value) => value.export(),
               Expression::NewExpression(box ref value) => value.export(),
               Expression::ObjectExpression(box ref value) => value.export(),
               Expression::AssignmentExpression(box ref value) => value.export(),
               Expression::FunctionExpression(box ref value) => value.export(),
               Expression::LiteralBooleanExpression(box ref value) => value.export(),
               Expression::ConditionalExpression(box ref value) => value.export(),
               Expression::LiteralNullExpression(box ref value) => value.export(),
               Expression::AwaitExpression(box ref value) => value.export(),
               Expression::LiteralInfinityExpression(box ref value) => value.export(),
               Expression::YieldExpression(box ref value) => value.export(),
               Expression::CompoundAssignmentExpression(box ref value) => value.export(),
               Expression::UpdateExpression(box ref value) => value.export(),
               Expression::ComputedMemberExpression(box ref value) => value.export()
            }
        }
    }


    impl Walker for Expression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               Expression::LiteralRegExpExpression(box ref mut value) => value.walk(path, visitor),
               Expression::ArrowExpression(box ref mut value) => value.walk(path, visitor),
               Expression::BinaryExpression(box ref mut value) => value.walk(path, visitor),
               Expression::IdentifierExpression(box ref mut value) => value.walk(path, visitor),
               Expression::NewTargetExpression(box ref mut value) => value.walk(path, visitor),
               Expression::ThisExpression(box ref mut value) => value.walk(path, visitor),
               Expression::UnaryExpression(box ref mut value) => value.walk(path, visitor),
               Expression::TemplateExpression(box ref mut value) => value.walk(path, visitor),
               Expression::ArrayExpression(box ref mut value) => value.walk(path, visitor),
               Expression::LiteralStringExpression(box ref mut value) => value.walk(path, visitor),
               Expression::CallExpression(box ref mut value) => value.walk(path, visitor),
               Expression::ClassExpression(box ref mut value) => value.walk(path, visitor),
               Expression::StaticMemberExpression(box ref mut value) => value.walk(path, visitor),
               Expression::YieldStarExpression(box ref mut value) => value.walk(path, visitor),
               Expression::LiteralNumericExpression(box ref mut value) => value.walk(path, visitor),
               Expression::NewExpression(box ref mut value) => value.walk(path, visitor),
               Expression::ObjectExpression(box ref mut value) => value.walk(path, visitor),
               Expression::AssignmentExpression(box ref mut value) => value.walk(path, visitor),
               Expression::FunctionExpression(box ref mut value) => value.walk(path, visitor),
               Expression::LiteralBooleanExpression(box ref mut value) => value.walk(path, visitor),
               Expression::ConditionalExpression(box ref mut value) => value.walk(path, visitor),
               Expression::LiteralNullExpression(box ref mut value) => value.walk(path, visitor),
               Expression::AwaitExpression(box ref mut value) => value.walk(path, visitor),
               Expression::LiteralInfinityExpression(box ref mut value) => value.walk(path, visitor),
               Expression::YieldExpression(box ref mut value) => value.walk(path, visitor),
               Expression::CompoundAssignmentExpression(box ref mut value) => value.walk(path, visitor),
               Expression::UpdateExpression(box ref mut value) => value.walk(path, visitor),
               Expression::ComputedMemberExpression(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum ExpressionOrSuper {
        IdentifierExpression(Box<IdentifierExpression>),
        NewTargetExpression(Box<NewTargetExpression>),
        ThisExpression(Box<ThisExpression>),
        LiteralBooleanExpression(Box<LiteralBooleanExpression>),
        UnaryExpression(Box<UnaryExpression>),
        StaticMemberExpression(Box<StaticMemberExpression>),
        UpdateExpression(Box<UpdateExpression>),
        ArrowExpression(Box<ArrowExpression>),
        ComputedMemberExpression(Box<ComputedMemberExpression>),
        LiteralNumericExpression(Box<LiteralNumericExpression>),
        TemplateExpression(Box<TemplateExpression>),
        ConditionalExpression(Box<ConditionalExpression>),
        BinaryExpression(Box<BinaryExpression>),
        CompoundAssignmentExpression(Box<CompoundAssignmentExpression>),
        ClassExpression(Box<ClassExpression>),
        Super(Box<Super>),
        YieldStarExpression(Box<YieldStarExpression>),
        LiteralStringExpression(Box<LiteralStringExpression>),
        NewExpression(Box<NewExpression>),
        FunctionExpression(Box<FunctionExpression>),
        LiteralNullExpression(Box<LiteralNullExpression>),
        LiteralInfinityExpression(Box<LiteralInfinityExpression>),
        CallExpression(Box<CallExpression>),
        ArrayExpression(Box<ArrayExpression>),
        AwaitExpression(Box<AwaitExpression>),
        AssignmentExpression(Box<AssignmentExpression>),
        LiteralRegExpExpression(Box<LiteralRegExpExpression>),
        YieldExpression(Box<YieldExpression>),
        ObjectExpression(Box<ObjectExpression>)
    }

    impl FromJSON for ExpressionOrSuper {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("IdentifierExpression") => Ok(ExpressionOrSuper::IdentifierExpression(Box::new(FromJSON::import(value)?))),
               Some("NewTargetExpression") => Ok(ExpressionOrSuper::NewTargetExpression(Box::new(FromJSON::import(value)?))),
               Some("ThisExpression") => Ok(ExpressionOrSuper::ThisExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralBooleanExpression") => Ok(ExpressionOrSuper::LiteralBooleanExpression(Box::new(FromJSON::import(value)?))),
               Some("UnaryExpression") => Ok(ExpressionOrSuper::UnaryExpression(Box::new(FromJSON::import(value)?))),
               Some("StaticMemberExpression") => Ok(ExpressionOrSuper::StaticMemberExpression(Box::new(FromJSON::import(value)?))),
               Some("UpdateExpression") => Ok(ExpressionOrSuper::UpdateExpression(Box::new(FromJSON::import(value)?))),
               Some("ArrowExpression") => Ok(ExpressionOrSuper::ArrowExpression(Box::new(FromJSON::import(value)?))),
               Some("ComputedMemberExpression") => Ok(ExpressionOrSuper::ComputedMemberExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralNumericExpression") => Ok(ExpressionOrSuper::LiteralNumericExpression(Box::new(FromJSON::import(value)?))),
               Some("TemplateExpression") => Ok(ExpressionOrSuper::TemplateExpression(Box::new(FromJSON::import(value)?))),
               Some("ConditionalExpression") => Ok(ExpressionOrSuper::ConditionalExpression(Box::new(FromJSON::import(value)?))),
               Some("BinaryExpression") => Ok(ExpressionOrSuper::BinaryExpression(Box::new(FromJSON::import(value)?))),
               Some("CompoundAssignmentExpression") => Ok(ExpressionOrSuper::CompoundAssignmentExpression(Box::new(FromJSON::import(value)?))),
               Some("ClassExpression") => Ok(ExpressionOrSuper::ClassExpression(Box::new(FromJSON::import(value)?))),
               Some("Super") => Ok(ExpressionOrSuper::Super(Box::new(FromJSON::import(value)?))),
               Some("YieldStarExpression") => Ok(ExpressionOrSuper::YieldStarExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralStringExpression") => Ok(ExpressionOrSuper::LiteralStringExpression(Box::new(FromJSON::import(value)?))),
               Some("NewExpression") => Ok(ExpressionOrSuper::NewExpression(Box::new(FromJSON::import(value)?))),
               Some("FunctionExpression") => Ok(ExpressionOrSuper::FunctionExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralNullExpression") => Ok(ExpressionOrSuper::LiteralNullExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralInfinityExpression") => Ok(ExpressionOrSuper::LiteralInfinityExpression(Box::new(FromJSON::import(value)?))),
               Some("CallExpression") => Ok(ExpressionOrSuper::CallExpression(Box::new(FromJSON::import(value)?))),
               Some("ArrayExpression") => Ok(ExpressionOrSuper::ArrayExpression(Box::new(FromJSON::import(value)?))),
               Some("AwaitExpression") => Ok(ExpressionOrSuper::AwaitExpression(Box::new(FromJSON::import(value)?))),
               Some("AssignmentExpression") => Ok(ExpressionOrSuper::AssignmentExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralRegExpExpression") => Ok(ExpressionOrSuper::LiteralRegExpExpression(Box::new(FromJSON::import(value)?))),
               Some("YieldExpression") => Ok(ExpressionOrSuper::YieldExpression(Box::new(FromJSON::import(value)?))),
               Some("ObjectExpression") => Ok(ExpressionOrSuper::ObjectExpression(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of ExpressionOrSuper".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for ExpressionOrSuper {
        fn export(&self) -> JSON {
            match *self {
               ExpressionOrSuper::IdentifierExpression(box ref value) => value.export(),
               ExpressionOrSuper::NewTargetExpression(box ref value) => value.export(),
               ExpressionOrSuper::ThisExpression(box ref value) => value.export(),
               ExpressionOrSuper::LiteralBooleanExpression(box ref value) => value.export(),
               ExpressionOrSuper::UnaryExpression(box ref value) => value.export(),
               ExpressionOrSuper::StaticMemberExpression(box ref value) => value.export(),
               ExpressionOrSuper::UpdateExpression(box ref value) => value.export(),
               ExpressionOrSuper::ArrowExpression(box ref value) => value.export(),
               ExpressionOrSuper::ComputedMemberExpression(box ref value) => value.export(),
               ExpressionOrSuper::LiteralNumericExpression(box ref value) => value.export(),
               ExpressionOrSuper::TemplateExpression(box ref value) => value.export(),
               ExpressionOrSuper::ConditionalExpression(box ref value) => value.export(),
               ExpressionOrSuper::BinaryExpression(box ref value) => value.export(),
               ExpressionOrSuper::CompoundAssignmentExpression(box ref value) => value.export(),
               ExpressionOrSuper::ClassExpression(box ref value) => value.export(),
               ExpressionOrSuper::Super(box ref value) => value.export(),
               ExpressionOrSuper::YieldStarExpression(box ref value) => value.export(),
               ExpressionOrSuper::LiteralStringExpression(box ref value) => value.export(),
               ExpressionOrSuper::NewExpression(box ref value) => value.export(),
               ExpressionOrSuper::FunctionExpression(box ref value) => value.export(),
               ExpressionOrSuper::LiteralNullExpression(box ref value) => value.export(),
               ExpressionOrSuper::LiteralInfinityExpression(box ref value) => value.export(),
               ExpressionOrSuper::CallExpression(box ref value) => value.export(),
               ExpressionOrSuper::ArrayExpression(box ref value) => value.export(),
               ExpressionOrSuper::AwaitExpression(box ref value) => value.export(),
               ExpressionOrSuper::AssignmentExpression(box ref value) => value.export(),
               ExpressionOrSuper::LiteralRegExpExpression(box ref value) => value.export(),
               ExpressionOrSuper::YieldExpression(box ref value) => value.export(),
               ExpressionOrSuper::ObjectExpression(box ref value) => value.export()
            }
        }
    }


    impl Walker for ExpressionOrSuper {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               ExpressionOrSuper::IdentifierExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::NewTargetExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::ThisExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::LiteralBooleanExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::UnaryExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::StaticMemberExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::UpdateExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::ArrowExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::ComputedMemberExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::LiteralNumericExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::TemplateExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::ConditionalExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::BinaryExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::CompoundAssignmentExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::ClassExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::Super(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::YieldStarExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::LiteralStringExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::NewExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::FunctionExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::LiteralNullExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::LiteralInfinityExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::CallExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::ArrayExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::AwaitExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::AssignmentExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::LiteralRegExpExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::YieldExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrSuper::ObjectExpression(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum ExpressionOrTemplateElement {
        LiteralStringExpression(Box<LiteralStringExpression>),
        YieldStarExpression(Box<YieldStarExpression>),
        ClassExpression(Box<ClassExpression>),
        YieldExpression(Box<YieldExpression>),
        StaticMemberExpression(Box<StaticMemberExpression>),
        IdentifierExpression(Box<IdentifierExpression>),
        TemplateElement(Box<TemplateElement>),
        LiteralInfinityExpression(Box<LiteralInfinityExpression>),
        ArrayExpression(Box<ArrayExpression>),
        CompoundAssignmentExpression(Box<CompoundAssignmentExpression>),
        TemplateExpression(Box<TemplateExpression>),
        AwaitExpression(Box<AwaitExpression>),
        LiteralRegExpExpression(Box<LiteralRegExpExpression>),
        ConditionalExpression(Box<ConditionalExpression>),
        ThisExpression(Box<ThisExpression>),
        ComputedMemberExpression(Box<ComputedMemberExpression>),
        ObjectExpression(Box<ObjectExpression>),
        LiteralNumericExpression(Box<LiteralNumericExpression>),
        LiteralBooleanExpression(Box<LiteralBooleanExpression>),
        CallExpression(Box<CallExpression>),
        LiteralNullExpression(Box<LiteralNullExpression>),
        NewTargetExpression(Box<NewTargetExpression>),
        NewExpression(Box<NewExpression>),
        AssignmentExpression(Box<AssignmentExpression>),
        FunctionExpression(Box<FunctionExpression>),
        BinaryExpression(Box<BinaryExpression>),
        ArrowExpression(Box<ArrowExpression>),
        UnaryExpression(Box<UnaryExpression>),
        UpdateExpression(Box<UpdateExpression>)
    }

    impl FromJSON for ExpressionOrTemplateElement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("LiteralStringExpression") => Ok(ExpressionOrTemplateElement::LiteralStringExpression(Box::new(FromJSON::import(value)?))),
               Some("YieldStarExpression") => Ok(ExpressionOrTemplateElement::YieldStarExpression(Box::new(FromJSON::import(value)?))),
               Some("ClassExpression") => Ok(ExpressionOrTemplateElement::ClassExpression(Box::new(FromJSON::import(value)?))),
               Some("YieldExpression") => Ok(ExpressionOrTemplateElement::YieldExpression(Box::new(FromJSON::import(value)?))),
               Some("StaticMemberExpression") => Ok(ExpressionOrTemplateElement::StaticMemberExpression(Box::new(FromJSON::import(value)?))),
               Some("IdentifierExpression") => Ok(ExpressionOrTemplateElement::IdentifierExpression(Box::new(FromJSON::import(value)?))),
               Some("TemplateElement") => Ok(ExpressionOrTemplateElement::TemplateElement(Box::new(FromJSON::import(value)?))),
               Some("LiteralInfinityExpression") => Ok(ExpressionOrTemplateElement::LiteralInfinityExpression(Box::new(FromJSON::import(value)?))),
               Some("ArrayExpression") => Ok(ExpressionOrTemplateElement::ArrayExpression(Box::new(FromJSON::import(value)?))),
               Some("CompoundAssignmentExpression") => Ok(ExpressionOrTemplateElement::CompoundAssignmentExpression(Box::new(FromJSON::import(value)?))),
               Some("TemplateExpression") => Ok(ExpressionOrTemplateElement::TemplateExpression(Box::new(FromJSON::import(value)?))),
               Some("AwaitExpression") => Ok(ExpressionOrTemplateElement::AwaitExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralRegExpExpression") => Ok(ExpressionOrTemplateElement::LiteralRegExpExpression(Box::new(FromJSON::import(value)?))),
               Some("ConditionalExpression") => Ok(ExpressionOrTemplateElement::ConditionalExpression(Box::new(FromJSON::import(value)?))),
               Some("ThisExpression") => Ok(ExpressionOrTemplateElement::ThisExpression(Box::new(FromJSON::import(value)?))),
               Some("ComputedMemberExpression") => Ok(ExpressionOrTemplateElement::ComputedMemberExpression(Box::new(FromJSON::import(value)?))),
               Some("ObjectExpression") => Ok(ExpressionOrTemplateElement::ObjectExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralNumericExpression") => Ok(ExpressionOrTemplateElement::LiteralNumericExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralBooleanExpression") => Ok(ExpressionOrTemplateElement::LiteralBooleanExpression(Box::new(FromJSON::import(value)?))),
               Some("CallExpression") => Ok(ExpressionOrTemplateElement::CallExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralNullExpression") => Ok(ExpressionOrTemplateElement::LiteralNullExpression(Box::new(FromJSON::import(value)?))),
               Some("NewTargetExpression") => Ok(ExpressionOrTemplateElement::NewTargetExpression(Box::new(FromJSON::import(value)?))),
               Some("NewExpression") => Ok(ExpressionOrTemplateElement::NewExpression(Box::new(FromJSON::import(value)?))),
               Some("AssignmentExpression") => Ok(ExpressionOrTemplateElement::AssignmentExpression(Box::new(FromJSON::import(value)?))),
               Some("FunctionExpression") => Ok(ExpressionOrTemplateElement::FunctionExpression(Box::new(FromJSON::import(value)?))),
               Some("BinaryExpression") => Ok(ExpressionOrTemplateElement::BinaryExpression(Box::new(FromJSON::import(value)?))),
               Some("ArrowExpression") => Ok(ExpressionOrTemplateElement::ArrowExpression(Box::new(FromJSON::import(value)?))),
               Some("UnaryExpression") => Ok(ExpressionOrTemplateElement::UnaryExpression(Box::new(FromJSON::import(value)?))),
               Some("UpdateExpression") => Ok(ExpressionOrTemplateElement::UpdateExpression(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of ExpressionOrTemplateElement".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for ExpressionOrTemplateElement {
        fn export(&self) -> JSON {
            match *self {
               ExpressionOrTemplateElement::LiteralStringExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::YieldStarExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::ClassExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::YieldExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::StaticMemberExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::IdentifierExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::TemplateElement(box ref value) => value.export(),
               ExpressionOrTemplateElement::LiteralInfinityExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::ArrayExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::CompoundAssignmentExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::TemplateExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::AwaitExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::LiteralRegExpExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::ConditionalExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::ThisExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::ComputedMemberExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::ObjectExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::LiteralNumericExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::LiteralBooleanExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::CallExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::LiteralNullExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::NewTargetExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::NewExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::AssignmentExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::FunctionExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::BinaryExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::ArrowExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::UnaryExpression(box ref value) => value.export(),
               ExpressionOrTemplateElement::UpdateExpression(box ref value) => value.export()
            }
        }
    }


    impl Walker for ExpressionOrTemplateElement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               ExpressionOrTemplateElement::LiteralStringExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::YieldStarExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::ClassExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::YieldExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::StaticMemberExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::IdentifierExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::TemplateElement(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::LiteralInfinityExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::ArrayExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::CompoundAssignmentExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::TemplateExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::AwaitExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::LiteralRegExpExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::ConditionalExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::ThisExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::ComputedMemberExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::ObjectExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::LiteralNumericExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::LiteralBooleanExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::CallExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::LiteralNullExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::NewTargetExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::NewExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::AssignmentExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::FunctionExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::BinaryExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::ArrowExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::UnaryExpression(box ref mut value) => value.walk(path, visitor),
               ExpressionOrTemplateElement::UpdateExpression(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum ForInOfBindingOrAssignmentTarget {
        ForInOfBinding(Box<ForInOfBinding>),
        ObjectAssignmentTarget(Box<ObjectAssignmentTarget>),
        AssignmentTargetIdentifier(Box<AssignmentTargetIdentifier>),
        ComputedMemberAssignmentTarget(Box<ComputedMemberAssignmentTarget>),
        ArrayAssignmentTarget(Box<ArrayAssignmentTarget>),
        StaticMemberAssignmentTarget(Box<StaticMemberAssignmentTarget>)
    }

    impl FromJSON for ForInOfBindingOrAssignmentTarget {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("ForInOfBinding") => Ok(ForInOfBindingOrAssignmentTarget::ForInOfBinding(Box::new(FromJSON::import(value)?))),
               Some("ObjectAssignmentTarget") => Ok(ForInOfBindingOrAssignmentTarget::ObjectAssignmentTarget(Box::new(FromJSON::import(value)?))),
               Some("AssignmentTargetIdentifier") => Ok(ForInOfBindingOrAssignmentTarget::AssignmentTargetIdentifier(Box::new(FromJSON::import(value)?))),
               Some("ComputedMemberAssignmentTarget") => Ok(ForInOfBindingOrAssignmentTarget::ComputedMemberAssignmentTarget(Box::new(FromJSON::import(value)?))),
               Some("ArrayAssignmentTarget") => Ok(ForInOfBindingOrAssignmentTarget::ArrayAssignmentTarget(Box::new(FromJSON::import(value)?))),
               Some("StaticMemberAssignmentTarget") => Ok(ForInOfBindingOrAssignmentTarget::StaticMemberAssignmentTarget(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of ForInOfBindingOrAssignmentTarget".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for ForInOfBindingOrAssignmentTarget {
        fn export(&self) -> JSON {
            match *self {
               ForInOfBindingOrAssignmentTarget::ForInOfBinding(box ref value) => value.export(),
               ForInOfBindingOrAssignmentTarget::ObjectAssignmentTarget(box ref value) => value.export(),
               ForInOfBindingOrAssignmentTarget::AssignmentTargetIdentifier(box ref value) => value.export(),
               ForInOfBindingOrAssignmentTarget::ComputedMemberAssignmentTarget(box ref value) => value.export(),
               ForInOfBindingOrAssignmentTarget::ArrayAssignmentTarget(box ref value) => value.export(),
               ForInOfBindingOrAssignmentTarget::StaticMemberAssignmentTarget(box ref value) => value.export()
            }
        }
    }


    impl Walker for ForInOfBindingOrAssignmentTarget {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               ForInOfBindingOrAssignmentTarget::ForInOfBinding(box ref mut value) => value.walk(path, visitor),
               ForInOfBindingOrAssignmentTarget::ObjectAssignmentTarget(box ref mut value) => value.walk(path, visitor),
               ForInOfBindingOrAssignmentTarget::AssignmentTargetIdentifier(box ref mut value) => value.walk(path, visitor),
               ForInOfBindingOrAssignmentTarget::ComputedMemberAssignmentTarget(box ref mut value) => value.walk(path, visitor),
               ForInOfBindingOrAssignmentTarget::ArrayAssignmentTarget(box ref mut value) => value.walk(path, visitor),
               ForInOfBindingOrAssignmentTarget::StaticMemberAssignmentTarget(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum FunctionBodyOrExpression {
        ThisExpression(Box<ThisExpression>),
        CompoundAssignmentExpression(Box<CompoundAssignmentExpression>),
        ComputedMemberExpression(Box<ComputedMemberExpression>),
        UpdateExpression(Box<UpdateExpression>),
        LiteralBooleanExpression(Box<LiteralBooleanExpression>),
        StaticMemberExpression(Box<StaticMemberExpression>),
        ArrowExpression(Box<ArrowExpression>),
        AssignmentExpression(Box<AssignmentExpression>),
        LiteralNumericExpression(Box<LiteralNumericExpression>),
        BinaryExpression(Box<BinaryExpression>),
        NewExpression(Box<NewExpression>),
        FunctionExpression(Box<FunctionExpression>),
        AwaitExpression(Box<AwaitExpression>),
        NewTargetExpression(Box<NewTargetExpression>),
        UnaryExpression(Box<UnaryExpression>),
        CallExpression(Box<CallExpression>),
        TemplateExpression(Box<TemplateExpression>),
        LiteralNullExpression(Box<LiteralNullExpression>),
        LiteralRegExpExpression(Box<LiteralRegExpExpression>),
        FunctionBody(Box<FunctionBody>),
        YieldStarExpression(Box<YieldStarExpression>),
        ConditionalExpression(Box<ConditionalExpression>),
        LiteralStringExpression(Box<LiteralStringExpression>),
        YieldExpression(Box<YieldExpression>),
        LiteralInfinityExpression(Box<LiteralInfinityExpression>),
        IdentifierExpression(Box<IdentifierExpression>),
        ClassExpression(Box<ClassExpression>),
        ObjectExpression(Box<ObjectExpression>),
        ArrayExpression(Box<ArrayExpression>)
    }

    impl FromJSON for FunctionBodyOrExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("ThisExpression") => Ok(FunctionBodyOrExpression::ThisExpression(Box::new(FromJSON::import(value)?))),
               Some("CompoundAssignmentExpression") => Ok(FunctionBodyOrExpression::CompoundAssignmentExpression(Box::new(FromJSON::import(value)?))),
               Some("ComputedMemberExpression") => Ok(FunctionBodyOrExpression::ComputedMemberExpression(Box::new(FromJSON::import(value)?))),
               Some("UpdateExpression") => Ok(FunctionBodyOrExpression::UpdateExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralBooleanExpression") => Ok(FunctionBodyOrExpression::LiteralBooleanExpression(Box::new(FromJSON::import(value)?))),
               Some("StaticMemberExpression") => Ok(FunctionBodyOrExpression::StaticMemberExpression(Box::new(FromJSON::import(value)?))),
               Some("ArrowExpression") => Ok(FunctionBodyOrExpression::ArrowExpression(Box::new(FromJSON::import(value)?))),
               Some("AssignmentExpression") => Ok(FunctionBodyOrExpression::AssignmentExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralNumericExpression") => Ok(FunctionBodyOrExpression::LiteralNumericExpression(Box::new(FromJSON::import(value)?))),
               Some("BinaryExpression") => Ok(FunctionBodyOrExpression::BinaryExpression(Box::new(FromJSON::import(value)?))),
               Some("NewExpression") => Ok(FunctionBodyOrExpression::NewExpression(Box::new(FromJSON::import(value)?))),
               Some("FunctionExpression") => Ok(FunctionBodyOrExpression::FunctionExpression(Box::new(FromJSON::import(value)?))),
               Some("AwaitExpression") => Ok(FunctionBodyOrExpression::AwaitExpression(Box::new(FromJSON::import(value)?))),
               Some("NewTargetExpression") => Ok(FunctionBodyOrExpression::NewTargetExpression(Box::new(FromJSON::import(value)?))),
               Some("UnaryExpression") => Ok(FunctionBodyOrExpression::UnaryExpression(Box::new(FromJSON::import(value)?))),
               Some("CallExpression") => Ok(FunctionBodyOrExpression::CallExpression(Box::new(FromJSON::import(value)?))),
               Some("TemplateExpression") => Ok(FunctionBodyOrExpression::TemplateExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralNullExpression") => Ok(FunctionBodyOrExpression::LiteralNullExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralRegExpExpression") => Ok(FunctionBodyOrExpression::LiteralRegExpExpression(Box::new(FromJSON::import(value)?))),
               Some("FunctionBody") => Ok(FunctionBodyOrExpression::FunctionBody(Box::new(FromJSON::import(value)?))),
               Some("YieldStarExpression") => Ok(FunctionBodyOrExpression::YieldStarExpression(Box::new(FromJSON::import(value)?))),
               Some("ConditionalExpression") => Ok(FunctionBodyOrExpression::ConditionalExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralStringExpression") => Ok(FunctionBodyOrExpression::LiteralStringExpression(Box::new(FromJSON::import(value)?))),
               Some("YieldExpression") => Ok(FunctionBodyOrExpression::YieldExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralInfinityExpression") => Ok(FunctionBodyOrExpression::LiteralInfinityExpression(Box::new(FromJSON::import(value)?))),
               Some("IdentifierExpression") => Ok(FunctionBodyOrExpression::IdentifierExpression(Box::new(FromJSON::import(value)?))),
               Some("ClassExpression") => Ok(FunctionBodyOrExpression::ClassExpression(Box::new(FromJSON::import(value)?))),
               Some("ObjectExpression") => Ok(FunctionBodyOrExpression::ObjectExpression(Box::new(FromJSON::import(value)?))),
               Some("ArrayExpression") => Ok(FunctionBodyOrExpression::ArrayExpression(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of FunctionBodyOrExpression".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for FunctionBodyOrExpression {
        fn export(&self) -> JSON {
            match *self {
               FunctionBodyOrExpression::ThisExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::CompoundAssignmentExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::ComputedMemberExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::UpdateExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::LiteralBooleanExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::StaticMemberExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::ArrowExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::AssignmentExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::LiteralNumericExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::BinaryExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::NewExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::FunctionExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::AwaitExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::NewTargetExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::UnaryExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::CallExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::TemplateExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::LiteralNullExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::LiteralRegExpExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::FunctionBody(box ref value) => value.export(),
               FunctionBodyOrExpression::YieldStarExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::ConditionalExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::LiteralStringExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::YieldExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::LiteralInfinityExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::IdentifierExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::ClassExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::ObjectExpression(box ref value) => value.export(),
               FunctionBodyOrExpression::ArrayExpression(box ref value) => value.export()
            }
        }
    }


    impl Walker for FunctionBodyOrExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               FunctionBodyOrExpression::ThisExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::CompoundAssignmentExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::ComputedMemberExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::UpdateExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::LiteralBooleanExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::StaticMemberExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::ArrowExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::AssignmentExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::LiteralNumericExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::BinaryExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::NewExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::FunctionExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::AwaitExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::NewTargetExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::UnaryExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::CallExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::TemplateExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::LiteralNullExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::LiteralRegExpExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::FunctionBody(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::YieldStarExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::ConditionalExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::LiteralStringExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::YieldExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::LiteralInfinityExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::IdentifierExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::ClassExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::ObjectExpression(box ref mut value) => value.walk(path, visitor),
               FunctionBodyOrExpression::ArrayExpression(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum FunctionDeclarationOrClassDeclarationOrExpression {
        ObjectExpression(Box<ObjectExpression>),
        NewTargetExpression(Box<NewTargetExpression>),
        YieldStarExpression(Box<YieldStarExpression>),
        AssignmentExpression(Box<AssignmentExpression>),
        StaticMemberExpression(Box<StaticMemberExpression>),
        ArrowExpression(Box<ArrowExpression>),
        UnaryExpression(Box<UnaryExpression>),
        ClassExpression(Box<ClassExpression>),
        UpdateExpression(Box<UpdateExpression>),
        LiteralNullExpression(Box<LiteralNullExpression>),
        CallExpression(Box<CallExpression>),
        LiteralNumericExpression(Box<LiteralNumericExpression>),
        LiteralRegExpExpression(Box<LiteralRegExpExpression>),
        LiteralBooleanExpression(Box<LiteralBooleanExpression>),
        ConditionalExpression(Box<ConditionalExpression>),
        LiteralInfinityExpression(Box<LiteralInfinityExpression>),
        CompoundAssignmentExpression(Box<CompoundAssignmentExpression>),
        LiteralStringExpression(Box<LiteralStringExpression>),
        BinaryExpression(Box<BinaryExpression>),
        NewExpression(Box<NewExpression>),
        ThisExpression(Box<ThisExpression>),
        TemplateExpression(Box<TemplateExpression>),
        FunctionDeclaration(Box<FunctionDeclaration>),
        ComputedMemberExpression(Box<ComputedMemberExpression>),
        IdentifierExpression(Box<IdentifierExpression>),
        FunctionExpression(Box<FunctionExpression>),
        AwaitExpression(Box<AwaitExpression>),
        YieldExpression(Box<YieldExpression>),
        ClassDeclaration(Box<ClassDeclaration>),
        ArrayExpression(Box<ArrayExpression>)
    }

    impl FromJSON for FunctionDeclarationOrClassDeclarationOrExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("ObjectExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::ObjectExpression(Box::new(FromJSON::import(value)?))),
               Some("NewTargetExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::NewTargetExpression(Box::new(FromJSON::import(value)?))),
               Some("YieldStarExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::YieldStarExpression(Box::new(FromJSON::import(value)?))),
               Some("AssignmentExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::AssignmentExpression(Box::new(FromJSON::import(value)?))),
               Some("StaticMemberExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::StaticMemberExpression(Box::new(FromJSON::import(value)?))),
               Some("ArrowExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::ArrowExpression(Box::new(FromJSON::import(value)?))),
               Some("UnaryExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::UnaryExpression(Box::new(FromJSON::import(value)?))),
               Some("ClassExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::ClassExpression(Box::new(FromJSON::import(value)?))),
               Some("UpdateExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::UpdateExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralNullExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::LiteralNullExpression(Box::new(FromJSON::import(value)?))),
               Some("CallExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::CallExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralNumericExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::LiteralNumericExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralRegExpExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::LiteralRegExpExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralBooleanExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::LiteralBooleanExpression(Box::new(FromJSON::import(value)?))),
               Some("ConditionalExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::ConditionalExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralInfinityExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::LiteralInfinityExpression(Box::new(FromJSON::import(value)?))),
               Some("CompoundAssignmentExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::CompoundAssignmentExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralStringExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::LiteralStringExpression(Box::new(FromJSON::import(value)?))),
               Some("BinaryExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::BinaryExpression(Box::new(FromJSON::import(value)?))),
               Some("NewExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::NewExpression(Box::new(FromJSON::import(value)?))),
               Some("ThisExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::ThisExpression(Box::new(FromJSON::import(value)?))),
               Some("TemplateExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::TemplateExpression(Box::new(FromJSON::import(value)?))),
               Some("FunctionDeclaration") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::FunctionDeclaration(Box::new(FromJSON::import(value)?))),
               Some("ComputedMemberExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::ComputedMemberExpression(Box::new(FromJSON::import(value)?))),
               Some("IdentifierExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::IdentifierExpression(Box::new(FromJSON::import(value)?))),
               Some("FunctionExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::FunctionExpression(Box::new(FromJSON::import(value)?))),
               Some("AwaitExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::AwaitExpression(Box::new(FromJSON::import(value)?))),
               Some("YieldExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::YieldExpression(Box::new(FromJSON::import(value)?))),
               Some("ClassDeclaration") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::ClassDeclaration(Box::new(FromJSON::import(value)?))),
               Some("ArrayExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::ArrayExpression(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of FunctionDeclarationOrClassDeclarationOrExpression".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for FunctionDeclarationOrClassDeclarationOrExpression {
        fn export(&self) -> JSON {
            match *self {
               FunctionDeclarationOrClassDeclarationOrExpression::ObjectExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::NewTargetExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::YieldStarExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::AssignmentExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::StaticMemberExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::ArrowExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::UnaryExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::ClassExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::UpdateExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::LiteralNullExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::CallExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::LiteralNumericExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::LiteralRegExpExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::LiteralBooleanExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::ConditionalExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::LiteralInfinityExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::CompoundAssignmentExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::LiteralStringExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::BinaryExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::NewExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::ThisExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::TemplateExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::FunctionDeclaration(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::ComputedMemberExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::IdentifierExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::FunctionExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::AwaitExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::YieldExpression(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::ClassDeclaration(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrExpression::ArrayExpression(box ref value) => value.export()
            }
        }
    }


    impl Walker for FunctionDeclarationOrClassDeclarationOrExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               FunctionDeclarationOrClassDeclarationOrExpression::ObjectExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::NewTargetExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::YieldStarExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::AssignmentExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::StaticMemberExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::ArrowExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::UnaryExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::ClassExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::UpdateExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::LiteralNullExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::CallExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::LiteralNumericExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::LiteralRegExpExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::LiteralBooleanExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::ConditionalExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::LiteralInfinityExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::CompoundAssignmentExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::LiteralStringExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::BinaryExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::NewExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::ThisExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::TemplateExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::FunctionDeclaration(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::ComputedMemberExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::IdentifierExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::FunctionExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::AwaitExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::YieldExpression(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::ClassDeclaration(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrExpression::ArrayExpression(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum FunctionDeclarationOrClassDeclarationOrVariableDeclaration {
        ClassDeclaration(Box<ClassDeclaration>),
        FunctionDeclaration(Box<FunctionDeclaration>),
        VariableDeclaration(Box<VariableDeclaration>)
    }

    impl FromJSON for FunctionDeclarationOrClassDeclarationOrVariableDeclaration {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("ClassDeclaration") => Ok(FunctionDeclarationOrClassDeclarationOrVariableDeclaration::ClassDeclaration(Box::new(FromJSON::import(value)?))),
               Some("FunctionDeclaration") => Ok(FunctionDeclarationOrClassDeclarationOrVariableDeclaration::FunctionDeclaration(Box::new(FromJSON::import(value)?))),
               Some("VariableDeclaration") => Ok(FunctionDeclarationOrClassDeclarationOrVariableDeclaration::VariableDeclaration(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of FunctionDeclarationOrClassDeclarationOrVariableDeclaration".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for FunctionDeclarationOrClassDeclarationOrVariableDeclaration {
        fn export(&self) -> JSON {
            match *self {
               FunctionDeclarationOrClassDeclarationOrVariableDeclaration::ClassDeclaration(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrVariableDeclaration::FunctionDeclaration(box ref value) => value.export(),
               FunctionDeclarationOrClassDeclarationOrVariableDeclaration::VariableDeclaration(box ref value) => value.export()
            }
        }
    }


    impl Walker for FunctionDeclarationOrClassDeclarationOrVariableDeclaration {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               FunctionDeclarationOrClassDeclarationOrVariableDeclaration::ClassDeclaration(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrVariableDeclaration::FunctionDeclaration(box ref mut value) => value.walk(path, visitor),
               FunctionDeclarationOrClassDeclarationOrVariableDeclaration::VariableDeclaration(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum ImportDeclaration {
        Import(Box<Import>),
        ImportNamespace(Box<ImportNamespace>)
    }

    impl FromJSON for ImportDeclaration {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("Import") => Ok(ImportDeclaration::Import(Box::new(FromJSON::import(value)?))),
               Some("ImportNamespace") => Ok(ImportDeclaration::ImportNamespace(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of ImportDeclaration".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for ImportDeclaration {
        fn export(&self) -> JSON {
            match *self {
               ImportDeclaration::Import(box ref value) => value.export(),
               ImportDeclaration::ImportNamespace(box ref value) => value.export()
            }
        }
    }


    impl Walker for ImportDeclaration {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               ImportDeclaration::Import(box ref mut value) => value.walk(path, visitor),
               ImportDeclaration::ImportNamespace(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum ImportDeclarationOrExportDeclarationOrStatement {
        ReturnStatement(Box<ReturnStatement>),
        BreakStatement(Box<BreakStatement>),
        ForOfStatement(Box<ForOfStatement>),
        SwitchStatement(Box<SwitchStatement>),
        Import(Box<Import>),
        EmptyStatement(Box<EmptyStatement>),
        TryCatchStatement(Box<TryCatchStatement>),
        TryFinallyStatement(Box<TryFinallyStatement>),
        SwitchStatementWithDefault(Box<SwitchStatementWithDefault>),
        ContinueStatement(Box<ContinueStatement>),
        IfStatement(Box<IfStatement>),
        ExpressionStatement(Box<ExpressionStatement>),
        WithStatement(Box<WithStatement>),
        ImportNamespace(Box<ImportNamespace>),
        LabelledStatement(Box<LabelledStatement>),
        ForInStatement(Box<ForInStatement>),
        FunctionDeclaration(Box<FunctionDeclaration>),
        ForStatement(Box<ForStatement>),
        VariableDeclaration(Box<VariableDeclaration>),
        Export(Box<Export>),
        ThrowStatement(Box<ThrowStatement>),
        WhileStatement(Box<WhileStatement>),
        ClassDeclaration(Box<ClassDeclaration>),
        DoWhileStatement(Box<DoWhileStatement>),
        DebuggerStatement(Box<DebuggerStatement>),
        ExportDefault(Box<ExportDefault>),
        ExportLocals(Box<ExportLocals>),
        Block(Box<Block>),
        ExportAllFrom(Box<ExportAllFrom>),
        ExportFrom(Box<ExportFrom>)
    }

    impl FromJSON for ImportDeclarationOrExportDeclarationOrStatement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("ReturnStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ReturnStatement(Box::new(FromJSON::import(value)?))),
               Some("BreakStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::BreakStatement(Box::new(FromJSON::import(value)?))),
               Some("ForOfStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ForOfStatement(Box::new(FromJSON::import(value)?))),
               Some("SwitchStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::SwitchStatement(Box::new(FromJSON::import(value)?))),
               Some("Import") => Ok(ImportDeclarationOrExportDeclarationOrStatement::Import(Box::new(FromJSON::import(value)?))),
               Some("EmptyStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::EmptyStatement(Box::new(FromJSON::import(value)?))),
               Some("TryCatchStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::TryCatchStatement(Box::new(FromJSON::import(value)?))),
               Some("TryFinallyStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::TryFinallyStatement(Box::new(FromJSON::import(value)?))),
               Some("SwitchStatementWithDefault") => Ok(ImportDeclarationOrExportDeclarationOrStatement::SwitchStatementWithDefault(Box::new(FromJSON::import(value)?))),
               Some("ContinueStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ContinueStatement(Box::new(FromJSON::import(value)?))),
               Some("IfStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::IfStatement(Box::new(FromJSON::import(value)?))),
               Some("ExpressionStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ExpressionStatement(Box::new(FromJSON::import(value)?))),
               Some("WithStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::WithStatement(Box::new(FromJSON::import(value)?))),
               Some("ImportNamespace") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ImportNamespace(Box::new(FromJSON::import(value)?))),
               Some("LabelledStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::LabelledStatement(Box::new(FromJSON::import(value)?))),
               Some("ForInStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ForInStatement(Box::new(FromJSON::import(value)?))),
               Some("FunctionDeclaration") => Ok(ImportDeclarationOrExportDeclarationOrStatement::FunctionDeclaration(Box::new(FromJSON::import(value)?))),
               Some("ForStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ForStatement(Box::new(FromJSON::import(value)?))),
               Some("VariableDeclaration") => Ok(ImportDeclarationOrExportDeclarationOrStatement::VariableDeclaration(Box::new(FromJSON::import(value)?))),
               Some("Export") => Ok(ImportDeclarationOrExportDeclarationOrStatement::Export(Box::new(FromJSON::import(value)?))),
               Some("ThrowStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ThrowStatement(Box::new(FromJSON::import(value)?))),
               Some("WhileStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::WhileStatement(Box::new(FromJSON::import(value)?))),
               Some("ClassDeclaration") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ClassDeclaration(Box::new(FromJSON::import(value)?))),
               Some("DoWhileStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::DoWhileStatement(Box::new(FromJSON::import(value)?))),
               Some("DebuggerStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::DebuggerStatement(Box::new(FromJSON::import(value)?))),
               Some("ExportDefault") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ExportDefault(Box::new(FromJSON::import(value)?))),
               Some("ExportLocals") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ExportLocals(Box::new(FromJSON::import(value)?))),
               Some("Block") => Ok(ImportDeclarationOrExportDeclarationOrStatement::Block(Box::new(FromJSON::import(value)?))),
               Some("ExportAllFrom") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ExportAllFrom(Box::new(FromJSON::import(value)?))),
               Some("ExportFrom") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ExportFrom(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of ImportDeclarationOrExportDeclarationOrStatement".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for ImportDeclarationOrExportDeclarationOrStatement {
        fn export(&self) -> JSON {
            match *self {
               ImportDeclarationOrExportDeclarationOrStatement::ReturnStatement(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::BreakStatement(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::ForOfStatement(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::SwitchStatement(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::Import(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::EmptyStatement(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::TryCatchStatement(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::TryFinallyStatement(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::SwitchStatementWithDefault(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::ContinueStatement(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::IfStatement(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::ExpressionStatement(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::WithStatement(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::ImportNamespace(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::LabelledStatement(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::ForInStatement(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::FunctionDeclaration(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::ForStatement(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::VariableDeclaration(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::Export(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::ThrowStatement(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::WhileStatement(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::ClassDeclaration(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::DoWhileStatement(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::DebuggerStatement(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::ExportDefault(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::ExportLocals(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::Block(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::ExportAllFrom(box ref value) => value.export(),
               ImportDeclarationOrExportDeclarationOrStatement::ExportFrom(box ref value) => value.export()
            }
        }
    }


    impl Walker for ImportDeclarationOrExportDeclarationOrStatement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               ImportDeclarationOrExportDeclarationOrStatement::ReturnStatement(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::BreakStatement(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::ForOfStatement(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::SwitchStatement(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::Import(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::EmptyStatement(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::TryCatchStatement(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::TryFinallyStatement(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::SwitchStatementWithDefault(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::ContinueStatement(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::IfStatement(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::ExpressionStatement(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::WithStatement(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::ImportNamespace(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::LabelledStatement(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::ForInStatement(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::FunctionDeclaration(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::ForStatement(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::VariableDeclaration(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::Export(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::ThrowStatement(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::WhileStatement(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::ClassDeclaration(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::DoWhileStatement(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::DebuggerStatement(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::ExportDefault(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::ExportLocals(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::Block(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::ExportAllFrom(box ref mut value) => value.walk(path, visitor),
               ImportDeclarationOrExportDeclarationOrStatement::ExportFrom(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum IterationStatement {
        ForStatement(Box<ForStatement>),
        WhileStatement(Box<WhileStatement>),
        ForOfStatement(Box<ForOfStatement>),
        ForInStatement(Box<ForInStatement>),
        DoWhileStatement(Box<DoWhileStatement>)
    }

    impl FromJSON for IterationStatement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("ForStatement") => Ok(IterationStatement::ForStatement(Box::new(FromJSON::import(value)?))),
               Some("WhileStatement") => Ok(IterationStatement::WhileStatement(Box::new(FromJSON::import(value)?))),
               Some("ForOfStatement") => Ok(IterationStatement::ForOfStatement(Box::new(FromJSON::import(value)?))),
               Some("ForInStatement") => Ok(IterationStatement::ForInStatement(Box::new(FromJSON::import(value)?))),
               Some("DoWhileStatement") => Ok(IterationStatement::DoWhileStatement(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of IterationStatement".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for IterationStatement {
        fn export(&self) -> JSON {
            match *self {
               IterationStatement::ForStatement(box ref value) => value.export(),
               IterationStatement::WhileStatement(box ref value) => value.export(),
               IterationStatement::ForOfStatement(box ref value) => value.export(),
               IterationStatement::ForInStatement(box ref value) => value.export(),
               IterationStatement::DoWhileStatement(box ref value) => value.export()
            }
        }
    }


    impl Walker for IterationStatement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               IterationStatement::ForStatement(box ref mut value) => value.walk(path, visitor),
               IterationStatement::WhileStatement(box ref mut value) => value.walk(path, visitor),
               IterationStatement::ForOfStatement(box ref mut value) => value.walk(path, visitor),
               IterationStatement::ForInStatement(box ref mut value) => value.walk(path, visitor),
               IterationStatement::DoWhileStatement(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum Literal {
        LiteralStringExpression(Box<LiteralStringExpression>),
        LiteralNumericExpression(Box<LiteralNumericExpression>),
        LiteralInfinityExpression(Box<LiteralInfinityExpression>),
        LiteralBooleanExpression(Box<LiteralBooleanExpression>),
        LiteralNullExpression(Box<LiteralNullExpression>)
    }

    impl FromJSON for Literal {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("LiteralStringExpression") => Ok(Literal::LiteralStringExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralNumericExpression") => Ok(Literal::LiteralNumericExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralInfinityExpression") => Ok(Literal::LiteralInfinityExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralBooleanExpression") => Ok(Literal::LiteralBooleanExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralNullExpression") => Ok(Literal::LiteralNullExpression(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of Literal".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for Literal {
        fn export(&self) -> JSON {
            match *self {
               Literal::LiteralStringExpression(box ref value) => value.export(),
               Literal::LiteralNumericExpression(box ref value) => value.export(),
               Literal::LiteralInfinityExpression(box ref value) => value.export(),
               Literal::LiteralBooleanExpression(box ref value) => value.export(),
               Literal::LiteralNullExpression(box ref value) => value.export()
            }
        }
    }


    impl Walker for Literal {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               Literal::LiteralStringExpression(box ref mut value) => value.walk(path, visitor),
               Literal::LiteralNumericExpression(box ref mut value) => value.walk(path, visitor),
               Literal::LiteralInfinityExpression(box ref mut value) => value.walk(path, visitor),
               Literal::LiteralBooleanExpression(box ref mut value) => value.walk(path, visitor),
               Literal::LiteralNullExpression(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum MethodDefinition {
        Setter(Box<Setter>),
        Method(Box<Method>),
        Getter(Box<Getter>)
    }

    impl FromJSON for MethodDefinition {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("Setter") => Ok(MethodDefinition::Setter(Box::new(FromJSON::import(value)?))),
               Some("Method") => Ok(MethodDefinition::Method(Box::new(FromJSON::import(value)?))),
               Some("Getter") => Ok(MethodDefinition::Getter(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of MethodDefinition".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for MethodDefinition {
        fn export(&self) -> JSON {
            match *self {
               MethodDefinition::Setter(box ref value) => value.export(),
               MethodDefinition::Method(box ref value) => value.export(),
               MethodDefinition::Getter(box ref value) => value.export()
            }
        }
    }


    impl Walker for MethodDefinition {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               MethodDefinition::Setter(box ref mut value) => value.walk(path, visitor),
               MethodDefinition::Method(box ref mut value) => value.walk(path, visitor),
               MethodDefinition::Getter(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum ObjectProperty {
        Method(Box<Method>),
        Setter(Box<Setter>),
        DataProperty(Box<DataProperty>),
        Getter(Box<Getter>),
        ShorthandProperty(Box<ShorthandProperty>)
    }

    impl FromJSON for ObjectProperty {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("Method") => Ok(ObjectProperty::Method(Box::new(FromJSON::import(value)?))),
               Some("Setter") => Ok(ObjectProperty::Setter(Box::new(FromJSON::import(value)?))),
               Some("DataProperty") => Ok(ObjectProperty::DataProperty(Box::new(FromJSON::import(value)?))),
               Some("Getter") => Ok(ObjectProperty::Getter(Box::new(FromJSON::import(value)?))),
               Some("ShorthandProperty") => Ok(ObjectProperty::ShorthandProperty(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of ObjectProperty".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for ObjectProperty {
        fn export(&self) -> JSON {
            match *self {
               ObjectProperty::Method(box ref value) => value.export(),
               ObjectProperty::Setter(box ref value) => value.export(),
               ObjectProperty::DataProperty(box ref value) => value.export(),
               ObjectProperty::Getter(box ref value) => value.export(),
               ObjectProperty::ShorthandProperty(box ref value) => value.export()
            }
        }
    }


    impl Walker for ObjectProperty {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               ObjectProperty::Method(box ref mut value) => value.walk(path, visitor),
               ObjectProperty::Setter(box ref mut value) => value.walk(path, visitor),
               ObjectProperty::DataProperty(box ref mut value) => value.walk(path, visitor),
               ObjectProperty::Getter(box ref mut value) => value.walk(path, visitor),
               ObjectProperty::ShorthandProperty(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum Parameter {
        ArrayBinding(Box<ArrayBinding>),
        BindingWithInitializer(Box<BindingWithInitializer>),
        BindingIdentifier(Box<BindingIdentifier>),
        ObjectBinding(Box<ObjectBinding>)
    }

    impl FromJSON for Parameter {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("ArrayBinding") => Ok(Parameter::ArrayBinding(Box::new(FromJSON::import(value)?))),
               Some("BindingWithInitializer") => Ok(Parameter::BindingWithInitializer(Box::new(FromJSON::import(value)?))),
               Some("BindingIdentifier") => Ok(Parameter::BindingIdentifier(Box::new(FromJSON::import(value)?))),
               Some("ObjectBinding") => Ok(Parameter::ObjectBinding(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of Parameter".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for Parameter {
        fn export(&self) -> JSON {
            match *self {
               Parameter::ArrayBinding(box ref value) => value.export(),
               Parameter::BindingWithInitializer(box ref value) => value.export(),
               Parameter::BindingIdentifier(box ref value) => value.export(),
               Parameter::ObjectBinding(box ref value) => value.export()
            }
        }
    }


    impl Walker for Parameter {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               Parameter::ArrayBinding(box ref mut value) => value.walk(path, visitor),
               Parameter::BindingWithInitializer(box ref mut value) => value.walk(path, visitor),
               Parameter::BindingIdentifier(box ref mut value) => value.walk(path, visitor),
               Parameter::ObjectBinding(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum Program {
        Module(Box<Module>),
        Script(Box<Script>)
    }

    impl FromJSON for Program {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("Module") => Ok(Program::Module(Box::new(FromJSON::import(value)?))),
               Some("Script") => Ok(Program::Script(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of Program".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for Program {
        fn export(&self) -> JSON {
            match *self {
               Program::Module(box ref value) => value.export(),
               Program::Script(box ref value) => value.export()
            }
        }
    }


    impl Walker for Program {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               Program::Module(box ref mut value) => value.walk(path, visitor),
               Program::Script(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum PropertyName {
        ComputedPropertyName(Box<ComputedPropertyName>),
        LiteralPropertyName(Box<LiteralPropertyName>)
    }

    impl FromJSON for PropertyName {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("ComputedPropertyName") => Ok(PropertyName::ComputedPropertyName(Box::new(FromJSON::import(value)?))),
               Some("LiteralPropertyName") => Ok(PropertyName::LiteralPropertyName(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of PropertyName".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for PropertyName {
        fn export(&self) -> JSON {
            match *self {
               PropertyName::ComputedPropertyName(box ref value) => value.export(),
               PropertyName::LiteralPropertyName(box ref value) => value.export()
            }
        }
    }


    impl Walker for PropertyName {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               PropertyName::ComputedPropertyName(box ref mut value) => value.walk(path, visitor),
               PropertyName::LiteralPropertyName(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum SimpleAssignmentTarget {
        ComputedMemberAssignmentTarget(Box<ComputedMemberAssignmentTarget>),
        StaticMemberAssignmentTarget(Box<StaticMemberAssignmentTarget>),
        AssignmentTargetIdentifier(Box<AssignmentTargetIdentifier>)
    }

    impl FromJSON for SimpleAssignmentTarget {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("ComputedMemberAssignmentTarget") => Ok(SimpleAssignmentTarget::ComputedMemberAssignmentTarget(Box::new(FromJSON::import(value)?))),
               Some("StaticMemberAssignmentTarget") => Ok(SimpleAssignmentTarget::StaticMemberAssignmentTarget(Box::new(FromJSON::import(value)?))),
               Some("AssignmentTargetIdentifier") => Ok(SimpleAssignmentTarget::AssignmentTargetIdentifier(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of SimpleAssignmentTarget".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for SimpleAssignmentTarget {
        fn export(&self) -> JSON {
            match *self {
               SimpleAssignmentTarget::ComputedMemberAssignmentTarget(box ref value) => value.export(),
               SimpleAssignmentTarget::StaticMemberAssignmentTarget(box ref value) => value.export(),
               SimpleAssignmentTarget::AssignmentTargetIdentifier(box ref value) => value.export()
            }
        }
    }


    impl Walker for SimpleAssignmentTarget {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               SimpleAssignmentTarget::ComputedMemberAssignmentTarget(box ref mut value) => value.walk(path, visitor),
               SimpleAssignmentTarget::StaticMemberAssignmentTarget(box ref mut value) => value.walk(path, visitor),
               SimpleAssignmentTarget::AssignmentTargetIdentifier(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum SpreadElementOrExpression {
        ConditionalExpression(Box<ConditionalExpression>),
        LiteralNullExpression(Box<LiteralNullExpression>),
        LiteralInfinityExpression(Box<LiteralInfinityExpression>),
        CallExpression(Box<CallExpression>),
        ThisExpression(Box<ThisExpression>),
        StaticMemberExpression(Box<StaticMemberExpression>),
        NewTargetExpression(Box<NewTargetExpression>),
        LiteralStringExpression(Box<LiteralStringExpression>),
        YieldStarExpression(Box<YieldStarExpression>),
        SpreadElement(Box<SpreadElement>),
        LiteralBooleanExpression(Box<LiteralBooleanExpression>),
        LiteralRegExpExpression(Box<LiteralRegExpExpression>),
        ClassExpression(Box<ClassExpression>),
        AwaitExpression(Box<AwaitExpression>),
        NewExpression(Box<NewExpression>),
        ArrayExpression(Box<ArrayExpression>),
        FunctionExpression(Box<FunctionExpression>),
        ComputedMemberExpression(Box<ComputedMemberExpression>),
        IdentifierExpression(Box<IdentifierExpression>),
        UpdateExpression(Box<UpdateExpression>),
        LiteralNumericExpression(Box<LiteralNumericExpression>),
        BinaryExpression(Box<BinaryExpression>),
        ArrowExpression(Box<ArrowExpression>),
        CompoundAssignmentExpression(Box<CompoundAssignmentExpression>),
        AssignmentExpression(Box<AssignmentExpression>),
        ObjectExpression(Box<ObjectExpression>),
        UnaryExpression(Box<UnaryExpression>),
        YieldExpression(Box<YieldExpression>),
        TemplateExpression(Box<TemplateExpression>)
    }

    impl FromJSON for SpreadElementOrExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("ConditionalExpression") => Ok(SpreadElementOrExpression::ConditionalExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralNullExpression") => Ok(SpreadElementOrExpression::LiteralNullExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralInfinityExpression") => Ok(SpreadElementOrExpression::LiteralInfinityExpression(Box::new(FromJSON::import(value)?))),
               Some("CallExpression") => Ok(SpreadElementOrExpression::CallExpression(Box::new(FromJSON::import(value)?))),
               Some("ThisExpression") => Ok(SpreadElementOrExpression::ThisExpression(Box::new(FromJSON::import(value)?))),
               Some("StaticMemberExpression") => Ok(SpreadElementOrExpression::StaticMemberExpression(Box::new(FromJSON::import(value)?))),
               Some("NewTargetExpression") => Ok(SpreadElementOrExpression::NewTargetExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralStringExpression") => Ok(SpreadElementOrExpression::LiteralStringExpression(Box::new(FromJSON::import(value)?))),
               Some("YieldStarExpression") => Ok(SpreadElementOrExpression::YieldStarExpression(Box::new(FromJSON::import(value)?))),
               Some("SpreadElement") => Ok(SpreadElementOrExpression::SpreadElement(Box::new(FromJSON::import(value)?))),
               Some("LiteralBooleanExpression") => Ok(SpreadElementOrExpression::LiteralBooleanExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralRegExpExpression") => Ok(SpreadElementOrExpression::LiteralRegExpExpression(Box::new(FromJSON::import(value)?))),
               Some("ClassExpression") => Ok(SpreadElementOrExpression::ClassExpression(Box::new(FromJSON::import(value)?))),
               Some("AwaitExpression") => Ok(SpreadElementOrExpression::AwaitExpression(Box::new(FromJSON::import(value)?))),
               Some("NewExpression") => Ok(SpreadElementOrExpression::NewExpression(Box::new(FromJSON::import(value)?))),
               Some("ArrayExpression") => Ok(SpreadElementOrExpression::ArrayExpression(Box::new(FromJSON::import(value)?))),
               Some("FunctionExpression") => Ok(SpreadElementOrExpression::FunctionExpression(Box::new(FromJSON::import(value)?))),
               Some("ComputedMemberExpression") => Ok(SpreadElementOrExpression::ComputedMemberExpression(Box::new(FromJSON::import(value)?))),
               Some("IdentifierExpression") => Ok(SpreadElementOrExpression::IdentifierExpression(Box::new(FromJSON::import(value)?))),
               Some("UpdateExpression") => Ok(SpreadElementOrExpression::UpdateExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralNumericExpression") => Ok(SpreadElementOrExpression::LiteralNumericExpression(Box::new(FromJSON::import(value)?))),
               Some("BinaryExpression") => Ok(SpreadElementOrExpression::BinaryExpression(Box::new(FromJSON::import(value)?))),
               Some("ArrowExpression") => Ok(SpreadElementOrExpression::ArrowExpression(Box::new(FromJSON::import(value)?))),
               Some("CompoundAssignmentExpression") => Ok(SpreadElementOrExpression::CompoundAssignmentExpression(Box::new(FromJSON::import(value)?))),
               Some("AssignmentExpression") => Ok(SpreadElementOrExpression::AssignmentExpression(Box::new(FromJSON::import(value)?))),
               Some("ObjectExpression") => Ok(SpreadElementOrExpression::ObjectExpression(Box::new(FromJSON::import(value)?))),
               Some("UnaryExpression") => Ok(SpreadElementOrExpression::UnaryExpression(Box::new(FromJSON::import(value)?))),
               Some("YieldExpression") => Ok(SpreadElementOrExpression::YieldExpression(Box::new(FromJSON::import(value)?))),
               Some("TemplateExpression") => Ok(SpreadElementOrExpression::TemplateExpression(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of SpreadElementOrExpression".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for SpreadElementOrExpression {
        fn export(&self) -> JSON {
            match *self {
               SpreadElementOrExpression::ConditionalExpression(box ref value) => value.export(),
               SpreadElementOrExpression::LiteralNullExpression(box ref value) => value.export(),
               SpreadElementOrExpression::LiteralInfinityExpression(box ref value) => value.export(),
               SpreadElementOrExpression::CallExpression(box ref value) => value.export(),
               SpreadElementOrExpression::ThisExpression(box ref value) => value.export(),
               SpreadElementOrExpression::StaticMemberExpression(box ref value) => value.export(),
               SpreadElementOrExpression::NewTargetExpression(box ref value) => value.export(),
               SpreadElementOrExpression::LiteralStringExpression(box ref value) => value.export(),
               SpreadElementOrExpression::YieldStarExpression(box ref value) => value.export(),
               SpreadElementOrExpression::SpreadElement(box ref value) => value.export(),
               SpreadElementOrExpression::LiteralBooleanExpression(box ref value) => value.export(),
               SpreadElementOrExpression::LiteralRegExpExpression(box ref value) => value.export(),
               SpreadElementOrExpression::ClassExpression(box ref value) => value.export(),
               SpreadElementOrExpression::AwaitExpression(box ref value) => value.export(),
               SpreadElementOrExpression::NewExpression(box ref value) => value.export(),
               SpreadElementOrExpression::ArrayExpression(box ref value) => value.export(),
               SpreadElementOrExpression::FunctionExpression(box ref value) => value.export(),
               SpreadElementOrExpression::ComputedMemberExpression(box ref value) => value.export(),
               SpreadElementOrExpression::IdentifierExpression(box ref value) => value.export(),
               SpreadElementOrExpression::UpdateExpression(box ref value) => value.export(),
               SpreadElementOrExpression::LiteralNumericExpression(box ref value) => value.export(),
               SpreadElementOrExpression::BinaryExpression(box ref value) => value.export(),
               SpreadElementOrExpression::ArrowExpression(box ref value) => value.export(),
               SpreadElementOrExpression::CompoundAssignmentExpression(box ref value) => value.export(),
               SpreadElementOrExpression::AssignmentExpression(box ref value) => value.export(),
               SpreadElementOrExpression::ObjectExpression(box ref value) => value.export(),
               SpreadElementOrExpression::UnaryExpression(box ref value) => value.export(),
               SpreadElementOrExpression::YieldExpression(box ref value) => value.export(),
               SpreadElementOrExpression::TemplateExpression(box ref value) => value.export()
            }
        }
    }


    impl Walker for SpreadElementOrExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               SpreadElementOrExpression::ConditionalExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::LiteralNullExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::LiteralInfinityExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::CallExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::ThisExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::StaticMemberExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::NewTargetExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::LiteralStringExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::YieldStarExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::SpreadElement(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::LiteralBooleanExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::LiteralRegExpExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::ClassExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::AwaitExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::NewExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::ArrayExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::FunctionExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::ComputedMemberExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::IdentifierExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::UpdateExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::LiteralNumericExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::BinaryExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::ArrowExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::CompoundAssignmentExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::AssignmentExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::ObjectExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::UnaryExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::YieldExpression(box ref mut value) => value.walk(path, visitor),
               SpreadElementOrExpression::TemplateExpression(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum Statement {
        TryFinallyStatement(Box<TryFinallyStatement>),
        DoWhileStatement(Box<DoWhileStatement>),
        ReturnStatement(Box<ReturnStatement>),
        ClassDeclaration(Box<ClassDeclaration>),
        ForStatement(Box<ForStatement>),
        IfStatement(Box<IfStatement>),
        ForInStatement(Box<ForInStatement>),
        TryCatchStatement(Box<TryCatchStatement>),
        ContinueStatement(Box<ContinueStatement>),
        FunctionDeclaration(Box<FunctionDeclaration>),
        ExpressionStatement(Box<ExpressionStatement>),
        VariableDeclaration(Box<VariableDeclaration>),
        ForOfStatement(Box<ForOfStatement>),
        EmptyStatement(Box<EmptyStatement>),
        ThrowStatement(Box<ThrowStatement>),
        BreakStatement(Box<BreakStatement>),
        WhileStatement(Box<WhileStatement>),
        WithStatement(Box<WithStatement>),
        SwitchStatement(Box<SwitchStatement>),
        SwitchStatementWithDefault(Box<SwitchStatementWithDefault>),
        DebuggerStatement(Box<DebuggerStatement>),
        Block(Box<Block>),
        LabelledStatement(Box<LabelledStatement>)
    }

    impl FromJSON for Statement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("TryFinallyStatement") => Ok(Statement::TryFinallyStatement(Box::new(FromJSON::import(value)?))),
               Some("DoWhileStatement") => Ok(Statement::DoWhileStatement(Box::new(FromJSON::import(value)?))),
               Some("ReturnStatement") => Ok(Statement::ReturnStatement(Box::new(FromJSON::import(value)?))),
               Some("ClassDeclaration") => Ok(Statement::ClassDeclaration(Box::new(FromJSON::import(value)?))),
               Some("ForStatement") => Ok(Statement::ForStatement(Box::new(FromJSON::import(value)?))),
               Some("IfStatement") => Ok(Statement::IfStatement(Box::new(FromJSON::import(value)?))),
               Some("ForInStatement") => Ok(Statement::ForInStatement(Box::new(FromJSON::import(value)?))),
               Some("TryCatchStatement") => Ok(Statement::TryCatchStatement(Box::new(FromJSON::import(value)?))),
               Some("ContinueStatement") => Ok(Statement::ContinueStatement(Box::new(FromJSON::import(value)?))),
               Some("FunctionDeclaration") => Ok(Statement::FunctionDeclaration(Box::new(FromJSON::import(value)?))),
               Some("ExpressionStatement") => Ok(Statement::ExpressionStatement(Box::new(FromJSON::import(value)?))),
               Some("VariableDeclaration") => Ok(Statement::VariableDeclaration(Box::new(FromJSON::import(value)?))),
               Some("ForOfStatement") => Ok(Statement::ForOfStatement(Box::new(FromJSON::import(value)?))),
               Some("EmptyStatement") => Ok(Statement::EmptyStatement(Box::new(FromJSON::import(value)?))),
               Some("ThrowStatement") => Ok(Statement::ThrowStatement(Box::new(FromJSON::import(value)?))),
               Some("BreakStatement") => Ok(Statement::BreakStatement(Box::new(FromJSON::import(value)?))),
               Some("WhileStatement") => Ok(Statement::WhileStatement(Box::new(FromJSON::import(value)?))),
               Some("WithStatement") => Ok(Statement::WithStatement(Box::new(FromJSON::import(value)?))),
               Some("SwitchStatement") => Ok(Statement::SwitchStatement(Box::new(FromJSON::import(value)?))),
               Some("SwitchStatementWithDefault") => Ok(Statement::SwitchStatementWithDefault(Box::new(FromJSON::import(value)?))),
               Some("DebuggerStatement") => Ok(Statement::DebuggerStatement(Box::new(FromJSON::import(value)?))),
               Some("Block") => Ok(Statement::Block(Box::new(FromJSON::import(value)?))),
               Some("LabelledStatement") => Ok(Statement::LabelledStatement(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of Statement".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for Statement {
        fn export(&self) -> JSON {
            match *self {
               Statement::TryFinallyStatement(box ref value) => value.export(),
               Statement::DoWhileStatement(box ref value) => value.export(),
               Statement::ReturnStatement(box ref value) => value.export(),
               Statement::ClassDeclaration(box ref value) => value.export(),
               Statement::ForStatement(box ref value) => value.export(),
               Statement::IfStatement(box ref value) => value.export(),
               Statement::ForInStatement(box ref value) => value.export(),
               Statement::TryCatchStatement(box ref value) => value.export(),
               Statement::ContinueStatement(box ref value) => value.export(),
               Statement::FunctionDeclaration(box ref value) => value.export(),
               Statement::ExpressionStatement(box ref value) => value.export(),
               Statement::VariableDeclaration(box ref value) => value.export(),
               Statement::ForOfStatement(box ref value) => value.export(),
               Statement::EmptyStatement(box ref value) => value.export(),
               Statement::ThrowStatement(box ref value) => value.export(),
               Statement::BreakStatement(box ref value) => value.export(),
               Statement::WhileStatement(box ref value) => value.export(),
               Statement::WithStatement(box ref value) => value.export(),
               Statement::SwitchStatement(box ref value) => value.export(),
               Statement::SwitchStatementWithDefault(box ref value) => value.export(),
               Statement::DebuggerStatement(box ref value) => value.export(),
               Statement::Block(box ref value) => value.export(),
               Statement::LabelledStatement(box ref value) => value.export()
            }
        }
    }


    impl Walker for Statement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               Statement::TryFinallyStatement(box ref mut value) => value.walk(path, visitor),
               Statement::DoWhileStatement(box ref mut value) => value.walk(path, visitor),
               Statement::ReturnStatement(box ref mut value) => value.walk(path, visitor),
               Statement::ClassDeclaration(box ref mut value) => value.walk(path, visitor),
               Statement::ForStatement(box ref mut value) => value.walk(path, visitor),
               Statement::IfStatement(box ref mut value) => value.walk(path, visitor),
               Statement::ForInStatement(box ref mut value) => value.walk(path, visitor),
               Statement::TryCatchStatement(box ref mut value) => value.walk(path, visitor),
               Statement::ContinueStatement(box ref mut value) => value.walk(path, visitor),
               Statement::FunctionDeclaration(box ref mut value) => value.walk(path, visitor),
               Statement::ExpressionStatement(box ref mut value) => value.walk(path, visitor),
               Statement::VariableDeclaration(box ref mut value) => value.walk(path, visitor),
               Statement::ForOfStatement(box ref mut value) => value.walk(path, visitor),
               Statement::EmptyStatement(box ref mut value) => value.walk(path, visitor),
               Statement::ThrowStatement(box ref mut value) => value.walk(path, visitor),
               Statement::BreakStatement(box ref mut value) => value.walk(path, visitor),
               Statement::WhileStatement(box ref mut value) => value.walk(path, visitor),
               Statement::WithStatement(box ref mut value) => value.walk(path, visitor),
               Statement::SwitchStatement(box ref mut value) => value.walk(path, visitor),
               Statement::SwitchStatementWithDefault(box ref mut value) => value.walk(path, visitor),
               Statement::DebuggerStatement(box ref mut value) => value.walk(path, visitor),
               Statement::Block(box ref mut value) => value.walk(path, visitor),
               Statement::LabelledStatement(box ref mut value) => value.walk(path, visitor)
            }
        }
    }


    #[derive(PartialEq, Debug, Clone)]
    pub enum VariableDeclarationOrExpression {
        NewExpression(Box<NewExpression>),
        LiteralStringExpression(Box<LiteralStringExpression>),
        ThisExpression(Box<ThisExpression>),
        BinaryExpression(Box<BinaryExpression>),
        StaticMemberExpression(Box<StaticMemberExpression>),
        LiteralRegExpExpression(Box<LiteralRegExpExpression>),
        LiteralBooleanExpression(Box<LiteralBooleanExpression>),
        CompoundAssignmentExpression(Box<CompoundAssignmentExpression>),
        ComputedMemberExpression(Box<ComputedMemberExpression>),
        YieldStarExpression(Box<YieldStarExpression>),
        YieldExpression(Box<YieldExpression>),
        LiteralInfinityExpression(Box<LiteralInfinityExpression>),
        TemplateExpression(Box<TemplateExpression>),
        NewTargetExpression(Box<NewTargetExpression>),
        LiteralNumericExpression(Box<LiteralNumericExpression>),
        AwaitExpression(Box<AwaitExpression>),
        ConditionalExpression(Box<ConditionalExpression>),
        ClassExpression(Box<ClassExpression>),
        AssignmentExpression(Box<AssignmentExpression>),
        UpdateExpression(Box<UpdateExpression>),
        FunctionExpression(Box<FunctionExpression>),
        CallExpression(Box<CallExpression>),
        IdentifierExpression(Box<IdentifierExpression>),
        ObjectExpression(Box<ObjectExpression>),
        ArrayExpression(Box<ArrayExpression>),
        ArrowExpression(Box<ArrowExpression>),
        UnaryExpression(Box<UnaryExpression>),
        VariableDeclaration(Box<VariableDeclaration>),
        LiteralNullExpression(Box<LiteralNullExpression>)
    }

    impl FromJSON for VariableDeclarationOrExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
               Some("NewExpression") => Ok(VariableDeclarationOrExpression::NewExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralStringExpression") => Ok(VariableDeclarationOrExpression::LiteralStringExpression(Box::new(FromJSON::import(value)?))),
               Some("ThisExpression") => Ok(VariableDeclarationOrExpression::ThisExpression(Box::new(FromJSON::import(value)?))),
               Some("BinaryExpression") => Ok(VariableDeclarationOrExpression::BinaryExpression(Box::new(FromJSON::import(value)?))),
               Some("StaticMemberExpression") => Ok(VariableDeclarationOrExpression::StaticMemberExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralRegExpExpression") => Ok(VariableDeclarationOrExpression::LiteralRegExpExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralBooleanExpression") => Ok(VariableDeclarationOrExpression::LiteralBooleanExpression(Box::new(FromJSON::import(value)?))),
               Some("CompoundAssignmentExpression") => Ok(VariableDeclarationOrExpression::CompoundAssignmentExpression(Box::new(FromJSON::import(value)?))),
               Some("ComputedMemberExpression") => Ok(VariableDeclarationOrExpression::ComputedMemberExpression(Box::new(FromJSON::import(value)?))),
               Some("YieldStarExpression") => Ok(VariableDeclarationOrExpression::YieldStarExpression(Box::new(FromJSON::import(value)?))),
               Some("YieldExpression") => Ok(VariableDeclarationOrExpression::YieldExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralInfinityExpression") => Ok(VariableDeclarationOrExpression::LiteralInfinityExpression(Box::new(FromJSON::import(value)?))),
               Some("TemplateExpression") => Ok(VariableDeclarationOrExpression::TemplateExpression(Box::new(FromJSON::import(value)?))),
               Some("NewTargetExpression") => Ok(VariableDeclarationOrExpression::NewTargetExpression(Box::new(FromJSON::import(value)?))),
               Some("LiteralNumericExpression") => Ok(VariableDeclarationOrExpression::LiteralNumericExpression(Box::new(FromJSON::import(value)?))),
               Some("AwaitExpression") => Ok(VariableDeclarationOrExpression::AwaitExpression(Box::new(FromJSON::import(value)?))),
               Some("ConditionalExpression") => Ok(VariableDeclarationOrExpression::ConditionalExpression(Box::new(FromJSON::import(value)?))),
               Some("ClassExpression") => Ok(VariableDeclarationOrExpression::ClassExpression(Box::new(FromJSON::import(value)?))),
               Some("AssignmentExpression") => Ok(VariableDeclarationOrExpression::AssignmentExpression(Box::new(FromJSON::import(value)?))),
               Some("UpdateExpression") => Ok(VariableDeclarationOrExpression::UpdateExpression(Box::new(FromJSON::import(value)?))),
               Some("FunctionExpression") => Ok(VariableDeclarationOrExpression::FunctionExpression(Box::new(FromJSON::import(value)?))),
               Some("CallExpression") => Ok(VariableDeclarationOrExpression::CallExpression(Box::new(FromJSON::import(value)?))),
               Some("IdentifierExpression") => Ok(VariableDeclarationOrExpression::IdentifierExpression(Box::new(FromJSON::import(value)?))),
               Some("ObjectExpression") => Ok(VariableDeclarationOrExpression::ObjectExpression(Box::new(FromJSON::import(value)?))),
               Some("ArrayExpression") => Ok(VariableDeclarationOrExpression::ArrayExpression(Box::new(FromJSON::import(value)?))),
               Some("ArrowExpression") => Ok(VariableDeclarationOrExpression::ArrowExpression(Box::new(FromJSON::import(value)?))),
               Some("UnaryExpression") => Ok(VariableDeclarationOrExpression::UnaryExpression(Box::new(FromJSON::import(value)?))),
               Some("VariableDeclaration") => Ok(VariableDeclarationOrExpression::VariableDeclaration(Box::new(FromJSON::import(value)?))),
               Some("LiteralNullExpression") => Ok(VariableDeclarationOrExpression::LiteralNullExpression(Box::new(FromJSON::import(value)?))),
                _ => Err(FromJSONError {
                    expected: "Instance of VariableDeclarationOrExpression".to_string(),
                    got: value.dump()
                })
            }
        }
    }


    impl ToJSON for VariableDeclarationOrExpression {
        fn export(&self) -> JSON {
            match *self {
               VariableDeclarationOrExpression::NewExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::LiteralStringExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::ThisExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::BinaryExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::StaticMemberExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::LiteralRegExpExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::LiteralBooleanExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::CompoundAssignmentExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::ComputedMemberExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::YieldStarExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::YieldExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::LiteralInfinityExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::TemplateExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::NewTargetExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::LiteralNumericExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::AwaitExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::ConditionalExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::ClassExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::AssignmentExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::UpdateExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::FunctionExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::CallExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::IdentifierExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::ObjectExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::ArrayExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::ArrowExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::UnaryExpression(box ref value) => value.export(),
               VariableDeclarationOrExpression::VariableDeclaration(box ref value) => value.export(),
               VariableDeclarationOrExpression::LiteralNullExpression(box ref value) => value.export()
            }
        }
    }


    impl Walker for VariableDeclarationOrExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            match *self {
               VariableDeclarationOrExpression::NewExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::LiteralStringExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::ThisExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::BinaryExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::StaticMemberExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::LiteralRegExpExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::LiteralBooleanExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::CompoundAssignmentExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::ComputedMemberExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::YieldStarExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::YieldExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::LiteralInfinityExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::TemplateExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::NewTargetExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::LiteralNumericExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::AwaitExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::ConditionalExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::ClassExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::AssignmentExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::UpdateExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::FunctionExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::CallExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::IdentifierExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::ObjectExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::ArrayExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::ArrowExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::UnaryExpression(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::VariableDeclaration(box ref mut value) => value.walk(path, visitor),
               VariableDeclarationOrExpression::LiteralNullExpression(box ref mut value) => value.walk(path, visitor)
            }
        }
    }




    // Aliases to primitive types (by lexicographical order)
     pub type Identifier = std::string::String;
     pub type IdentifierName = std::string::String;
     pub type Label = std::string::String;
     pub type String = std::string::String;


    // Aliases to list types (by lexicographical order)
    pub type Arguments = Vec<SpreadElementOrExpression>;
    pub type ListOfAssignmentTargetOrAssignmentTargetWithInitializer = Vec<AssignmentTargetOrAssignmentTargetWithInitializer>;
    pub type ListOfAssignmentTargetProperty = Vec<AssignmentTargetProperty>;
    pub type ListOfBindingProperty = Vec<BindingProperty>;
    pub type ListOfClassElement = Vec<ClassElement>;
    pub type ListOfDirective = Vec<Directive>;
    pub type ListOfExportFromSpecifier = Vec<ExportFromSpecifier>;
    pub type ListOfExportLocalSpecifier = Vec<ExportLocalSpecifier>;
    pub type ListOfExpressionOrTemplateElement = Vec<ExpressionOrTemplateElement>;
    pub type ListOfIdentifierName = Vec<IdentifierName>;
    pub type ListOfImportDeclarationOrExportDeclarationOrStatement = Vec<ImportDeclarationOrExportDeclarationOrStatement>;
    pub type ListOfImportSpecifier = Vec<ImportSpecifier>;
    pub type ListOfObjectProperty = Vec<ObjectProperty>;
    pub type ListOfOptionalBindingOrBindingWithInitializer = Vec<OptionalBindingOrBindingWithInitializer>;
    pub type ListOfOptionalSpreadElementOrExpression = Vec<OptionalSpreadElementOrExpression>;
    pub type ListOfParameter = Vec<Parameter>;
    pub type ListOfStatement = Vec<Statement>;
    pub type ListOfSwitchCase = Vec<SwitchCase>;
    pub type ListOfVariableDeclarator = Vec<VariableDeclarator>;


    // Aliases to optional types (by lexicographical order)
    pub type OptionalAssertedBlockScope = Option<AssertedBlockScope>;
    pub type OptionalAssertedParameterScope = Option<AssertedParameterScope>;
    pub type OptionalAssertedVarScope = Option<AssertedVarScope>;
    pub type OptionalAssignmentTarget = Option<AssignmentTarget>;
    pub type OptionalBinding = Option<Binding>;
    pub type OptionalBindingIdentifier = Option<BindingIdentifier>;
    pub type OptionalBindingOrBindingWithInitializer = Option<BindingOrBindingWithInitializer>;
    pub type OptionalCatchClause = Option<CatchClause>;
    pub type OptionalExpression = Option<Expression>;
    pub type OptionalIdentifierName = Option<IdentifierName>;
    pub type OptionalLabel = Option<Label>;
    pub type OptionalSpreadElementOrExpression = Option<SpreadElementOrExpression>;
    pub type OptionalStatement = Option<Statement>;
    pub type OptionalVariableDeclarationOrExpression = Option<VariableDeclarationOrExpression>;


     // Interfaces and interface names (by lexicographical order)
    #[derive(PartialEq, Debug, Clone)]
    pub struct ArrayAssignmentTarget {
        pub elements: ListOfAssignmentTargetOrAssignmentTargetWithInitializer,
        pub rest: OptionalAssignmentTarget
    }

    impl FromJSON for ArrayAssignmentTarget {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ArrayAssignmentTarget") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ArrayAssignmentTarget".to_string(),
                    got: value.dump()
                })
            }
            Ok(ArrayAssignmentTarget { elements: FromJSON::import(&value["elements"])?, rest: FromJSON::import(&value["rest"])? })
        }
    }


    impl ToJSON for ArrayAssignmentTarget {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ArrayAssignmentTarget"),
                 "elements" => self.elements.export(),
                 "rest" => self.rest.export()
            }
        }
    }


    impl Walker for ArrayAssignmentTarget {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ArrayAssignmentTarget);
            visitor.enter_array_assignment_target(path, self)?;
            path.enter_field(ASTField::Elements);
            self.elements.walk(path, visitor)?;
            path.exit_field(ASTField::Elements);
            path.enter_field(ASTField::Rest);
            self.rest.walk(path, visitor)?;
            path.exit_field(ASTField::Rest);
            visitor.exit_array_assignment_target(path, self)?;
            path.exit_interface(ASTNode::ArrayAssignmentTarget);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ArrayBinding {
        pub elements: ListOfOptionalBindingOrBindingWithInitializer,
        pub rest: OptionalBinding
    }

    impl FromJSON for ArrayBinding {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ArrayBinding") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ArrayBinding".to_string(),
                    got: value.dump()
                })
            }
            Ok(ArrayBinding { elements: FromJSON::import(&value["elements"])?, rest: FromJSON::import(&value["rest"])? })
        }
    }


    impl ToJSON for ArrayBinding {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ArrayBinding"),
                 "elements" => self.elements.export(),
                 "rest" => self.rest.export()
            }
        }
    }


    impl Walker for ArrayBinding {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ArrayBinding);
            visitor.enter_array_binding(path, self)?;
            path.enter_field(ASTField::Elements);
            self.elements.walk(path, visitor)?;
            path.exit_field(ASTField::Elements);
            path.enter_field(ASTField::Rest);
            self.rest.walk(path, visitor)?;
            path.exit_field(ASTField::Rest);
            visitor.exit_array_binding(path, self)?;
            path.exit_interface(ASTNode::ArrayBinding);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ArrayExpression {
        pub elements: ListOfOptionalSpreadElementOrExpression
    }

    impl FromJSON for ArrayExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ArrayExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ArrayExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(ArrayExpression { elements: FromJSON::import(&value["elements"])? })
        }
    }


    impl ToJSON for ArrayExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ArrayExpression"),
                 "elements" => self.elements.export()
            }
        }
    }


    impl Walker for ArrayExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ArrayExpression);
            visitor.enter_array_expression(path, self)?;
            path.enter_field(ASTField::Elements);
            self.elements.walk(path, visitor)?;
            path.exit_field(ASTField::Elements);
            visitor.exit_array_expression(path, self)?;
            path.exit_interface(ASTNode::ArrayExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ArrowExpression {
        pub is_async: bool,
        pub parameter_scope: OptionalAssertedParameterScope,
        pub body_scope: OptionalAssertedVarScope,
        pub params: FormalParameters,
        pub body: FunctionBodyOrExpression
    }

    impl FromJSON for ArrowExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ArrowExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ArrowExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(ArrowExpression { is_async: FromJSON::import(&value["isAsync"])?, parameter_scope: FromJSON::import(&value["parameterScope"])?, body_scope: FromJSON::import(&value["bodyScope"])?, params: FromJSON::import(&value["params"])?, body: FromJSON::import(&value["body"])? })
        }
    }


    impl ToJSON for ArrowExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ArrowExpression"),
                 "isAsync" => self.is_async.export(),
                 "parameterScope" => self.parameter_scope.export(),
                 "bodyScope" => self.body_scope.export(),
                 "params" => self.params.export(),
                 "body" => self.body.export()
            }
        }
    }


    impl Walker for ArrowExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ArrowExpression);
            visitor.enter_arrow_expression(path, self)?;
            path.enter_field(ASTField::IsAsync);
            self.is_async.walk(path, visitor)?;
            path.exit_field(ASTField::IsAsync);
            path.enter_field(ASTField::ParameterScope);
            self.parameter_scope.walk(path, visitor)?;
            path.exit_field(ASTField::ParameterScope);
            path.enter_field(ASTField::BodyScope);
            self.body_scope.walk(path, visitor)?;
            path.exit_field(ASTField::BodyScope);
            path.enter_field(ASTField::Params);
            self.params.walk(path, visitor)?;
            path.exit_field(ASTField::Params);
            path.enter_field(ASTField::Body);
            self.body.walk(path, visitor)?;
            path.exit_field(ASTField::Body);
            visitor.exit_arrow_expression(path, self)?;
            path.exit_interface(ASTNode::ArrowExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct AssertedBlockScope {
        pub lexically_declared_names: ListOfIdentifierName,
        pub captured_names: ListOfIdentifierName,
        pub has_direct_eval: bool
    }

    impl FromJSON for AssertedBlockScope {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("AssertedBlockScope") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of AssertedBlockScope".to_string(),
                    got: value.dump()
                })
            }
            Ok(AssertedBlockScope { lexically_declared_names: FromJSON::import(&value["lexicallyDeclaredNames"])?, captured_names: FromJSON::import(&value["capturedNames"])?, has_direct_eval: FromJSON::import(&value["hasDirectEval"])? })
        }
    }


    impl ToJSON for AssertedBlockScope {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("AssertedBlockScope"),
                 "lexicallyDeclaredNames" => self.lexically_declared_names.export(),
                 "capturedNames" => self.captured_names.export(),
                 "hasDirectEval" => self.has_direct_eval.export()
            }
        }
    }


    impl Walker for AssertedBlockScope {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::AssertedBlockScope);
            visitor.enter_asserted_block_scope(path, self)?;
            path.enter_field(ASTField::LexicallyDeclaredNames);
            self.lexically_declared_names.walk(path, visitor)?;
            path.exit_field(ASTField::LexicallyDeclaredNames);
            path.enter_field(ASTField::CapturedNames);
            self.captured_names.walk(path, visitor)?;
            path.exit_field(ASTField::CapturedNames);
            path.enter_field(ASTField::HasDirectEval);
            self.has_direct_eval.walk(path, visitor)?;
            path.exit_field(ASTField::HasDirectEval);
            visitor.exit_asserted_block_scope(path, self)?;
            path.exit_interface(ASTNode::AssertedBlockScope);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct AssertedParameterScope {
        pub parameter_names: ListOfIdentifierName,
        pub captured_names: ListOfIdentifierName,
        pub has_direct_eval: bool
    }

    impl FromJSON for AssertedParameterScope {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("AssertedParameterScope") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of AssertedParameterScope".to_string(),
                    got: value.dump()
                })
            }
            Ok(AssertedParameterScope { parameter_names: FromJSON::import(&value["parameterNames"])?, captured_names: FromJSON::import(&value["capturedNames"])?, has_direct_eval: FromJSON::import(&value["hasDirectEval"])? })
        }
    }


    impl ToJSON for AssertedParameterScope {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("AssertedParameterScope"),
                 "parameterNames" => self.parameter_names.export(),
                 "capturedNames" => self.captured_names.export(),
                 "hasDirectEval" => self.has_direct_eval.export()
            }
        }
    }


    impl Walker for AssertedParameterScope {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::AssertedParameterScope);
            visitor.enter_asserted_parameter_scope(path, self)?;
            path.enter_field(ASTField::ParameterNames);
            self.parameter_names.walk(path, visitor)?;
            path.exit_field(ASTField::ParameterNames);
            path.enter_field(ASTField::CapturedNames);
            self.captured_names.walk(path, visitor)?;
            path.exit_field(ASTField::CapturedNames);
            path.enter_field(ASTField::HasDirectEval);
            self.has_direct_eval.walk(path, visitor)?;
            path.exit_field(ASTField::HasDirectEval);
            visitor.exit_asserted_parameter_scope(path, self)?;
            path.exit_interface(ASTNode::AssertedParameterScope);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct AssertedVarScope {
        pub lexically_declared_names: ListOfIdentifierName,
        pub var_declared_names: ListOfIdentifierName,
        pub captured_names: ListOfIdentifierName,
        pub has_direct_eval: bool
    }

    impl FromJSON for AssertedVarScope {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("AssertedVarScope") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of AssertedVarScope".to_string(),
                    got: value.dump()
                })
            }
            Ok(AssertedVarScope { lexically_declared_names: FromJSON::import(&value["lexicallyDeclaredNames"])?, var_declared_names: FromJSON::import(&value["varDeclaredNames"])?, captured_names: FromJSON::import(&value["capturedNames"])?, has_direct_eval: FromJSON::import(&value["hasDirectEval"])? })
        }
    }


    impl ToJSON for AssertedVarScope {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("AssertedVarScope"),
                 "lexicallyDeclaredNames" => self.lexically_declared_names.export(),
                 "varDeclaredNames" => self.var_declared_names.export(),
                 "capturedNames" => self.captured_names.export(),
                 "hasDirectEval" => self.has_direct_eval.export()
            }
        }
    }


    impl Walker for AssertedVarScope {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::AssertedVarScope);
            visitor.enter_asserted_var_scope(path, self)?;
            path.enter_field(ASTField::LexicallyDeclaredNames);
            self.lexically_declared_names.walk(path, visitor)?;
            path.exit_field(ASTField::LexicallyDeclaredNames);
            path.enter_field(ASTField::VarDeclaredNames);
            self.var_declared_names.walk(path, visitor)?;
            path.exit_field(ASTField::VarDeclaredNames);
            path.enter_field(ASTField::CapturedNames);
            self.captured_names.walk(path, visitor)?;
            path.exit_field(ASTField::CapturedNames);
            path.enter_field(ASTField::HasDirectEval);
            self.has_direct_eval.walk(path, visitor)?;
            path.exit_field(ASTField::HasDirectEval);
            visitor.exit_asserted_var_scope(path, self)?;
            path.exit_interface(ASTNode::AssertedVarScope);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct AssignmentExpression {
        pub binding: AssignmentTarget,
        pub expression: Expression
    }

    impl FromJSON for AssignmentExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("AssignmentExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of AssignmentExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(AssignmentExpression { binding: FromJSON::import(&value["binding"])?, expression: FromJSON::import(&value["expression"])? })
        }
    }


    impl ToJSON for AssignmentExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("AssignmentExpression"),
                 "binding" => self.binding.export(),
                 "expression" => self.expression.export()
            }
        }
    }


    impl Walker for AssignmentExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::AssignmentExpression);
            visitor.enter_assignment_expression(path, self)?;
            path.enter_field(ASTField::Binding);
            self.binding.walk(path, visitor)?;
            path.exit_field(ASTField::Binding);
            path.enter_field(ASTField::Expression);
            self.expression.walk(path, visitor)?;
            path.exit_field(ASTField::Expression);
            visitor.exit_assignment_expression(path, self)?;
            path.exit_interface(ASTNode::AssignmentExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct AssignmentTargetIdentifier {
        pub name: Identifier
    }

    impl FromJSON for AssignmentTargetIdentifier {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("AssignmentTargetIdentifier") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of AssignmentTargetIdentifier".to_string(),
                    got: value.dump()
                })
            }
            Ok(AssignmentTargetIdentifier { name: FromJSON::import(&value["name"])? })
        }
    }


    impl ToJSON for AssignmentTargetIdentifier {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("AssignmentTargetIdentifier"),
                 "name" => self.name.export()
            }
        }
    }


    impl Walker for AssignmentTargetIdentifier {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::AssignmentTargetIdentifier);
            visitor.enter_assignment_target_identifier(path, self)?;
            path.enter_field(ASTField::Name);
            self.name.walk(path, visitor)?;
            path.exit_field(ASTField::Name);
            visitor.exit_assignment_target_identifier(path, self)?;
            path.exit_interface(ASTNode::AssignmentTargetIdentifier);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct AssignmentTargetPropertyIdentifier {
        pub binding: AssignmentTargetIdentifier,
        pub init: OptionalExpression
    }

    impl FromJSON for AssignmentTargetPropertyIdentifier {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("AssignmentTargetPropertyIdentifier") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of AssignmentTargetPropertyIdentifier".to_string(),
                    got: value.dump()
                })
            }
            Ok(AssignmentTargetPropertyIdentifier { binding: FromJSON::import(&value["binding"])?, init: FromJSON::import(&value["init"])? })
        }
    }


    impl ToJSON for AssignmentTargetPropertyIdentifier {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("AssignmentTargetPropertyIdentifier"),
                 "binding" => self.binding.export(),
                 "init" => self.init.export()
            }
        }
    }


    impl Walker for AssignmentTargetPropertyIdentifier {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::AssignmentTargetPropertyIdentifier);
            visitor.enter_assignment_target_property_identifier(path, self)?;
            path.enter_field(ASTField::Binding);
            self.binding.walk(path, visitor)?;
            path.exit_field(ASTField::Binding);
            path.enter_field(ASTField::Init);
            self.init.walk(path, visitor)?;
            path.exit_field(ASTField::Init);
            visitor.exit_assignment_target_property_identifier(path, self)?;
            path.exit_interface(ASTNode::AssignmentTargetPropertyIdentifier);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct AssignmentTargetPropertyProperty {
        pub name: PropertyName,
        pub binding: AssignmentTargetOrAssignmentTargetWithInitializer
    }

    impl FromJSON for AssignmentTargetPropertyProperty {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("AssignmentTargetPropertyProperty") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of AssignmentTargetPropertyProperty".to_string(),
                    got: value.dump()
                })
            }
            Ok(AssignmentTargetPropertyProperty { name: FromJSON::import(&value["name"])?, binding: FromJSON::import(&value["binding"])? })
        }
    }


    impl ToJSON for AssignmentTargetPropertyProperty {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("AssignmentTargetPropertyProperty"),
                 "name" => self.name.export(),
                 "binding" => self.binding.export()
            }
        }
    }


    impl Walker for AssignmentTargetPropertyProperty {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::AssignmentTargetPropertyProperty);
            visitor.enter_assignment_target_property_property(path, self)?;
            path.enter_field(ASTField::Name);
            self.name.walk(path, visitor)?;
            path.exit_field(ASTField::Name);
            path.enter_field(ASTField::Binding);
            self.binding.walk(path, visitor)?;
            path.exit_field(ASTField::Binding);
            visitor.exit_assignment_target_property_property(path, self)?;
            path.exit_interface(ASTNode::AssignmentTargetPropertyProperty);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct AssignmentTargetWithInitializer {
        pub binding: AssignmentTarget,
        pub init: Expression
    }

    impl FromJSON for AssignmentTargetWithInitializer {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("AssignmentTargetWithInitializer") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of AssignmentTargetWithInitializer".to_string(),
                    got: value.dump()
                })
            }
            Ok(AssignmentTargetWithInitializer { binding: FromJSON::import(&value["binding"])?, init: FromJSON::import(&value["init"])? })
        }
    }


    impl ToJSON for AssignmentTargetWithInitializer {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("AssignmentTargetWithInitializer"),
                 "binding" => self.binding.export(),
                 "init" => self.init.export()
            }
        }
    }


    impl Walker for AssignmentTargetWithInitializer {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::AssignmentTargetWithInitializer);
            visitor.enter_assignment_target_with_initializer(path, self)?;
            path.enter_field(ASTField::Binding);
            self.binding.walk(path, visitor)?;
            path.exit_field(ASTField::Binding);
            path.enter_field(ASTField::Init);
            self.init.walk(path, visitor)?;
            path.exit_field(ASTField::Init);
            visitor.exit_assignment_target_with_initializer(path, self)?;
            path.exit_interface(ASTNode::AssignmentTargetWithInitializer);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct AwaitExpression {
        pub expression: Expression
    }

    impl FromJSON for AwaitExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("AwaitExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of AwaitExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(AwaitExpression { expression: FromJSON::import(&value["expression"])? })
        }
    }


    impl ToJSON for AwaitExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("AwaitExpression"),
                 "expression" => self.expression.export()
            }
        }
    }


    impl Walker for AwaitExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::AwaitExpression);
            visitor.enter_await_expression(path, self)?;
            path.enter_field(ASTField::Expression);
            self.expression.walk(path, visitor)?;
            path.exit_field(ASTField::Expression);
            visitor.exit_await_expression(path, self)?;
            path.exit_interface(ASTNode::AwaitExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct BinaryExpression {
        pub operator: BinaryOperator,
        pub left: Expression,
        pub right: Expression
    }

    impl FromJSON for BinaryExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("BinaryExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of BinaryExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(BinaryExpression { operator: FromJSON::import(&value["operator"])?, left: FromJSON::import(&value["left"])?, right: FromJSON::import(&value["right"])? })
        }
    }


    impl ToJSON for BinaryExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("BinaryExpression"),
                 "operator" => self.operator.export(),
                 "left" => self.left.export(),
                 "right" => self.right.export()
            }
        }
    }


    impl Walker for BinaryExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::BinaryExpression);
            visitor.enter_binary_expression(path, self)?;
            path.enter_field(ASTField::Operator);
            self.operator.walk(path, visitor)?;
            path.exit_field(ASTField::Operator);
            path.enter_field(ASTField::Left);
            self.left.walk(path, visitor)?;
            path.exit_field(ASTField::Left);
            path.enter_field(ASTField::Right);
            self.right.walk(path, visitor)?;
            path.exit_field(ASTField::Right);
            visitor.exit_binary_expression(path, self)?;
            path.exit_interface(ASTNode::BinaryExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct BindingIdentifier {
        pub name: Identifier
    }

    impl FromJSON for BindingIdentifier {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("BindingIdentifier") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of BindingIdentifier".to_string(),
                    got: value.dump()
                })
            }
            Ok(BindingIdentifier { name: FromJSON::import(&value["name"])? })
        }
    }


    impl ToJSON for BindingIdentifier {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("BindingIdentifier"),
                 "name" => self.name.export()
            }
        }
    }


    impl Walker for BindingIdentifier {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::BindingIdentifier);
            visitor.enter_binding_identifier(path, self)?;
            path.enter_field(ASTField::Name);
            self.name.walk(path, visitor)?;
            path.exit_field(ASTField::Name);
            visitor.exit_binding_identifier(path, self)?;
            path.exit_interface(ASTNode::BindingIdentifier);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct BindingPropertyIdentifier {
        pub binding: BindingIdentifier,
        pub init: OptionalExpression
    }

    impl FromJSON for BindingPropertyIdentifier {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("BindingPropertyIdentifier") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of BindingPropertyIdentifier".to_string(),
                    got: value.dump()
                })
            }
            Ok(BindingPropertyIdentifier { binding: FromJSON::import(&value["binding"])?, init: FromJSON::import(&value["init"])? })
        }
    }


    impl ToJSON for BindingPropertyIdentifier {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("BindingPropertyIdentifier"),
                 "binding" => self.binding.export(),
                 "init" => self.init.export()
            }
        }
    }


    impl Walker for BindingPropertyIdentifier {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::BindingPropertyIdentifier);
            visitor.enter_binding_property_identifier(path, self)?;
            path.enter_field(ASTField::Binding);
            self.binding.walk(path, visitor)?;
            path.exit_field(ASTField::Binding);
            path.enter_field(ASTField::Init);
            self.init.walk(path, visitor)?;
            path.exit_field(ASTField::Init);
            visitor.exit_binding_property_identifier(path, self)?;
            path.exit_interface(ASTNode::BindingPropertyIdentifier);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct BindingPropertyProperty {
        pub name: PropertyName,
        pub binding: BindingOrBindingWithInitializer
    }

    impl FromJSON for BindingPropertyProperty {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("BindingPropertyProperty") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of BindingPropertyProperty".to_string(),
                    got: value.dump()
                })
            }
            Ok(BindingPropertyProperty { name: FromJSON::import(&value["name"])?, binding: FromJSON::import(&value["binding"])? })
        }
    }


    impl ToJSON for BindingPropertyProperty {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("BindingPropertyProperty"),
                 "name" => self.name.export(),
                 "binding" => self.binding.export()
            }
        }
    }


    impl Walker for BindingPropertyProperty {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::BindingPropertyProperty);
            visitor.enter_binding_property_property(path, self)?;
            path.enter_field(ASTField::Name);
            self.name.walk(path, visitor)?;
            path.exit_field(ASTField::Name);
            path.enter_field(ASTField::Binding);
            self.binding.walk(path, visitor)?;
            path.exit_field(ASTField::Binding);
            visitor.exit_binding_property_property(path, self)?;
            path.exit_interface(ASTNode::BindingPropertyProperty);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct BindingWithInitializer {
        pub binding: Binding,
        pub init: Expression
    }

    impl FromJSON for BindingWithInitializer {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("BindingWithInitializer") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of BindingWithInitializer".to_string(),
                    got: value.dump()
                })
            }
            Ok(BindingWithInitializer { binding: FromJSON::import(&value["binding"])?, init: FromJSON::import(&value["init"])? })
        }
    }


    impl ToJSON for BindingWithInitializer {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("BindingWithInitializer"),
                 "binding" => self.binding.export(),
                 "init" => self.init.export()
            }
        }
    }


    impl Walker for BindingWithInitializer {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::BindingWithInitializer);
            visitor.enter_binding_with_initializer(path, self)?;
            path.enter_field(ASTField::Binding);
            self.binding.walk(path, visitor)?;
            path.exit_field(ASTField::Binding);
            path.enter_field(ASTField::Init);
            self.init.walk(path, visitor)?;
            path.exit_field(ASTField::Init);
            visitor.exit_binding_with_initializer(path, self)?;
            path.exit_interface(ASTNode::BindingWithInitializer);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct Block {
        pub scope: OptionalAssertedBlockScope,
        pub statements: ListOfStatement
    }

    impl FromJSON for Block {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("Block") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of Block".to_string(),
                    got: value.dump()
                })
            }
            Ok(Block { scope: FromJSON::import(&value["scope"])?, statements: FromJSON::import(&value["statements"])? })
        }
    }


    impl ToJSON for Block {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("Block"),
                 "scope" => self.scope.export(),
                 "statements" => self.statements.export()
            }
        }
    }


    impl Walker for Block {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::Block);
            visitor.enter_block(path, self)?;
            path.enter_field(ASTField::Scope);
            self.scope.walk(path, visitor)?;
            path.exit_field(ASTField::Scope);
            path.enter_field(ASTField::Statements);
            self.statements.walk(path, visitor)?;
            path.exit_field(ASTField::Statements);
            visitor.exit_block(path, self)?;
            path.exit_interface(ASTNode::Block);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct BreakStatement {
        pub label: OptionalLabel
    }

    impl FromJSON for BreakStatement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("BreakStatement") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of BreakStatement".to_string(),
                    got: value.dump()
                })
            }
            Ok(BreakStatement { label: FromJSON::import(&value["label"])? })
        }
    }


    impl ToJSON for BreakStatement {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("BreakStatement"),
                 "label" => self.label.export()
            }
        }
    }


    impl Walker for BreakStatement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::BreakStatement);
            visitor.enter_break_statement(path, self)?;
            path.enter_field(ASTField::Label);
            self.label.walk(path, visitor)?;
            path.exit_field(ASTField::Label);
            visitor.exit_break_statement(path, self)?;
            path.exit_interface(ASTNode::BreakStatement);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct CallExpression {
        pub callee: ExpressionOrSuper,
        pub arguments: Arguments
    }

    impl FromJSON for CallExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("CallExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of CallExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(CallExpression { callee: FromJSON::import(&value["callee"])?, arguments: FromJSON::import(&value["arguments"])? })
        }
    }


    impl ToJSON for CallExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("CallExpression"),
                 "callee" => self.callee.export(),
                 "arguments" => self.arguments.export()
            }
        }
    }


    impl Walker for CallExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::CallExpression);
            visitor.enter_call_expression(path, self)?;
            path.enter_field(ASTField::Callee);
            self.callee.walk(path, visitor)?;
            path.exit_field(ASTField::Callee);
            path.enter_field(ASTField::Arguments);
            self.arguments.walk(path, visitor)?;
            path.exit_field(ASTField::Arguments);
            visitor.exit_call_expression(path, self)?;
            path.exit_interface(ASTNode::CallExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct CatchClause {
        pub binding: Binding,
        pub body: Block
    }

    impl FromJSON for CatchClause {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("CatchClause") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of CatchClause".to_string(),
                    got: value.dump()
                })
            }
            Ok(CatchClause { binding: FromJSON::import(&value["binding"])?, body: FromJSON::import(&value["body"])? })
        }
    }


    impl ToJSON for CatchClause {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("CatchClause"),
                 "binding" => self.binding.export(),
                 "body" => self.body.export()
            }
        }
    }


    impl Walker for CatchClause {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::CatchClause);
            visitor.enter_catch_clause(path, self)?;
            path.enter_field(ASTField::Binding);
            self.binding.walk(path, visitor)?;
            path.exit_field(ASTField::Binding);
            path.enter_field(ASTField::Body);
            self.body.walk(path, visitor)?;
            path.exit_field(ASTField::Body);
            visitor.exit_catch_clause(path, self)?;
            path.exit_interface(ASTNode::CatchClause);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ClassDeclaration {
        pub name: BindingIdentifier,
        pub super_: OptionalExpression,
        pub elements: ListOfClassElement
    }

    impl FromJSON for ClassDeclaration {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ClassDeclaration") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ClassDeclaration".to_string(),
                    got: value.dump()
                })
            }
            Ok(ClassDeclaration { name: FromJSON::import(&value["name"])?, super_: FromJSON::import(&value["super"])?, elements: FromJSON::import(&value["elements"])? })
        }
    }


    impl ToJSON for ClassDeclaration {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ClassDeclaration"),
                 "name" => self.name.export(),
                 "super" => self.super_.export(),
                 "elements" => self.elements.export()
            }
        }
    }


    impl Walker for ClassDeclaration {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ClassDeclaration);
            visitor.enter_class_declaration(path, self)?;
            path.enter_field(ASTField::Name);
            self.name.walk(path, visitor)?;
            path.exit_field(ASTField::Name);
            path.enter_field(ASTField::Super);
            self.super_.walk(path, visitor)?;
            path.exit_field(ASTField::Super);
            path.enter_field(ASTField::Elements);
            self.elements.walk(path, visitor)?;
            path.exit_field(ASTField::Elements);
            visitor.exit_class_declaration(path, self)?;
            path.exit_interface(ASTNode::ClassDeclaration);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ClassElement {
        pub is_static: bool,
        pub method: MethodDefinition
    }

    impl FromJSON for ClassElement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ClassElement") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ClassElement".to_string(),
                    got: value.dump()
                })
            }
            Ok(ClassElement { is_static: FromJSON::import(&value["isStatic"])?, method: FromJSON::import(&value["method"])? })
        }
    }


    impl ToJSON for ClassElement {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ClassElement"),
                 "isStatic" => self.is_static.export(),
                 "method" => self.method.export()
            }
        }
    }


    impl Walker for ClassElement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ClassElement);
            visitor.enter_class_element(path, self)?;
            path.enter_field(ASTField::IsStatic);
            self.is_static.walk(path, visitor)?;
            path.exit_field(ASTField::IsStatic);
            path.enter_field(ASTField::Method);
            self.method.walk(path, visitor)?;
            path.exit_field(ASTField::Method);
            visitor.exit_class_element(path, self)?;
            path.exit_interface(ASTNode::ClassElement);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ClassExpression {
        pub name: OptionalBindingIdentifier,
        pub super_: OptionalExpression,
        pub elements: ListOfClassElement
    }

    impl FromJSON for ClassExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ClassExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ClassExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(ClassExpression { name: FromJSON::import(&value["name"])?, super_: FromJSON::import(&value["super"])?, elements: FromJSON::import(&value["elements"])? })
        }
    }


    impl ToJSON for ClassExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ClassExpression"),
                 "name" => self.name.export(),
                 "super" => self.super_.export(),
                 "elements" => self.elements.export()
            }
        }
    }


    impl Walker for ClassExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ClassExpression);
            visitor.enter_class_expression(path, self)?;
            path.enter_field(ASTField::Name);
            self.name.walk(path, visitor)?;
            path.exit_field(ASTField::Name);
            path.enter_field(ASTField::Super);
            self.super_.walk(path, visitor)?;
            path.exit_field(ASTField::Super);
            path.enter_field(ASTField::Elements);
            self.elements.walk(path, visitor)?;
            path.exit_field(ASTField::Elements);
            visitor.exit_class_expression(path, self)?;
            path.exit_interface(ASTNode::ClassExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct CompoundAssignmentExpression {
        pub operator: CompoundAssignmentOperator,
        pub binding: SimpleAssignmentTarget,
        pub expression: Expression
    }

    impl FromJSON for CompoundAssignmentExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("CompoundAssignmentExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of CompoundAssignmentExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(CompoundAssignmentExpression { operator: FromJSON::import(&value["operator"])?, binding: FromJSON::import(&value["binding"])?, expression: FromJSON::import(&value["expression"])? })
        }
    }


    impl ToJSON for CompoundAssignmentExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("CompoundAssignmentExpression"),
                 "operator" => self.operator.export(),
                 "binding" => self.binding.export(),
                 "expression" => self.expression.export()
            }
        }
    }


    impl Walker for CompoundAssignmentExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::CompoundAssignmentExpression);
            visitor.enter_compound_assignment_expression(path, self)?;
            path.enter_field(ASTField::Operator);
            self.operator.walk(path, visitor)?;
            path.exit_field(ASTField::Operator);
            path.enter_field(ASTField::Binding);
            self.binding.walk(path, visitor)?;
            path.exit_field(ASTField::Binding);
            path.enter_field(ASTField::Expression);
            self.expression.walk(path, visitor)?;
            path.exit_field(ASTField::Expression);
            visitor.exit_compound_assignment_expression(path, self)?;
            path.exit_interface(ASTNode::CompoundAssignmentExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ComputedMemberAssignmentTarget {
        pub object: ExpressionOrSuper,
        pub expression: Expression
    }

    impl FromJSON for ComputedMemberAssignmentTarget {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ComputedMemberAssignmentTarget") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ComputedMemberAssignmentTarget".to_string(),
                    got: value.dump()
                })
            }
            Ok(ComputedMemberAssignmentTarget { object: FromJSON::import(&value["object"])?, expression: FromJSON::import(&value["expression"])? })
        }
    }


    impl ToJSON for ComputedMemberAssignmentTarget {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ComputedMemberAssignmentTarget"),
                 "object" => self.object.export(),
                 "expression" => self.expression.export()
            }
        }
    }


    impl Walker for ComputedMemberAssignmentTarget {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ComputedMemberAssignmentTarget);
            visitor.enter_computed_member_assignment_target(path, self)?;
            path.enter_field(ASTField::Object);
            self.object.walk(path, visitor)?;
            path.exit_field(ASTField::Object);
            path.enter_field(ASTField::Expression);
            self.expression.walk(path, visitor)?;
            path.exit_field(ASTField::Expression);
            visitor.exit_computed_member_assignment_target(path, self)?;
            path.exit_interface(ASTNode::ComputedMemberAssignmentTarget);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ComputedMemberExpression {
        pub object: ExpressionOrSuper,
        pub expression: Expression
    }

    impl FromJSON for ComputedMemberExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ComputedMemberExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ComputedMemberExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(ComputedMemberExpression { object: FromJSON::import(&value["object"])?, expression: FromJSON::import(&value["expression"])? })
        }
    }


    impl ToJSON for ComputedMemberExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ComputedMemberExpression"),
                 "object" => self.object.export(),
                 "expression" => self.expression.export()
            }
        }
    }


    impl Walker for ComputedMemberExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ComputedMemberExpression);
            visitor.enter_computed_member_expression(path, self)?;
            path.enter_field(ASTField::Object);
            self.object.walk(path, visitor)?;
            path.exit_field(ASTField::Object);
            path.enter_field(ASTField::Expression);
            self.expression.walk(path, visitor)?;
            path.exit_field(ASTField::Expression);
            visitor.exit_computed_member_expression(path, self)?;
            path.exit_interface(ASTNode::ComputedMemberExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ComputedPropertyName {
        pub expression: Expression
    }

    impl FromJSON for ComputedPropertyName {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ComputedPropertyName") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ComputedPropertyName".to_string(),
                    got: value.dump()
                })
            }
            Ok(ComputedPropertyName { expression: FromJSON::import(&value["expression"])? })
        }
    }


    impl ToJSON for ComputedPropertyName {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ComputedPropertyName"),
                 "expression" => self.expression.export()
            }
        }
    }


    impl Walker for ComputedPropertyName {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ComputedPropertyName);
            visitor.enter_computed_property_name(path, self)?;
            path.enter_field(ASTField::Expression);
            self.expression.walk(path, visitor)?;
            path.exit_field(ASTField::Expression);
            visitor.exit_computed_property_name(path, self)?;
            path.exit_interface(ASTNode::ComputedPropertyName);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ConditionalExpression {
        pub test: Expression,
        pub consequent: Expression,
        pub alternate: Expression
    }

    impl FromJSON for ConditionalExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ConditionalExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ConditionalExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(ConditionalExpression { test: FromJSON::import(&value["test"])?, consequent: FromJSON::import(&value["consequent"])?, alternate: FromJSON::import(&value["alternate"])? })
        }
    }


    impl ToJSON for ConditionalExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ConditionalExpression"),
                 "test" => self.test.export(),
                 "consequent" => self.consequent.export(),
                 "alternate" => self.alternate.export()
            }
        }
    }


    impl Walker for ConditionalExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ConditionalExpression);
            visitor.enter_conditional_expression(path, self)?;
            path.enter_field(ASTField::Test);
            self.test.walk(path, visitor)?;
            path.exit_field(ASTField::Test);
            path.enter_field(ASTField::Consequent);
            self.consequent.walk(path, visitor)?;
            path.exit_field(ASTField::Consequent);
            path.enter_field(ASTField::Alternate);
            self.alternate.walk(path, visitor)?;
            path.exit_field(ASTField::Alternate);
            visitor.exit_conditional_expression(path, self)?;
            path.exit_interface(ASTNode::ConditionalExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ContinueStatement {
        pub label: OptionalLabel
    }

    impl FromJSON for ContinueStatement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ContinueStatement") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ContinueStatement".to_string(),
                    got: value.dump()
                })
            }
            Ok(ContinueStatement { label: FromJSON::import(&value["label"])? })
        }
    }


    impl ToJSON for ContinueStatement {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ContinueStatement"),
                 "label" => self.label.export()
            }
        }
    }


    impl Walker for ContinueStatement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ContinueStatement);
            visitor.enter_continue_statement(path, self)?;
            path.enter_field(ASTField::Label);
            self.label.walk(path, visitor)?;
            path.exit_field(ASTField::Label);
            visitor.exit_continue_statement(path, self)?;
            path.exit_interface(ASTNode::ContinueStatement);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct DataProperty {
        pub name: PropertyName,
        pub expression: Expression
    }

    impl FromJSON for DataProperty {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("DataProperty") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of DataProperty".to_string(),
                    got: value.dump()
                })
            }
            Ok(DataProperty { name: FromJSON::import(&value["name"])?, expression: FromJSON::import(&value["expression"])? })
        }
    }


    impl ToJSON for DataProperty {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("DataProperty"),
                 "name" => self.name.export(),
                 "expression" => self.expression.export()
            }
        }
    }


    impl Walker for DataProperty {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::DataProperty);
            visitor.enter_data_property(path, self)?;
            path.enter_field(ASTField::Name);
            self.name.walk(path, visitor)?;
            path.exit_field(ASTField::Name);
            path.enter_field(ASTField::Expression);
            self.expression.walk(path, visitor)?;
            path.exit_field(ASTField::Expression);
            visitor.exit_data_property(path, self)?;
            path.exit_interface(ASTNode::DataProperty);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct DebuggerStatement {

    }

    impl FromJSON for DebuggerStatement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("DebuggerStatement") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of DebuggerStatement".to_string(),
                    got: value.dump()
                })
            }
            Ok(DebuggerStatement {  })
        }
    }


    impl ToJSON for DebuggerStatement {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("DebuggerStatement"),

            }
        }
    }


    impl Walker for DebuggerStatement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::DebuggerStatement);
            visitor.enter_debugger_statement(path, self)?;

            visitor.exit_debugger_statement(path, self)?;
            path.exit_interface(ASTNode::DebuggerStatement);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct Directive {
        pub raw_value: String
    }

    impl FromJSON for Directive {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("Directive") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of Directive".to_string(),
                    got: value.dump()
                })
            }
            Ok(Directive { raw_value: FromJSON::import(&value["rawValue"])? })
        }
    }


    impl ToJSON for Directive {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("Directive"),
                 "rawValue" => self.raw_value.export()
            }
        }
    }


    impl Walker for Directive {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::Directive);
            visitor.enter_directive(path, self)?;
            path.enter_field(ASTField::RawValue);
            self.raw_value.walk(path, visitor)?;
            path.exit_field(ASTField::RawValue);
            visitor.exit_directive(path, self)?;
            path.exit_interface(ASTNode::Directive);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct DoWhileStatement {
        pub test: Expression,
        pub body: Statement
    }

    impl FromJSON for DoWhileStatement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("DoWhileStatement") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of DoWhileStatement".to_string(),
                    got: value.dump()
                })
            }
            Ok(DoWhileStatement { test: FromJSON::import(&value["test"])?, body: FromJSON::import(&value["body"])? })
        }
    }


    impl ToJSON for DoWhileStatement {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("DoWhileStatement"),
                 "test" => self.test.export(),
                 "body" => self.body.export()
            }
        }
    }


    impl Walker for DoWhileStatement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::DoWhileStatement);
            visitor.enter_do_while_statement(path, self)?;
            path.enter_field(ASTField::Test);
            self.test.walk(path, visitor)?;
            path.exit_field(ASTField::Test);
            path.enter_field(ASTField::Body);
            self.body.walk(path, visitor)?;
            path.exit_field(ASTField::Body);
            visitor.exit_do_while_statement(path, self)?;
            path.exit_interface(ASTNode::DoWhileStatement);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct EmptyStatement {

    }

    impl FromJSON for EmptyStatement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("EmptyStatement") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of EmptyStatement".to_string(),
                    got: value.dump()
                })
            }
            Ok(EmptyStatement {  })
        }
    }


    impl ToJSON for EmptyStatement {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("EmptyStatement"),

            }
        }
    }


    impl Walker for EmptyStatement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::EmptyStatement);
            visitor.enter_empty_statement(path, self)?;

            visitor.exit_empty_statement(path, self)?;
            path.exit_interface(ASTNode::EmptyStatement);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct Export {
        pub declaration: FunctionDeclarationOrClassDeclarationOrVariableDeclaration
    }

    impl FromJSON for Export {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("Export") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of Export".to_string(),
                    got: value.dump()
                })
            }
            Ok(Export { declaration: FromJSON::import(&value["declaration"])? })
        }
    }


    impl ToJSON for Export {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("Export"),
                 "declaration" => self.declaration.export()
            }
        }
    }


    impl Walker for Export {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::Export);
            visitor.enter_export(path, self)?;
            path.enter_field(ASTField::Declaration);
            self.declaration.walk(path, visitor)?;
            path.exit_field(ASTField::Declaration);
            visitor.exit_export(path, self)?;
            path.exit_interface(ASTNode::Export);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ExportAllFrom {
        pub module_specifier: String
    }

    impl FromJSON for ExportAllFrom {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ExportAllFrom") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ExportAllFrom".to_string(),
                    got: value.dump()
                })
            }
            Ok(ExportAllFrom { module_specifier: FromJSON::import(&value["moduleSpecifier"])? })
        }
    }


    impl ToJSON for ExportAllFrom {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ExportAllFrom"),
                 "moduleSpecifier" => self.module_specifier.export()
            }
        }
    }


    impl Walker for ExportAllFrom {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ExportAllFrom);
            visitor.enter_export_all_from(path, self)?;
            path.enter_field(ASTField::ModuleSpecifier);
            self.module_specifier.walk(path, visitor)?;
            path.exit_field(ASTField::ModuleSpecifier);
            visitor.exit_export_all_from(path, self)?;
            path.exit_interface(ASTNode::ExportAllFrom);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ExportDefault {
        pub body: FunctionDeclarationOrClassDeclarationOrExpression
    }

    impl FromJSON for ExportDefault {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ExportDefault") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ExportDefault".to_string(),
                    got: value.dump()
                })
            }
            Ok(ExportDefault { body: FromJSON::import(&value["body"])? })
        }
    }


    impl ToJSON for ExportDefault {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ExportDefault"),
                 "body" => self.body.export()
            }
        }
    }


    impl Walker for ExportDefault {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ExportDefault);
            visitor.enter_export_default(path, self)?;
            path.enter_field(ASTField::Body);
            self.body.walk(path, visitor)?;
            path.exit_field(ASTField::Body);
            visitor.exit_export_default(path, self)?;
            path.exit_interface(ASTNode::ExportDefault);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ExportFrom {
        pub named_exports: ListOfExportFromSpecifier,
        pub module_specifier: String
    }

    impl FromJSON for ExportFrom {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ExportFrom") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ExportFrom".to_string(),
                    got: value.dump()
                })
            }
            Ok(ExportFrom { named_exports: FromJSON::import(&value["namedExports"])?, module_specifier: FromJSON::import(&value["moduleSpecifier"])? })
        }
    }


    impl ToJSON for ExportFrom {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ExportFrom"),
                 "namedExports" => self.named_exports.export(),
                 "moduleSpecifier" => self.module_specifier.export()
            }
        }
    }


    impl Walker for ExportFrom {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ExportFrom);
            visitor.enter_export_from(path, self)?;
            path.enter_field(ASTField::NamedExports);
            self.named_exports.walk(path, visitor)?;
            path.exit_field(ASTField::NamedExports);
            path.enter_field(ASTField::ModuleSpecifier);
            self.module_specifier.walk(path, visitor)?;
            path.exit_field(ASTField::ModuleSpecifier);
            visitor.exit_export_from(path, self)?;
            path.exit_interface(ASTNode::ExportFrom);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ExportFromSpecifier {
        pub name: IdentifierName,
        pub exported_name: OptionalIdentifierName
    }

    impl FromJSON for ExportFromSpecifier {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ExportFromSpecifier") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ExportFromSpecifier".to_string(),
                    got: value.dump()
                })
            }
            Ok(ExportFromSpecifier { name: FromJSON::import(&value["name"])?, exported_name: FromJSON::import(&value["exportedName"])? })
        }
    }


    impl ToJSON for ExportFromSpecifier {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ExportFromSpecifier"),
                 "name" => self.name.export(),
                 "exportedName" => self.exported_name.export()
            }
        }
    }


    impl Walker for ExportFromSpecifier {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ExportFromSpecifier);
            visitor.enter_export_from_specifier(path, self)?;
            path.enter_field(ASTField::Name);
            self.name.walk(path, visitor)?;
            path.exit_field(ASTField::Name);
            path.enter_field(ASTField::ExportedName);
            self.exported_name.walk(path, visitor)?;
            path.exit_field(ASTField::ExportedName);
            visitor.exit_export_from_specifier(path, self)?;
            path.exit_interface(ASTNode::ExportFromSpecifier);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ExportLocalSpecifier {
        pub name: IdentifierExpression,
        pub exported_name: OptionalIdentifierName
    }

    impl FromJSON for ExportLocalSpecifier {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ExportLocalSpecifier") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ExportLocalSpecifier".to_string(),
                    got: value.dump()
                })
            }
            Ok(ExportLocalSpecifier { name: FromJSON::import(&value["name"])?, exported_name: FromJSON::import(&value["exportedName"])? })
        }
    }


    impl ToJSON for ExportLocalSpecifier {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ExportLocalSpecifier"),
                 "name" => self.name.export(),
                 "exportedName" => self.exported_name.export()
            }
        }
    }


    impl Walker for ExportLocalSpecifier {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ExportLocalSpecifier);
            visitor.enter_export_local_specifier(path, self)?;
            path.enter_field(ASTField::Name);
            self.name.walk(path, visitor)?;
            path.exit_field(ASTField::Name);
            path.enter_field(ASTField::ExportedName);
            self.exported_name.walk(path, visitor)?;
            path.exit_field(ASTField::ExportedName);
            visitor.exit_export_local_specifier(path, self)?;
            path.exit_interface(ASTNode::ExportLocalSpecifier);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ExportLocals {
        pub named_exports: ListOfExportLocalSpecifier
    }

    impl FromJSON for ExportLocals {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ExportLocals") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ExportLocals".to_string(),
                    got: value.dump()
                })
            }
            Ok(ExportLocals { named_exports: FromJSON::import(&value["namedExports"])? })
        }
    }


    impl ToJSON for ExportLocals {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ExportLocals"),
                 "namedExports" => self.named_exports.export()
            }
        }
    }


    impl Walker for ExportLocals {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ExportLocals);
            visitor.enter_export_locals(path, self)?;
            path.enter_field(ASTField::NamedExports);
            self.named_exports.walk(path, visitor)?;
            path.exit_field(ASTField::NamedExports);
            visitor.exit_export_locals(path, self)?;
            path.exit_interface(ASTNode::ExportLocals);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ExpressionStatement {
        pub expression: Expression
    }

    impl FromJSON for ExpressionStatement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ExpressionStatement") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ExpressionStatement".to_string(),
                    got: value.dump()
                })
            }
            Ok(ExpressionStatement { expression: FromJSON::import(&value["expression"])? })
        }
    }


    impl ToJSON for ExpressionStatement {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ExpressionStatement"),
                 "expression" => self.expression.export()
            }
        }
    }


    impl Walker for ExpressionStatement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ExpressionStatement);
            visitor.enter_expression_statement(path, self)?;
            path.enter_field(ASTField::Expression);
            self.expression.walk(path, visitor)?;
            path.exit_field(ASTField::Expression);
            visitor.exit_expression_statement(path, self)?;
            path.exit_interface(ASTNode::ExpressionStatement);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ForInOfBinding {
        pub kind: VariableDeclarationKind,
        pub binding: Binding
    }

    impl FromJSON for ForInOfBinding {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ForInOfBinding") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ForInOfBinding".to_string(),
                    got: value.dump()
                })
            }
            Ok(ForInOfBinding { kind: FromJSON::import(&value["kind"])?, binding: FromJSON::import(&value["binding"])? })
        }
    }


    impl ToJSON for ForInOfBinding {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ForInOfBinding"),
                 "kind" => self.kind.export(),
                 "binding" => self.binding.export()
            }
        }
    }


    impl Walker for ForInOfBinding {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ForInOfBinding);
            visitor.enter_for_in_of_binding(path, self)?;
            path.enter_field(ASTField::Kind);
            self.kind.walk(path, visitor)?;
            path.exit_field(ASTField::Kind);
            path.enter_field(ASTField::Binding);
            self.binding.walk(path, visitor)?;
            path.exit_field(ASTField::Binding);
            visitor.exit_for_in_of_binding(path, self)?;
            path.exit_interface(ASTNode::ForInOfBinding);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ForInStatement {
        pub left: ForInOfBindingOrAssignmentTarget,
        pub right: Expression,
        pub body: Statement
    }

    impl FromJSON for ForInStatement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ForInStatement") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ForInStatement".to_string(),
                    got: value.dump()
                })
            }
            Ok(ForInStatement { left: FromJSON::import(&value["left"])?, right: FromJSON::import(&value["right"])?, body: FromJSON::import(&value["body"])? })
        }
    }


    impl ToJSON for ForInStatement {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ForInStatement"),
                 "left" => self.left.export(),
                 "right" => self.right.export(),
                 "body" => self.body.export()
            }
        }
    }


    impl Walker for ForInStatement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ForInStatement);
            visitor.enter_for_in_statement(path, self)?;
            path.enter_field(ASTField::Left);
            self.left.walk(path, visitor)?;
            path.exit_field(ASTField::Left);
            path.enter_field(ASTField::Right);
            self.right.walk(path, visitor)?;
            path.exit_field(ASTField::Right);
            path.enter_field(ASTField::Body);
            self.body.walk(path, visitor)?;
            path.exit_field(ASTField::Body);
            visitor.exit_for_in_statement(path, self)?;
            path.exit_interface(ASTNode::ForInStatement);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ForOfStatement {
        pub left: ForInOfBindingOrAssignmentTarget,
        pub right: Expression,
        pub body: Statement
    }

    impl FromJSON for ForOfStatement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ForOfStatement") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ForOfStatement".to_string(),
                    got: value.dump()
                })
            }
            Ok(ForOfStatement { left: FromJSON::import(&value["left"])?, right: FromJSON::import(&value["right"])?, body: FromJSON::import(&value["body"])? })
        }
    }


    impl ToJSON for ForOfStatement {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ForOfStatement"),
                 "left" => self.left.export(),
                 "right" => self.right.export(),
                 "body" => self.body.export()
            }
        }
    }


    impl Walker for ForOfStatement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ForOfStatement);
            visitor.enter_for_of_statement(path, self)?;
            path.enter_field(ASTField::Left);
            self.left.walk(path, visitor)?;
            path.exit_field(ASTField::Left);
            path.enter_field(ASTField::Right);
            self.right.walk(path, visitor)?;
            path.exit_field(ASTField::Right);
            path.enter_field(ASTField::Body);
            self.body.walk(path, visitor)?;
            path.exit_field(ASTField::Body);
            visitor.exit_for_of_statement(path, self)?;
            path.exit_interface(ASTNode::ForOfStatement);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ForStatement {
        pub init: OptionalVariableDeclarationOrExpression,
        pub test: OptionalExpression,
        pub update: OptionalExpression,
        pub body: Statement
    }

    impl FromJSON for ForStatement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ForStatement") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ForStatement".to_string(),
                    got: value.dump()
                })
            }
            Ok(ForStatement { init: FromJSON::import(&value["init"])?, test: FromJSON::import(&value["test"])?, update: FromJSON::import(&value["update"])?, body: FromJSON::import(&value["body"])? })
        }
    }


    impl ToJSON for ForStatement {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ForStatement"),
                 "init" => self.init.export(),
                 "test" => self.test.export(),
                 "update" => self.update.export(),
                 "body" => self.body.export()
            }
        }
    }


    impl Walker for ForStatement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ForStatement);
            visitor.enter_for_statement(path, self)?;
            path.enter_field(ASTField::Init);
            self.init.walk(path, visitor)?;
            path.exit_field(ASTField::Init);
            path.enter_field(ASTField::Test);
            self.test.walk(path, visitor)?;
            path.exit_field(ASTField::Test);
            path.enter_field(ASTField::Update);
            self.update.walk(path, visitor)?;
            path.exit_field(ASTField::Update);
            path.enter_field(ASTField::Body);
            self.body.walk(path, visitor)?;
            path.exit_field(ASTField::Body);
            visitor.exit_for_statement(path, self)?;
            path.exit_interface(ASTNode::ForStatement);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct FormalParameters {
        pub items: ListOfParameter,
        pub rest: OptionalBinding
    }

    impl FromJSON for FormalParameters {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("FormalParameters") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of FormalParameters".to_string(),
                    got: value.dump()
                })
            }
            Ok(FormalParameters { items: FromJSON::import(&value["items"])?, rest: FromJSON::import(&value["rest"])? })
        }
    }


    impl ToJSON for FormalParameters {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("FormalParameters"),
                 "items" => self.items.export(),
                 "rest" => self.rest.export()
            }
        }
    }


    impl Walker for FormalParameters {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::FormalParameters);
            visitor.enter_formal_parameters(path, self)?;
            path.enter_field(ASTField::Items);
            self.items.walk(path, visitor)?;
            path.exit_field(ASTField::Items);
            path.enter_field(ASTField::Rest);
            self.rest.walk(path, visitor)?;
            path.exit_field(ASTField::Rest);
            visitor.exit_formal_parameters(path, self)?;
            path.exit_interface(ASTNode::FormalParameters);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct FunctionBody {
        pub directives: ListOfDirective,
        pub statements: ListOfStatement
    }

    impl FromJSON for FunctionBody {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("FunctionBody") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of FunctionBody".to_string(),
                    got: value.dump()
                })
            }
            Ok(FunctionBody { directives: FromJSON::import(&value["directives"])?, statements: FromJSON::import(&value["statements"])? })
        }
    }


    impl ToJSON for FunctionBody {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("FunctionBody"),
                 "directives" => self.directives.export(),
                 "statements" => self.statements.export()
            }
        }
    }


    impl Walker for FunctionBody {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::FunctionBody);
            visitor.enter_function_body(path, self)?;
            path.enter_field(ASTField::Directives);
            self.directives.walk(path, visitor)?;
            path.exit_field(ASTField::Directives);
            path.enter_field(ASTField::Statements);
            self.statements.walk(path, visitor)?;
            path.exit_field(ASTField::Statements);
            visitor.exit_function_body(path, self)?;
            path.exit_interface(ASTNode::FunctionBody);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct FunctionDeclaration {
        pub is_async: bool,
        pub is_generator: bool,
        pub parameter_scope: OptionalAssertedParameterScope,
        pub body_scope: OptionalAssertedVarScope,
        pub name: BindingIdentifier,
        pub params: FormalParameters,
        pub body: FunctionBody
    }

    impl FromJSON for FunctionDeclaration {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("FunctionDeclaration") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of FunctionDeclaration".to_string(),
                    got: value.dump()
                })
            }
            Ok(FunctionDeclaration { is_async: FromJSON::import(&value["isAsync"])?, is_generator: FromJSON::import(&value["isGenerator"])?, parameter_scope: FromJSON::import(&value["parameterScope"])?, body_scope: FromJSON::import(&value["bodyScope"])?, name: FromJSON::import(&value["name"])?, params: FromJSON::import(&value["params"])?, body: FromJSON::import(&value["body"])? })
        }
    }


    impl ToJSON for FunctionDeclaration {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("FunctionDeclaration"),
                 "isAsync" => self.is_async.export(),
                 "isGenerator" => self.is_generator.export(),
                 "parameterScope" => self.parameter_scope.export(),
                 "bodyScope" => self.body_scope.export(),
                 "name" => self.name.export(),
                 "params" => self.params.export(),
                 "body" => self.body.export()
            }
        }
    }


    impl Walker for FunctionDeclaration {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::FunctionDeclaration);
            visitor.enter_function_declaration(path, self)?;
            path.enter_field(ASTField::IsAsync);
            self.is_async.walk(path, visitor)?;
            path.exit_field(ASTField::IsAsync);
            path.enter_field(ASTField::IsGenerator);
            self.is_generator.walk(path, visitor)?;
            path.exit_field(ASTField::IsGenerator);
            path.enter_field(ASTField::ParameterScope);
            self.parameter_scope.walk(path, visitor)?;
            path.exit_field(ASTField::ParameterScope);
            path.enter_field(ASTField::BodyScope);
            self.body_scope.walk(path, visitor)?;
            path.exit_field(ASTField::BodyScope);
            path.enter_field(ASTField::Name);
            self.name.walk(path, visitor)?;
            path.exit_field(ASTField::Name);
            path.enter_field(ASTField::Params);
            self.params.walk(path, visitor)?;
            path.exit_field(ASTField::Params);
            path.enter_field(ASTField::Body);
            self.body.walk(path, visitor)?;
            path.exit_field(ASTField::Body);
            visitor.exit_function_declaration(path, self)?;
            path.exit_interface(ASTNode::FunctionDeclaration);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct FunctionExpression {
        pub is_async: bool,
        pub is_generator: bool,
        pub parameter_scope: OptionalAssertedParameterScope,
        pub body_scope: OptionalAssertedVarScope,
        pub name: OptionalBindingIdentifier,
        pub params: FormalParameters,
        pub body: FunctionBody
    }

    impl FromJSON for FunctionExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("FunctionExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of FunctionExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(FunctionExpression { is_async: FromJSON::import(&value["isAsync"])?, is_generator: FromJSON::import(&value["isGenerator"])?, parameter_scope: FromJSON::import(&value["parameterScope"])?, body_scope: FromJSON::import(&value["bodyScope"])?, name: FromJSON::import(&value["name"])?, params: FromJSON::import(&value["params"])?, body: FromJSON::import(&value["body"])? })
        }
    }


    impl ToJSON for FunctionExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("FunctionExpression"),
                 "isAsync" => self.is_async.export(),
                 "isGenerator" => self.is_generator.export(),
                 "parameterScope" => self.parameter_scope.export(),
                 "bodyScope" => self.body_scope.export(),
                 "name" => self.name.export(),
                 "params" => self.params.export(),
                 "body" => self.body.export()
            }
        }
    }


    impl Walker for FunctionExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::FunctionExpression);
            visitor.enter_function_expression(path, self)?;
            path.enter_field(ASTField::IsAsync);
            self.is_async.walk(path, visitor)?;
            path.exit_field(ASTField::IsAsync);
            path.enter_field(ASTField::IsGenerator);
            self.is_generator.walk(path, visitor)?;
            path.exit_field(ASTField::IsGenerator);
            path.enter_field(ASTField::ParameterScope);
            self.parameter_scope.walk(path, visitor)?;
            path.exit_field(ASTField::ParameterScope);
            path.enter_field(ASTField::BodyScope);
            self.body_scope.walk(path, visitor)?;
            path.exit_field(ASTField::BodyScope);
            path.enter_field(ASTField::Name);
            self.name.walk(path, visitor)?;
            path.exit_field(ASTField::Name);
            path.enter_field(ASTField::Params);
            self.params.walk(path, visitor)?;
            path.exit_field(ASTField::Params);
            path.enter_field(ASTField::Body);
            self.body.walk(path, visitor)?;
            path.exit_field(ASTField::Body);
            visitor.exit_function_expression(path, self)?;
            path.exit_interface(ASTNode::FunctionExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct Getter {
        pub body_scope: OptionalAssertedVarScope,
        pub name: PropertyName,
        pub body: FunctionBody
    }

    impl FromJSON for Getter {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("Getter") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of Getter".to_string(),
                    got: value.dump()
                })
            }
            Ok(Getter { body_scope: FromJSON::import(&value["bodyScope"])?, name: FromJSON::import(&value["name"])?, body: FromJSON::import(&value["body"])? })
        }
    }


    impl ToJSON for Getter {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("Getter"),
                 "bodyScope" => self.body_scope.export(),
                 "name" => self.name.export(),
                 "body" => self.body.export()
            }
        }
    }


    impl Walker for Getter {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::Getter);
            visitor.enter_getter(path, self)?;
            path.enter_field(ASTField::BodyScope);
            self.body_scope.walk(path, visitor)?;
            path.exit_field(ASTField::BodyScope);
            path.enter_field(ASTField::Name);
            self.name.walk(path, visitor)?;
            path.exit_field(ASTField::Name);
            path.enter_field(ASTField::Body);
            self.body.walk(path, visitor)?;
            path.exit_field(ASTField::Body);
            visitor.exit_getter(path, self)?;
            path.exit_interface(ASTNode::Getter);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct IdentifierExpression {
        pub name: Identifier
    }

    impl FromJSON for IdentifierExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("IdentifierExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of IdentifierExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(IdentifierExpression { name: FromJSON::import(&value["name"])? })
        }
    }


    impl ToJSON for IdentifierExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("IdentifierExpression"),
                 "name" => self.name.export()
            }
        }
    }


    impl Walker for IdentifierExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::IdentifierExpression);
            visitor.enter_identifier_expression(path, self)?;
            path.enter_field(ASTField::Name);
            self.name.walk(path, visitor)?;
            path.exit_field(ASTField::Name);
            visitor.exit_identifier_expression(path, self)?;
            path.exit_interface(ASTNode::IdentifierExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct IfStatement {
        pub test: Expression,
        pub consequent: Statement,
        pub alternate: OptionalStatement
    }

    impl FromJSON for IfStatement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("IfStatement") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of IfStatement".to_string(),
                    got: value.dump()
                })
            }
            Ok(IfStatement { test: FromJSON::import(&value["test"])?, consequent: FromJSON::import(&value["consequent"])?, alternate: FromJSON::import(&value["alternate"])? })
        }
    }


    impl ToJSON for IfStatement {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("IfStatement"),
                 "test" => self.test.export(),
                 "consequent" => self.consequent.export(),
                 "alternate" => self.alternate.export()
            }
        }
    }


    impl Walker for IfStatement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::IfStatement);
            visitor.enter_if_statement(path, self)?;
            path.enter_field(ASTField::Test);
            self.test.walk(path, visitor)?;
            path.exit_field(ASTField::Test);
            path.enter_field(ASTField::Consequent);
            self.consequent.walk(path, visitor)?;
            path.exit_field(ASTField::Consequent);
            path.enter_field(ASTField::Alternate);
            self.alternate.walk(path, visitor)?;
            path.exit_field(ASTField::Alternate);
            visitor.exit_if_statement(path, self)?;
            path.exit_interface(ASTNode::IfStatement);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct Import {
        pub module_specifier: String,
        pub default_binding: OptionalBindingIdentifier,
        pub named_imports: ListOfImportSpecifier
    }

    impl FromJSON for Import {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("Import") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of Import".to_string(),
                    got: value.dump()
                })
            }
            Ok(Import { module_specifier: FromJSON::import(&value["moduleSpecifier"])?, default_binding: FromJSON::import(&value["defaultBinding"])?, named_imports: FromJSON::import(&value["namedImports"])? })
        }
    }


    impl ToJSON for Import {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("Import"),
                 "moduleSpecifier" => self.module_specifier.export(),
                 "defaultBinding" => self.default_binding.export(),
                 "namedImports" => self.named_imports.export()
            }
        }
    }


    impl Walker for Import {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::Import);
            visitor.enter_import(path, self)?;
            path.enter_field(ASTField::ModuleSpecifier);
            self.module_specifier.walk(path, visitor)?;
            path.exit_field(ASTField::ModuleSpecifier);
            path.enter_field(ASTField::DefaultBinding);
            self.default_binding.walk(path, visitor)?;
            path.exit_field(ASTField::DefaultBinding);
            path.enter_field(ASTField::NamedImports);
            self.named_imports.walk(path, visitor)?;
            path.exit_field(ASTField::NamedImports);
            visitor.exit_import(path, self)?;
            path.exit_interface(ASTNode::Import);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ImportNamespace {
        pub module_specifier: String,
        pub default_binding: OptionalBindingIdentifier,
        pub namespace_binding: BindingIdentifier
    }

    impl FromJSON for ImportNamespace {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ImportNamespace") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ImportNamespace".to_string(),
                    got: value.dump()
                })
            }
            Ok(ImportNamespace { module_specifier: FromJSON::import(&value["moduleSpecifier"])?, default_binding: FromJSON::import(&value["defaultBinding"])?, namespace_binding: FromJSON::import(&value["namespaceBinding"])? })
        }
    }


    impl ToJSON for ImportNamespace {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ImportNamespace"),
                 "moduleSpecifier" => self.module_specifier.export(),
                 "defaultBinding" => self.default_binding.export(),
                 "namespaceBinding" => self.namespace_binding.export()
            }
        }
    }


    impl Walker for ImportNamespace {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ImportNamespace);
            visitor.enter_import_namespace(path, self)?;
            path.enter_field(ASTField::ModuleSpecifier);
            self.module_specifier.walk(path, visitor)?;
            path.exit_field(ASTField::ModuleSpecifier);
            path.enter_field(ASTField::DefaultBinding);
            self.default_binding.walk(path, visitor)?;
            path.exit_field(ASTField::DefaultBinding);
            path.enter_field(ASTField::NamespaceBinding);
            self.namespace_binding.walk(path, visitor)?;
            path.exit_field(ASTField::NamespaceBinding);
            visitor.exit_import_namespace(path, self)?;
            path.exit_interface(ASTNode::ImportNamespace);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ImportSpecifier {
        pub name: OptionalIdentifierName,
        pub binding: BindingIdentifier
    }

    impl FromJSON for ImportSpecifier {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ImportSpecifier") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ImportSpecifier".to_string(),
                    got: value.dump()
                })
            }
            Ok(ImportSpecifier { name: FromJSON::import(&value["name"])?, binding: FromJSON::import(&value["binding"])? })
        }
    }


    impl ToJSON for ImportSpecifier {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ImportSpecifier"),
                 "name" => self.name.export(),
                 "binding" => self.binding.export()
            }
        }
    }


    impl Walker for ImportSpecifier {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ImportSpecifier);
            visitor.enter_import_specifier(path, self)?;
            path.enter_field(ASTField::Name);
            self.name.walk(path, visitor)?;
            path.exit_field(ASTField::Name);
            path.enter_field(ASTField::Binding);
            self.binding.walk(path, visitor)?;
            path.exit_field(ASTField::Binding);
            visitor.exit_import_specifier(path, self)?;
            path.exit_interface(ASTNode::ImportSpecifier);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct LabelledStatement {
        pub label: Label,
        pub body: Statement
    }

    impl FromJSON for LabelledStatement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("LabelledStatement") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of LabelledStatement".to_string(),
                    got: value.dump()
                })
            }
            Ok(LabelledStatement { label: FromJSON::import(&value["label"])?, body: FromJSON::import(&value["body"])? })
        }
    }


    impl ToJSON for LabelledStatement {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("LabelledStatement"),
                 "label" => self.label.export(),
                 "body" => self.body.export()
            }
        }
    }


    impl Walker for LabelledStatement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::LabelledStatement);
            visitor.enter_labelled_statement(path, self)?;
            path.enter_field(ASTField::Label);
            self.label.walk(path, visitor)?;
            path.exit_field(ASTField::Label);
            path.enter_field(ASTField::Body);
            self.body.walk(path, visitor)?;
            path.exit_field(ASTField::Body);
            visitor.exit_labelled_statement(path, self)?;
            path.exit_interface(ASTNode::LabelledStatement);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct LiteralBooleanExpression {
        pub value: bool
    }

    impl FromJSON for LiteralBooleanExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("LiteralBooleanExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of LiteralBooleanExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(LiteralBooleanExpression { value: FromJSON::import(&value["value"])? })
        }
    }


    impl ToJSON for LiteralBooleanExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("LiteralBooleanExpression"),
                 "value" => self.value.export()
            }
        }
    }


    impl Walker for LiteralBooleanExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::LiteralBooleanExpression);
            visitor.enter_literal_boolean_expression(path, self)?;
            path.enter_field(ASTField::Value);
            self.value.walk(path, visitor)?;
            path.exit_field(ASTField::Value);
            visitor.exit_literal_boolean_expression(path, self)?;
            path.exit_interface(ASTNode::LiteralBooleanExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct LiteralInfinityExpression {

    }

    impl FromJSON for LiteralInfinityExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("LiteralInfinityExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of LiteralInfinityExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(LiteralInfinityExpression {  })
        }
    }


    impl ToJSON for LiteralInfinityExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("LiteralInfinityExpression"),

            }
        }
    }


    impl Walker for LiteralInfinityExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::LiteralInfinityExpression);
            visitor.enter_literal_infinity_expression(path, self)?;

            visitor.exit_literal_infinity_expression(path, self)?;
            path.exit_interface(ASTNode::LiteralInfinityExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct LiteralNullExpression {

    }

    impl FromJSON for LiteralNullExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("LiteralNullExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of LiteralNullExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(LiteralNullExpression {  })
        }
    }


    impl ToJSON for LiteralNullExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("LiteralNullExpression"),

            }
        }
    }


    impl Walker for LiteralNullExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::LiteralNullExpression);
            visitor.enter_literal_null_expression(path, self)?;

            visitor.exit_literal_null_expression(path, self)?;
            path.exit_interface(ASTNode::LiteralNullExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct LiteralNumericExpression {
        pub value: f64
    }

    impl FromJSON for LiteralNumericExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("LiteralNumericExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of LiteralNumericExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(LiteralNumericExpression { value: FromJSON::import(&value["value"])? })
        }
    }


    impl ToJSON for LiteralNumericExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("LiteralNumericExpression"),
                 "value" => self.value.export()
            }
        }
    }


    impl Walker for LiteralNumericExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::LiteralNumericExpression);
            visitor.enter_literal_numeric_expression(path, self)?;
            path.enter_field(ASTField::Value);
            self.value.walk(path, visitor)?;
            path.exit_field(ASTField::Value);
            visitor.exit_literal_numeric_expression(path, self)?;
            path.exit_interface(ASTNode::LiteralNumericExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct LiteralPropertyName {
        pub value: String
    }

    impl FromJSON for LiteralPropertyName {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("LiteralPropertyName") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of LiteralPropertyName".to_string(),
                    got: value.dump()
                })
            }
            Ok(LiteralPropertyName { value: FromJSON::import(&value["value"])? })
        }
    }


    impl ToJSON for LiteralPropertyName {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("LiteralPropertyName"),
                 "value" => self.value.export()
            }
        }
    }


    impl Walker for LiteralPropertyName {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::LiteralPropertyName);
            visitor.enter_literal_property_name(path, self)?;
            path.enter_field(ASTField::Value);
            self.value.walk(path, visitor)?;
            path.exit_field(ASTField::Value);
            visitor.exit_literal_property_name(path, self)?;
            path.exit_interface(ASTNode::LiteralPropertyName);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct LiteralRegExpExpression {
        pub pattern: String,
        pub flags: String
    }

    impl FromJSON for LiteralRegExpExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("LiteralRegExpExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of LiteralRegExpExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(LiteralRegExpExpression { pattern: FromJSON::import(&value["pattern"])?, flags: FromJSON::import(&value["flags"])? })
        }
    }


    impl ToJSON for LiteralRegExpExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("LiteralRegExpExpression"),
                 "pattern" => self.pattern.export(),
                 "flags" => self.flags.export()
            }
        }
    }


    impl Walker for LiteralRegExpExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::LiteralRegExpExpression);
            visitor.enter_literal_reg_exp_expression(path, self)?;
            path.enter_field(ASTField::Pattern);
            self.pattern.walk(path, visitor)?;
            path.exit_field(ASTField::Pattern);
            path.enter_field(ASTField::Flags);
            self.flags.walk(path, visitor)?;
            path.exit_field(ASTField::Flags);
            visitor.exit_literal_reg_exp_expression(path, self)?;
            path.exit_interface(ASTNode::LiteralRegExpExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct LiteralStringExpression {
        pub value: String
    }

    impl FromJSON for LiteralStringExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("LiteralStringExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of LiteralStringExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(LiteralStringExpression { value: FromJSON::import(&value["value"])? })
        }
    }


    impl ToJSON for LiteralStringExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("LiteralStringExpression"),
                 "value" => self.value.export()
            }
        }
    }


    impl Walker for LiteralStringExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::LiteralStringExpression);
            visitor.enter_literal_string_expression(path, self)?;
            path.enter_field(ASTField::Value);
            self.value.walk(path, visitor)?;
            path.exit_field(ASTField::Value);
            visitor.exit_literal_string_expression(path, self)?;
            path.exit_interface(ASTNode::LiteralStringExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct Method {
        pub is_async: bool,
        pub is_generator: bool,
        pub parameter_scope: OptionalAssertedParameterScope,
        pub body_scope: OptionalAssertedVarScope,
        pub name: PropertyName,
        pub params: FormalParameters,
        pub body: FunctionBody
    }

    impl FromJSON for Method {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("Method") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of Method".to_string(),
                    got: value.dump()
                })
            }
            Ok(Method { is_async: FromJSON::import(&value["isAsync"])?, is_generator: FromJSON::import(&value["isGenerator"])?, parameter_scope: FromJSON::import(&value["parameterScope"])?, body_scope: FromJSON::import(&value["bodyScope"])?, name: FromJSON::import(&value["name"])?, params: FromJSON::import(&value["params"])?, body: FromJSON::import(&value["body"])? })
        }
    }


    impl ToJSON for Method {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("Method"),
                 "isAsync" => self.is_async.export(),
                 "isGenerator" => self.is_generator.export(),
                 "parameterScope" => self.parameter_scope.export(),
                 "bodyScope" => self.body_scope.export(),
                 "name" => self.name.export(),
                 "params" => self.params.export(),
                 "body" => self.body.export()
            }
        }
    }


    impl Walker for Method {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::Method);
            visitor.enter_method(path, self)?;
            path.enter_field(ASTField::IsAsync);
            self.is_async.walk(path, visitor)?;
            path.exit_field(ASTField::IsAsync);
            path.enter_field(ASTField::IsGenerator);
            self.is_generator.walk(path, visitor)?;
            path.exit_field(ASTField::IsGenerator);
            path.enter_field(ASTField::ParameterScope);
            self.parameter_scope.walk(path, visitor)?;
            path.exit_field(ASTField::ParameterScope);
            path.enter_field(ASTField::BodyScope);
            self.body_scope.walk(path, visitor)?;
            path.exit_field(ASTField::BodyScope);
            path.enter_field(ASTField::Name);
            self.name.walk(path, visitor)?;
            path.exit_field(ASTField::Name);
            path.enter_field(ASTField::Params);
            self.params.walk(path, visitor)?;
            path.exit_field(ASTField::Params);
            path.enter_field(ASTField::Body);
            self.body.walk(path, visitor)?;
            path.exit_field(ASTField::Body);
            visitor.exit_method(path, self)?;
            path.exit_interface(ASTNode::Method);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct Module {
        pub scope: OptionalAssertedVarScope,
        pub directives: ListOfDirective,
        pub items: ListOfImportDeclarationOrExportDeclarationOrStatement
    }

    impl FromJSON for Module {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("Module") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of Module".to_string(),
                    got: value.dump()
                })
            }
            Ok(Module { scope: FromJSON::import(&value["scope"])?, directives: FromJSON::import(&value["directives"])?, items: FromJSON::import(&value["items"])? })
        }
    }


    impl ToJSON for Module {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("Module"),
                 "scope" => self.scope.export(),
                 "directives" => self.directives.export(),
                 "items" => self.items.export()
            }
        }
    }


    impl Walker for Module {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::Module);
            visitor.enter_module(path, self)?;
            path.enter_field(ASTField::Scope);
            self.scope.walk(path, visitor)?;
            path.exit_field(ASTField::Scope);
            path.enter_field(ASTField::Directives);
            self.directives.walk(path, visitor)?;
            path.exit_field(ASTField::Directives);
            path.enter_field(ASTField::Items);
            self.items.walk(path, visitor)?;
            path.exit_field(ASTField::Items);
            visitor.exit_module(path, self)?;
            path.exit_interface(ASTNode::Module);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct NewExpression {
        pub callee: Expression,
        pub arguments: Arguments
    }

    impl FromJSON for NewExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("NewExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of NewExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(NewExpression { callee: FromJSON::import(&value["callee"])?, arguments: FromJSON::import(&value["arguments"])? })
        }
    }


    impl ToJSON for NewExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("NewExpression"),
                 "callee" => self.callee.export(),
                 "arguments" => self.arguments.export()
            }
        }
    }


    impl Walker for NewExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::NewExpression);
            visitor.enter_new_expression(path, self)?;
            path.enter_field(ASTField::Callee);
            self.callee.walk(path, visitor)?;
            path.exit_field(ASTField::Callee);
            path.enter_field(ASTField::Arguments);
            self.arguments.walk(path, visitor)?;
            path.exit_field(ASTField::Arguments);
            visitor.exit_new_expression(path, self)?;
            path.exit_interface(ASTNode::NewExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct NewTargetExpression {

    }

    impl FromJSON for NewTargetExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("NewTargetExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of NewTargetExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(NewTargetExpression {  })
        }
    }


    impl ToJSON for NewTargetExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("NewTargetExpression"),

            }
        }
    }


    impl Walker for NewTargetExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::NewTargetExpression);
            visitor.enter_new_target_expression(path, self)?;

            visitor.exit_new_target_expression(path, self)?;
            path.exit_interface(ASTNode::NewTargetExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ObjectAssignmentTarget {
        pub properties: ListOfAssignmentTargetProperty
    }

    impl FromJSON for ObjectAssignmentTarget {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ObjectAssignmentTarget") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ObjectAssignmentTarget".to_string(),
                    got: value.dump()
                })
            }
            Ok(ObjectAssignmentTarget { properties: FromJSON::import(&value["properties"])? })
        }
    }


    impl ToJSON for ObjectAssignmentTarget {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ObjectAssignmentTarget"),
                 "properties" => self.properties.export()
            }
        }
    }


    impl Walker for ObjectAssignmentTarget {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ObjectAssignmentTarget);
            visitor.enter_object_assignment_target(path, self)?;
            path.enter_field(ASTField::Properties);
            self.properties.walk(path, visitor)?;
            path.exit_field(ASTField::Properties);
            visitor.exit_object_assignment_target(path, self)?;
            path.exit_interface(ASTNode::ObjectAssignmentTarget);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ObjectBinding {
        pub properties: ListOfBindingProperty
    }

    impl FromJSON for ObjectBinding {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ObjectBinding") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ObjectBinding".to_string(),
                    got: value.dump()
                })
            }
            Ok(ObjectBinding { properties: FromJSON::import(&value["properties"])? })
        }
    }


    impl ToJSON for ObjectBinding {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ObjectBinding"),
                 "properties" => self.properties.export()
            }
        }
    }


    impl Walker for ObjectBinding {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ObjectBinding);
            visitor.enter_object_binding(path, self)?;
            path.enter_field(ASTField::Properties);
            self.properties.walk(path, visitor)?;
            path.exit_field(ASTField::Properties);
            visitor.exit_object_binding(path, self)?;
            path.exit_interface(ASTNode::ObjectBinding);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ObjectExpression {
        pub properties: ListOfObjectProperty
    }

    impl FromJSON for ObjectExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ObjectExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ObjectExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(ObjectExpression { properties: FromJSON::import(&value["properties"])? })
        }
    }


    impl ToJSON for ObjectExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ObjectExpression"),
                 "properties" => self.properties.export()
            }
        }
    }


    impl Walker for ObjectExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ObjectExpression);
            visitor.enter_object_expression(path, self)?;
            path.enter_field(ASTField::Properties);
            self.properties.walk(path, visitor)?;
            path.exit_field(ASTField::Properties);
            visitor.exit_object_expression(path, self)?;
            path.exit_interface(ASTNode::ObjectExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ReturnStatement {
        pub expression: OptionalExpression
    }

    impl FromJSON for ReturnStatement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ReturnStatement") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ReturnStatement".to_string(),
                    got: value.dump()
                })
            }
            Ok(ReturnStatement { expression: FromJSON::import(&value["expression"])? })
        }
    }


    impl ToJSON for ReturnStatement {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ReturnStatement"),
                 "expression" => self.expression.export()
            }
        }
    }


    impl Walker for ReturnStatement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ReturnStatement);
            visitor.enter_return_statement(path, self)?;
            path.enter_field(ASTField::Expression);
            self.expression.walk(path, visitor)?;
            path.exit_field(ASTField::Expression);
            visitor.exit_return_statement(path, self)?;
            path.exit_interface(ASTNode::ReturnStatement);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct Script {
        pub scope: OptionalAssertedVarScope,
        pub directives: ListOfDirective,
        pub statements: ListOfStatement
    }

    impl FromJSON for Script {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("Script") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of Script".to_string(),
                    got: value.dump()
                })
            }
            Ok(Script { scope: FromJSON::import(&value["scope"])?, directives: FromJSON::import(&value["directives"])?, statements: FromJSON::import(&value["statements"])? })
        }
    }


    impl ToJSON for Script {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("Script"),
                 "scope" => self.scope.export(),
                 "directives" => self.directives.export(),
                 "statements" => self.statements.export()
            }
        }
    }


    impl Walker for Script {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::Script);
            visitor.enter_script(path, self)?;
            path.enter_field(ASTField::Scope);
            self.scope.walk(path, visitor)?;
            path.exit_field(ASTField::Scope);
            path.enter_field(ASTField::Directives);
            self.directives.walk(path, visitor)?;
            path.exit_field(ASTField::Directives);
            path.enter_field(ASTField::Statements);
            self.statements.walk(path, visitor)?;
            path.exit_field(ASTField::Statements);
            visitor.exit_script(path, self)?;
            path.exit_interface(ASTNode::Script);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct Setter {
        pub parameter_scope: OptionalAssertedParameterScope,
        pub body_scope: OptionalAssertedVarScope,
        pub name: PropertyName,
        pub param: Parameter,
        pub body: FunctionBody
    }

    impl FromJSON for Setter {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("Setter") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of Setter".to_string(),
                    got: value.dump()
                })
            }
            Ok(Setter { parameter_scope: FromJSON::import(&value["parameterScope"])?, body_scope: FromJSON::import(&value["bodyScope"])?, name: FromJSON::import(&value["name"])?, param: FromJSON::import(&value["param"])?, body: FromJSON::import(&value["body"])? })
        }
    }


    impl ToJSON for Setter {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("Setter"),
                 "parameterScope" => self.parameter_scope.export(),
                 "bodyScope" => self.body_scope.export(),
                 "name" => self.name.export(),
                 "param" => self.param.export(),
                 "body" => self.body.export()
            }
        }
    }


    impl Walker for Setter {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::Setter);
            visitor.enter_setter(path, self)?;
            path.enter_field(ASTField::ParameterScope);
            self.parameter_scope.walk(path, visitor)?;
            path.exit_field(ASTField::ParameterScope);
            path.enter_field(ASTField::BodyScope);
            self.body_scope.walk(path, visitor)?;
            path.exit_field(ASTField::BodyScope);
            path.enter_field(ASTField::Name);
            self.name.walk(path, visitor)?;
            path.exit_field(ASTField::Name);
            path.enter_field(ASTField::Param);
            self.param.walk(path, visitor)?;
            path.exit_field(ASTField::Param);
            path.enter_field(ASTField::Body);
            self.body.walk(path, visitor)?;
            path.exit_field(ASTField::Body);
            visitor.exit_setter(path, self)?;
            path.exit_interface(ASTNode::Setter);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ShorthandProperty {
        pub name: IdentifierExpression
    }

    impl FromJSON for ShorthandProperty {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ShorthandProperty") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ShorthandProperty".to_string(),
                    got: value.dump()
                })
            }
            Ok(ShorthandProperty { name: FromJSON::import(&value["name"])? })
        }
    }


    impl ToJSON for ShorthandProperty {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ShorthandProperty"),
                 "name" => self.name.export()
            }
        }
    }


    impl Walker for ShorthandProperty {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ShorthandProperty);
            visitor.enter_shorthand_property(path, self)?;
            path.enter_field(ASTField::Name);
            self.name.walk(path, visitor)?;
            path.exit_field(ASTField::Name);
            visitor.exit_shorthand_property(path, self)?;
            path.exit_interface(ASTNode::ShorthandProperty);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct SpreadElement {
        pub expression: Expression
    }

    impl FromJSON for SpreadElement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("SpreadElement") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of SpreadElement".to_string(),
                    got: value.dump()
                })
            }
            Ok(SpreadElement { expression: FromJSON::import(&value["expression"])? })
        }
    }


    impl ToJSON for SpreadElement {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("SpreadElement"),
                 "expression" => self.expression.export()
            }
        }
    }


    impl Walker for SpreadElement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::SpreadElement);
            visitor.enter_spread_element(path, self)?;
            path.enter_field(ASTField::Expression);
            self.expression.walk(path, visitor)?;
            path.exit_field(ASTField::Expression);
            visitor.exit_spread_element(path, self)?;
            path.exit_interface(ASTNode::SpreadElement);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct StaticMemberAssignmentTarget {
        pub object: ExpressionOrSuper,
        pub property: IdentifierName
    }

    impl FromJSON for StaticMemberAssignmentTarget {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("StaticMemberAssignmentTarget") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of StaticMemberAssignmentTarget".to_string(),
                    got: value.dump()
                })
            }
            Ok(StaticMemberAssignmentTarget { object: FromJSON::import(&value["object"])?, property: FromJSON::import(&value["property"])? })
        }
    }


    impl ToJSON for StaticMemberAssignmentTarget {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("StaticMemberAssignmentTarget"),
                 "object" => self.object.export(),
                 "property" => self.property.export()
            }
        }
    }


    impl Walker for StaticMemberAssignmentTarget {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::StaticMemberAssignmentTarget);
            visitor.enter_static_member_assignment_target(path, self)?;
            path.enter_field(ASTField::Object);
            self.object.walk(path, visitor)?;
            path.exit_field(ASTField::Object);
            path.enter_field(ASTField::Property);
            self.property.walk(path, visitor)?;
            path.exit_field(ASTField::Property);
            visitor.exit_static_member_assignment_target(path, self)?;
            path.exit_interface(ASTNode::StaticMemberAssignmentTarget);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct StaticMemberExpression {
        pub object: ExpressionOrSuper,
        pub property: IdentifierName
    }

    impl FromJSON for StaticMemberExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("StaticMemberExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of StaticMemberExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(StaticMemberExpression { object: FromJSON::import(&value["object"])?, property: FromJSON::import(&value["property"])? })
        }
    }


    impl ToJSON for StaticMemberExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("StaticMemberExpression"),
                 "object" => self.object.export(),
                 "property" => self.property.export()
            }
        }
    }


    impl Walker for StaticMemberExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::StaticMemberExpression);
            visitor.enter_static_member_expression(path, self)?;
            path.enter_field(ASTField::Object);
            self.object.walk(path, visitor)?;
            path.exit_field(ASTField::Object);
            path.enter_field(ASTField::Property);
            self.property.walk(path, visitor)?;
            path.exit_field(ASTField::Property);
            visitor.exit_static_member_expression(path, self)?;
            path.exit_interface(ASTNode::StaticMemberExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct Super {

    }

    impl FromJSON for Super {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("Super") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of Super".to_string(),
                    got: value.dump()
                })
            }
            Ok(Super {  })
        }
    }


    impl ToJSON for Super {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("Super"),

            }
        }
    }


    impl Walker for Super {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::Super);
            visitor.enter_super_(path, self)?;

            visitor.exit_super_(path, self)?;
            path.exit_interface(ASTNode::Super);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct SwitchCase {
        pub test: Expression,
        pub consequent: ListOfStatement
    }

    impl FromJSON for SwitchCase {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("SwitchCase") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of SwitchCase".to_string(),
                    got: value.dump()
                })
            }
            Ok(SwitchCase { test: FromJSON::import(&value["test"])?, consequent: FromJSON::import(&value["consequent"])? })
        }
    }


    impl ToJSON for SwitchCase {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("SwitchCase"),
                 "test" => self.test.export(),
                 "consequent" => self.consequent.export()
            }
        }
    }


    impl Walker for SwitchCase {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::SwitchCase);
            visitor.enter_switch_case(path, self)?;
            path.enter_field(ASTField::Test);
            self.test.walk(path, visitor)?;
            path.exit_field(ASTField::Test);
            path.enter_field(ASTField::Consequent);
            self.consequent.walk(path, visitor)?;
            path.exit_field(ASTField::Consequent);
            visitor.exit_switch_case(path, self)?;
            path.exit_interface(ASTNode::SwitchCase);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct SwitchDefault {
        pub consequent: ListOfStatement
    }

    impl FromJSON for SwitchDefault {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("SwitchDefault") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of SwitchDefault".to_string(),
                    got: value.dump()
                })
            }
            Ok(SwitchDefault { consequent: FromJSON::import(&value["consequent"])? })
        }
    }


    impl ToJSON for SwitchDefault {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("SwitchDefault"),
                 "consequent" => self.consequent.export()
            }
        }
    }


    impl Walker for SwitchDefault {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::SwitchDefault);
            visitor.enter_switch_default(path, self)?;
            path.enter_field(ASTField::Consequent);
            self.consequent.walk(path, visitor)?;
            path.exit_field(ASTField::Consequent);
            visitor.exit_switch_default(path, self)?;
            path.exit_interface(ASTNode::SwitchDefault);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct SwitchStatement {
        pub discriminant: Expression,
        pub cases: ListOfSwitchCase
    }

    impl FromJSON for SwitchStatement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("SwitchStatement") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of SwitchStatement".to_string(),
                    got: value.dump()
                })
            }
            Ok(SwitchStatement { discriminant: FromJSON::import(&value["discriminant"])?, cases: FromJSON::import(&value["cases"])? })
        }
    }


    impl ToJSON for SwitchStatement {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("SwitchStatement"),
                 "discriminant" => self.discriminant.export(),
                 "cases" => self.cases.export()
            }
        }
    }


    impl Walker for SwitchStatement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::SwitchStatement);
            visitor.enter_switch_statement(path, self)?;
            path.enter_field(ASTField::Discriminant);
            self.discriminant.walk(path, visitor)?;
            path.exit_field(ASTField::Discriminant);
            path.enter_field(ASTField::Cases);
            self.cases.walk(path, visitor)?;
            path.exit_field(ASTField::Cases);
            visitor.exit_switch_statement(path, self)?;
            path.exit_interface(ASTNode::SwitchStatement);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct SwitchStatementWithDefault {
        pub discriminant: Expression,
        pub pre_default_cases: ListOfSwitchCase,
        pub default_case: SwitchDefault,
        pub post_default_cases: ListOfSwitchCase
    }

    impl FromJSON for SwitchStatementWithDefault {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("SwitchStatementWithDefault") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of SwitchStatementWithDefault".to_string(),
                    got: value.dump()
                })
            }
            Ok(SwitchStatementWithDefault { discriminant: FromJSON::import(&value["discriminant"])?, pre_default_cases: FromJSON::import(&value["preDefaultCases"])?, default_case: FromJSON::import(&value["defaultCase"])?, post_default_cases: FromJSON::import(&value["postDefaultCases"])? })
        }
    }


    impl ToJSON for SwitchStatementWithDefault {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("SwitchStatementWithDefault"),
                 "discriminant" => self.discriminant.export(),
                 "preDefaultCases" => self.pre_default_cases.export(),
                 "defaultCase" => self.default_case.export(),
                 "postDefaultCases" => self.post_default_cases.export()
            }
        }
    }


    impl Walker for SwitchStatementWithDefault {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::SwitchStatementWithDefault);
            visitor.enter_switch_statement_with_default(path, self)?;
            path.enter_field(ASTField::Discriminant);
            self.discriminant.walk(path, visitor)?;
            path.exit_field(ASTField::Discriminant);
            path.enter_field(ASTField::PreDefaultCases);
            self.pre_default_cases.walk(path, visitor)?;
            path.exit_field(ASTField::PreDefaultCases);
            path.enter_field(ASTField::DefaultCase);
            self.default_case.walk(path, visitor)?;
            path.exit_field(ASTField::DefaultCase);
            path.enter_field(ASTField::PostDefaultCases);
            self.post_default_cases.walk(path, visitor)?;
            path.exit_field(ASTField::PostDefaultCases);
            visitor.exit_switch_statement_with_default(path, self)?;
            path.exit_interface(ASTNode::SwitchStatementWithDefault);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct TemplateElement {
        pub raw_value: String
    }

    impl FromJSON for TemplateElement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("TemplateElement") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of TemplateElement".to_string(),
                    got: value.dump()
                })
            }
            Ok(TemplateElement { raw_value: FromJSON::import(&value["rawValue"])? })
        }
    }


    impl ToJSON for TemplateElement {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("TemplateElement"),
                 "rawValue" => self.raw_value.export()
            }
        }
    }


    impl Walker for TemplateElement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::TemplateElement);
            visitor.enter_template_element(path, self)?;
            path.enter_field(ASTField::RawValue);
            self.raw_value.walk(path, visitor)?;
            path.exit_field(ASTField::RawValue);
            visitor.exit_template_element(path, self)?;
            path.exit_interface(ASTNode::TemplateElement);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct TemplateExpression {
        pub tag: OptionalExpression,
        pub elements: ListOfExpressionOrTemplateElement
    }

    impl FromJSON for TemplateExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("TemplateExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of TemplateExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(TemplateExpression { tag: FromJSON::import(&value["tag"])?, elements: FromJSON::import(&value["elements"])? })
        }
    }


    impl ToJSON for TemplateExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("TemplateExpression"),
                 "tag" => self.tag.export(),
                 "elements" => self.elements.export()
            }
        }
    }


    impl Walker for TemplateExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::TemplateExpression);
            visitor.enter_template_expression(path, self)?;
            path.enter_field(ASTField::Tag);
            self.tag.walk(path, visitor)?;
            path.exit_field(ASTField::Tag);
            path.enter_field(ASTField::Elements);
            self.elements.walk(path, visitor)?;
            path.exit_field(ASTField::Elements);
            visitor.exit_template_expression(path, self)?;
            path.exit_interface(ASTNode::TemplateExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ThisExpression {

    }

    impl FromJSON for ThisExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ThisExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ThisExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(ThisExpression {  })
        }
    }


    impl ToJSON for ThisExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ThisExpression"),

            }
        }
    }


    impl Walker for ThisExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ThisExpression);
            visitor.enter_this_expression(path, self)?;

            visitor.exit_this_expression(path, self)?;
            path.exit_interface(ASTNode::ThisExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct ThrowStatement {
        pub expression: Expression
    }

    impl FromJSON for ThrowStatement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("ThrowStatement") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of ThrowStatement".to_string(),
                    got: value.dump()
                })
            }
            Ok(ThrowStatement { expression: FromJSON::import(&value["expression"])? })
        }
    }


    impl ToJSON for ThrowStatement {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("ThrowStatement"),
                 "expression" => self.expression.export()
            }
        }
    }


    impl Walker for ThrowStatement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::ThrowStatement);
            visitor.enter_throw_statement(path, self)?;
            path.enter_field(ASTField::Expression);
            self.expression.walk(path, visitor)?;
            path.exit_field(ASTField::Expression);
            visitor.exit_throw_statement(path, self)?;
            path.exit_interface(ASTNode::ThrowStatement);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct TryCatchStatement {
        pub body: Block,
        pub catch_clause: CatchClause
    }

    impl FromJSON for TryCatchStatement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("TryCatchStatement") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of TryCatchStatement".to_string(),
                    got: value.dump()
                })
            }
            Ok(TryCatchStatement { body: FromJSON::import(&value["body"])?, catch_clause: FromJSON::import(&value["catchClause"])? })
        }
    }


    impl ToJSON for TryCatchStatement {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("TryCatchStatement"),
                 "body" => self.body.export(),
                 "catchClause" => self.catch_clause.export()
            }
        }
    }


    impl Walker for TryCatchStatement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::TryCatchStatement);
            visitor.enter_try_catch_statement(path, self)?;
            path.enter_field(ASTField::Body);
            self.body.walk(path, visitor)?;
            path.exit_field(ASTField::Body);
            path.enter_field(ASTField::CatchClause);
            self.catch_clause.walk(path, visitor)?;
            path.exit_field(ASTField::CatchClause);
            visitor.exit_try_catch_statement(path, self)?;
            path.exit_interface(ASTNode::TryCatchStatement);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct TryFinallyStatement {
        pub body: Block,
        pub catch_clause: OptionalCatchClause,
        pub finalizer: Block
    }

    impl FromJSON for TryFinallyStatement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("TryFinallyStatement") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of TryFinallyStatement".to_string(),
                    got: value.dump()
                })
            }
            Ok(TryFinallyStatement { body: FromJSON::import(&value["body"])?, catch_clause: FromJSON::import(&value["catchClause"])?, finalizer: FromJSON::import(&value["finalizer"])? })
        }
    }


    impl ToJSON for TryFinallyStatement {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("TryFinallyStatement"),
                 "body" => self.body.export(),
                 "catchClause" => self.catch_clause.export(),
                 "finalizer" => self.finalizer.export()
            }
        }
    }


    impl Walker for TryFinallyStatement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::TryFinallyStatement);
            visitor.enter_try_finally_statement(path, self)?;
            path.enter_field(ASTField::Body);
            self.body.walk(path, visitor)?;
            path.exit_field(ASTField::Body);
            path.enter_field(ASTField::CatchClause);
            self.catch_clause.walk(path, visitor)?;
            path.exit_field(ASTField::CatchClause);
            path.enter_field(ASTField::Finalizer);
            self.finalizer.walk(path, visitor)?;
            path.exit_field(ASTField::Finalizer);
            visitor.exit_try_finally_statement(path, self)?;
            path.exit_interface(ASTNode::TryFinallyStatement);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct UnaryExpression {
        pub operator: UnaryOperator,
        pub operand: Expression
    }

    impl FromJSON for UnaryExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("UnaryExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of UnaryExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(UnaryExpression { operator: FromJSON::import(&value["operator"])?, operand: FromJSON::import(&value["operand"])? })
        }
    }


    impl ToJSON for UnaryExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("UnaryExpression"),
                 "operator" => self.operator.export(),
                 "operand" => self.operand.export()
            }
        }
    }


    impl Walker for UnaryExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::UnaryExpression);
            visitor.enter_unary_expression(path, self)?;
            path.enter_field(ASTField::Operator);
            self.operator.walk(path, visitor)?;
            path.exit_field(ASTField::Operator);
            path.enter_field(ASTField::Operand);
            self.operand.walk(path, visitor)?;
            path.exit_field(ASTField::Operand);
            visitor.exit_unary_expression(path, self)?;
            path.exit_interface(ASTNode::UnaryExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct UpdateExpression {
        pub is_prefix: bool,
        pub operator: UpdateOperator,
        pub operand: SimpleAssignmentTarget
    }

    impl FromJSON for UpdateExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("UpdateExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of UpdateExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(UpdateExpression { is_prefix: FromJSON::import(&value["isPrefix"])?, operator: FromJSON::import(&value["operator"])?, operand: FromJSON::import(&value["operand"])? })
        }
    }


    impl ToJSON for UpdateExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("UpdateExpression"),
                 "isPrefix" => self.is_prefix.export(),
                 "operator" => self.operator.export(),
                 "operand" => self.operand.export()
            }
        }
    }


    impl Walker for UpdateExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::UpdateExpression);
            visitor.enter_update_expression(path, self)?;
            path.enter_field(ASTField::IsPrefix);
            self.is_prefix.walk(path, visitor)?;
            path.exit_field(ASTField::IsPrefix);
            path.enter_field(ASTField::Operator);
            self.operator.walk(path, visitor)?;
            path.exit_field(ASTField::Operator);
            path.enter_field(ASTField::Operand);
            self.operand.walk(path, visitor)?;
            path.exit_field(ASTField::Operand);
            visitor.exit_update_expression(path, self)?;
            path.exit_interface(ASTNode::UpdateExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct VariableDeclaration {
        pub kind: VariableDeclarationKind,
        pub declarators: ListOfVariableDeclarator
    }

    impl FromJSON for VariableDeclaration {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("VariableDeclaration") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of VariableDeclaration".to_string(),
                    got: value.dump()
                })
            }
            Ok(VariableDeclaration { kind: FromJSON::import(&value["kind"])?, declarators: FromJSON::import(&value["declarators"])? })
        }
    }


    impl ToJSON for VariableDeclaration {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("VariableDeclaration"),
                 "kind" => self.kind.export(),
                 "declarators" => self.declarators.export()
            }
        }
    }


    impl Walker for VariableDeclaration {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::VariableDeclaration);
            visitor.enter_variable_declaration(path, self)?;
            path.enter_field(ASTField::Kind);
            self.kind.walk(path, visitor)?;
            path.exit_field(ASTField::Kind);
            path.enter_field(ASTField::Declarators);
            self.declarators.walk(path, visitor)?;
            path.exit_field(ASTField::Declarators);
            visitor.exit_variable_declaration(path, self)?;
            path.exit_interface(ASTNode::VariableDeclaration);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct VariableDeclarator {
        pub binding: Binding,
        pub init: OptionalExpression
    }

    impl FromJSON for VariableDeclarator {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("VariableDeclarator") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of VariableDeclarator".to_string(),
                    got: value.dump()
                })
            }
            Ok(VariableDeclarator { binding: FromJSON::import(&value["binding"])?, init: FromJSON::import(&value["init"])? })
        }
    }


    impl ToJSON for VariableDeclarator {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("VariableDeclarator"),
                 "binding" => self.binding.export(),
                 "init" => self.init.export()
            }
        }
    }


    impl Walker for VariableDeclarator {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::VariableDeclarator);
            visitor.enter_variable_declarator(path, self)?;
            path.enter_field(ASTField::Binding);
            self.binding.walk(path, visitor)?;
            path.exit_field(ASTField::Binding);
            path.enter_field(ASTField::Init);
            self.init.walk(path, visitor)?;
            path.exit_field(ASTField::Init);
            visitor.exit_variable_declarator(path, self)?;
            path.exit_interface(ASTNode::VariableDeclarator);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct WhileStatement {
        pub test: Expression,
        pub body: Statement
    }

    impl FromJSON for WhileStatement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("WhileStatement") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of WhileStatement".to_string(),
                    got: value.dump()
                })
            }
            Ok(WhileStatement { test: FromJSON::import(&value["test"])?, body: FromJSON::import(&value["body"])? })
        }
    }


    impl ToJSON for WhileStatement {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("WhileStatement"),
                 "test" => self.test.export(),
                 "body" => self.body.export()
            }
        }
    }


    impl Walker for WhileStatement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::WhileStatement);
            visitor.enter_while_statement(path, self)?;
            path.enter_field(ASTField::Test);
            self.test.walk(path, visitor)?;
            path.exit_field(ASTField::Test);
            path.enter_field(ASTField::Body);
            self.body.walk(path, visitor)?;
            path.exit_field(ASTField::Body);
            visitor.exit_while_statement(path, self)?;
            path.exit_interface(ASTNode::WhileStatement);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct WithStatement {
        pub object: Expression,
        pub body: Statement
    }

    impl FromJSON for WithStatement {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("WithStatement") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of WithStatement".to_string(),
                    got: value.dump()
                })
            }
            Ok(WithStatement { object: FromJSON::import(&value["object"])?, body: FromJSON::import(&value["body"])? })
        }
    }


    impl ToJSON for WithStatement {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("WithStatement"),
                 "object" => self.object.export(),
                 "body" => self.body.export()
            }
        }
    }


    impl Walker for WithStatement {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::WithStatement);
            visitor.enter_with_statement(path, self)?;
            path.enter_field(ASTField::Object);
            self.object.walk(path, visitor)?;
            path.exit_field(ASTField::Object);
            path.enter_field(ASTField::Body);
            self.body.walk(path, visitor)?;
            path.exit_field(ASTField::Body);
            visitor.exit_with_statement(path, self)?;
            path.exit_interface(ASTNode::WithStatement);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct YieldExpression {
        pub expression: OptionalExpression
    }

    impl FromJSON for YieldExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("YieldExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of YieldExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(YieldExpression { expression: FromJSON::import(&value["expression"])? })
        }
    }


    impl ToJSON for YieldExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("YieldExpression"),
                 "expression" => self.expression.export()
            }
        }
    }


    impl Walker for YieldExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::YieldExpression);
            visitor.enter_yield_expression(path, self)?;
            path.enter_field(ASTField::Expression);
            self.expression.walk(path, visitor)?;
            path.exit_field(ASTField::Expression);
            visitor.exit_yield_expression(path, self)?;
            path.exit_interface(ASTNode::YieldExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct YieldStarExpression {
        pub expression: Expression
    }

    impl FromJSON for YieldStarExpression {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("YieldStarExpression") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of YieldStarExpression".to_string(),
                    got: value.dump()
                })
            }
            Ok(YieldStarExpression { expression: FromJSON::import(&value["expression"])? })
        }
    }


    impl ToJSON for YieldStarExpression {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("YieldStarExpression"),
                 "expression" => self.expression.export()
            }
        }
    }


    impl Walker for YieldStarExpression {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::YieldStarExpression);
            visitor.enter_yield_star_expression(path, self)?;
            path.enter_field(ASTField::Expression);
            self.expression.walk(path, visitor)?;
            path.exit_field(ASTField::Expression);
            visitor.exit_yield_star_expression(path, self)?;
            path.exit_interface(ASTNode::YieldStarExpression);
            Ok(())
        }
    }



    #[derive(PartialEq, Debug, Clone)]
    pub struct Null {

    }

    impl FromJSON for Null {
        fn import(value: &JSON) -> Result<Self, FromJSONError> {
            match value["type"].as_str() {
                Some("Null") => { /* Good */ },
                _ => return Err(FromJSONError {
                    expected: "Instance of Null".to_string(),
                    got: value.dump()
                })
            }
            Ok(Null {  })
        }
    }


    impl ToJSON for Null {
        fn export(&self) -> JSON {
            object!{
                "type" => json::from("Null"),

            }
        }
    }


    impl Walker for Null {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            path.enter_interface(ASTNode::Null);
            visitor.enter_null(path, self)?;

            visitor.exit_null(path, self)?;
            path.exit_interface(ASTNode::Null);
            Ok(())
        }
    }



    #[derive(Clone, Copy, Debug, PartialEq, Eq)]
     pub enum ASTNode {
        ArrayAssignmentTarget,
        ArrayBinding,
        ArrayExpression,
        ArrowExpression,
        AssertedBlockScope,
        AssertedParameterScope,
        AssertedVarScope,
        AssignmentExpression,
        AssignmentTargetIdentifier,
        AssignmentTargetPropertyIdentifier,
        AssignmentTargetPropertyProperty,
        AssignmentTargetWithInitializer,
        AwaitExpression,
        BinaryExpression,
        BindingIdentifier,
        BindingPropertyIdentifier,
        BindingPropertyProperty,
        BindingWithInitializer,
        Block,
        BreakStatement,
        CallExpression,
        CatchClause,
        ClassDeclaration,
        ClassElement,
        ClassExpression,
        CompoundAssignmentExpression,
        ComputedMemberAssignmentTarget,
        ComputedMemberExpression,
        ComputedPropertyName,
        ConditionalExpression,
        ContinueStatement,
        DataProperty,
        DebuggerStatement,
        Directive,
        DoWhileStatement,
        EmptyStatement,
        Export,
        ExportAllFrom,
        ExportDefault,
        ExportFrom,
        ExportFromSpecifier,
        ExportLocalSpecifier,
        ExportLocals,
        ExpressionStatement,
        ForInOfBinding,
        ForInStatement,
        ForOfStatement,
        ForStatement,
        FormalParameters,
        FunctionBody,
        FunctionDeclaration,
        FunctionExpression,
        Getter,
        IdentifierExpression,
        IfStatement,
        Import,
        ImportNamespace,
        ImportSpecifier,
        LabelledStatement,
        LiteralBooleanExpression,
        LiteralInfinityExpression,
        LiteralNullExpression,
        LiteralNumericExpression,
        LiteralPropertyName,
        LiteralRegExpExpression,
        LiteralStringExpression,
        Method,
        Module,
        NewExpression,
        NewTargetExpression,
        ObjectAssignmentTarget,
        ObjectBinding,
        ObjectExpression,
        ReturnStatement,
        Script,
        Setter,
        ShorthandProperty,
        SpreadElement,
        StaticMemberAssignmentTarget,
        StaticMemberExpression,
        Super,
        SwitchCase,
        SwitchDefault,
        SwitchStatement,
        SwitchStatementWithDefault,
        TemplateElement,
        TemplateExpression,
        ThisExpression,
        ThrowStatement,
        TryCatchStatement,
        TryFinallyStatement,
        UnaryExpression,
        UpdateExpression,
        VariableDeclaration,
        VariableDeclarator,
        WhileStatement,
        WithStatement,
        YieldExpression,
        YieldStarExpression,
        Null
    }



    pub trait Visitor<E> {

        fn enter_array_assignment_target(&mut self, _path: &ASTPath, _node: &mut ArrayAssignmentTarget) -> Result<(), E> {
            Ok(())
        }
        fn exit_array_assignment_target(&mut self, _path: &ASTPath, _node: &mut ArrayAssignmentTarget) -> Result<(), E> {
            Ok(())
        }


        fn enter_array_binding(&mut self, _path: &ASTPath, _node: &mut ArrayBinding) -> Result<(), E> {
            Ok(())
        }
        fn exit_array_binding(&mut self, _path: &ASTPath, _node: &mut ArrayBinding) -> Result<(), E> {
            Ok(())
        }


        fn enter_array_expression(&mut self, _path: &ASTPath, _node: &mut ArrayExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_array_expression(&mut self, _path: &ASTPath, _node: &mut ArrayExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_arrow_expression(&mut self, _path: &ASTPath, _node: &mut ArrowExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_arrow_expression(&mut self, _path: &ASTPath, _node: &mut ArrowExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_asserted_block_scope(&mut self, _path: &ASTPath, _node: &mut AssertedBlockScope) -> Result<(), E> {
            Ok(())
        }
        fn exit_asserted_block_scope(&mut self, _path: &ASTPath, _node: &mut AssertedBlockScope) -> Result<(), E> {
            Ok(())
        }


        fn enter_asserted_parameter_scope(&mut self, _path: &ASTPath, _node: &mut AssertedParameterScope) -> Result<(), E> {
            Ok(())
        }
        fn exit_asserted_parameter_scope(&mut self, _path: &ASTPath, _node: &mut AssertedParameterScope) -> Result<(), E> {
            Ok(())
        }


        fn enter_asserted_var_scope(&mut self, _path: &ASTPath, _node: &mut AssertedVarScope) -> Result<(), E> {
            Ok(())
        }
        fn exit_asserted_var_scope(&mut self, _path: &ASTPath, _node: &mut AssertedVarScope) -> Result<(), E> {
            Ok(())
        }


        fn enter_assignment_expression(&mut self, _path: &ASTPath, _node: &mut AssignmentExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_assignment_expression(&mut self, _path: &ASTPath, _node: &mut AssignmentExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_assignment_target_identifier(&mut self, _path: &ASTPath, _node: &mut AssignmentTargetIdentifier) -> Result<(), E> {
            Ok(())
        }
        fn exit_assignment_target_identifier(&mut self, _path: &ASTPath, _node: &mut AssignmentTargetIdentifier) -> Result<(), E> {
            Ok(())
        }


        fn enter_assignment_target_property_identifier(&mut self, _path: &ASTPath, _node: &mut AssignmentTargetPropertyIdentifier) -> Result<(), E> {
            Ok(())
        }
        fn exit_assignment_target_property_identifier(&mut self, _path: &ASTPath, _node: &mut AssignmentTargetPropertyIdentifier) -> Result<(), E> {
            Ok(())
        }


        fn enter_assignment_target_property_property(&mut self, _path: &ASTPath, _node: &mut AssignmentTargetPropertyProperty) -> Result<(), E> {
            Ok(())
        }
        fn exit_assignment_target_property_property(&mut self, _path: &ASTPath, _node: &mut AssignmentTargetPropertyProperty) -> Result<(), E> {
            Ok(())
        }


        fn enter_assignment_target_with_initializer(&mut self, _path: &ASTPath, _node: &mut AssignmentTargetWithInitializer) -> Result<(), E> {
            Ok(())
        }
        fn exit_assignment_target_with_initializer(&mut self, _path: &ASTPath, _node: &mut AssignmentTargetWithInitializer) -> Result<(), E> {
            Ok(())
        }


        fn enter_await_expression(&mut self, _path: &ASTPath, _node: &mut AwaitExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_await_expression(&mut self, _path: &ASTPath, _node: &mut AwaitExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_binary_expression(&mut self, _path: &ASTPath, _node: &mut BinaryExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_binary_expression(&mut self, _path: &ASTPath, _node: &mut BinaryExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_binding_identifier(&mut self, _path: &ASTPath, _node: &mut BindingIdentifier) -> Result<(), E> {
            Ok(())
        }
        fn exit_binding_identifier(&mut self, _path: &ASTPath, _node: &mut BindingIdentifier) -> Result<(), E> {
            Ok(())
        }


        fn enter_binding_property_identifier(&mut self, _path: &ASTPath, _node: &mut BindingPropertyIdentifier) -> Result<(), E> {
            Ok(())
        }
        fn exit_binding_property_identifier(&mut self, _path: &ASTPath, _node: &mut BindingPropertyIdentifier) -> Result<(), E> {
            Ok(())
        }


        fn enter_binding_property_property(&mut self, _path: &ASTPath, _node: &mut BindingPropertyProperty) -> Result<(), E> {
            Ok(())
        }
        fn exit_binding_property_property(&mut self, _path: &ASTPath, _node: &mut BindingPropertyProperty) -> Result<(), E> {
            Ok(())
        }


        fn enter_binding_with_initializer(&mut self, _path: &ASTPath, _node: &mut BindingWithInitializer) -> Result<(), E> {
            Ok(())
        }
        fn exit_binding_with_initializer(&mut self, _path: &ASTPath, _node: &mut BindingWithInitializer) -> Result<(), E> {
            Ok(())
        }


        fn enter_block(&mut self, _path: &ASTPath, _node: &mut Block) -> Result<(), E> {
            Ok(())
        }
        fn exit_block(&mut self, _path: &ASTPath, _node: &mut Block) -> Result<(), E> {
            Ok(())
        }


        fn enter_break_statement(&mut self, _path: &ASTPath, _node: &mut BreakStatement) -> Result<(), E> {
            Ok(())
        }
        fn exit_break_statement(&mut self, _path: &ASTPath, _node: &mut BreakStatement) -> Result<(), E> {
            Ok(())
        }


        fn enter_call_expression(&mut self, _path: &ASTPath, _node: &mut CallExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_call_expression(&mut self, _path: &ASTPath, _node: &mut CallExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_catch_clause(&mut self, _path: &ASTPath, _node: &mut CatchClause) -> Result<(), E> {
            Ok(())
        }
        fn exit_catch_clause(&mut self, _path: &ASTPath, _node: &mut CatchClause) -> Result<(), E> {
            Ok(())
        }


        fn enter_class_declaration(&mut self, _path: &ASTPath, _node: &mut ClassDeclaration) -> Result<(), E> {
            Ok(())
        }
        fn exit_class_declaration(&mut self, _path: &ASTPath, _node: &mut ClassDeclaration) -> Result<(), E> {
            Ok(())
        }


        fn enter_class_element(&mut self, _path: &ASTPath, _node: &mut ClassElement) -> Result<(), E> {
            Ok(())
        }
        fn exit_class_element(&mut self, _path: &ASTPath, _node: &mut ClassElement) -> Result<(), E> {
            Ok(())
        }


        fn enter_class_expression(&mut self, _path: &ASTPath, _node: &mut ClassExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_class_expression(&mut self, _path: &ASTPath, _node: &mut ClassExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_compound_assignment_expression(&mut self, _path: &ASTPath, _node: &mut CompoundAssignmentExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_compound_assignment_expression(&mut self, _path: &ASTPath, _node: &mut CompoundAssignmentExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_computed_member_assignment_target(&mut self, _path: &ASTPath, _node: &mut ComputedMemberAssignmentTarget) -> Result<(), E> {
            Ok(())
        }
        fn exit_computed_member_assignment_target(&mut self, _path: &ASTPath, _node: &mut ComputedMemberAssignmentTarget) -> Result<(), E> {
            Ok(())
        }


        fn enter_computed_member_expression(&mut self, _path: &ASTPath, _node: &mut ComputedMemberExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_computed_member_expression(&mut self, _path: &ASTPath, _node: &mut ComputedMemberExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_computed_property_name(&mut self, _path: &ASTPath, _node: &mut ComputedPropertyName) -> Result<(), E> {
            Ok(())
        }
        fn exit_computed_property_name(&mut self, _path: &ASTPath, _node: &mut ComputedPropertyName) -> Result<(), E> {
            Ok(())
        }


        fn enter_conditional_expression(&mut self, _path: &ASTPath, _node: &mut ConditionalExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_conditional_expression(&mut self, _path: &ASTPath, _node: &mut ConditionalExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_continue_statement(&mut self, _path: &ASTPath, _node: &mut ContinueStatement) -> Result<(), E> {
            Ok(())
        }
        fn exit_continue_statement(&mut self, _path: &ASTPath, _node: &mut ContinueStatement) -> Result<(), E> {
            Ok(())
        }


        fn enter_data_property(&mut self, _path: &ASTPath, _node: &mut DataProperty) -> Result<(), E> {
            Ok(())
        }
        fn exit_data_property(&mut self, _path: &ASTPath, _node: &mut DataProperty) -> Result<(), E> {
            Ok(())
        }


        fn enter_debugger_statement(&mut self, _path: &ASTPath, _node: &mut DebuggerStatement) -> Result<(), E> {
            Ok(())
        }
        fn exit_debugger_statement(&mut self, _path: &ASTPath, _node: &mut DebuggerStatement) -> Result<(), E> {
            Ok(())
        }


        fn enter_directive(&mut self, _path: &ASTPath, _node: &mut Directive) -> Result<(), E> {
            Ok(())
        }
        fn exit_directive(&mut self, _path: &ASTPath, _node: &mut Directive) -> Result<(), E> {
            Ok(())
        }


        fn enter_do_while_statement(&mut self, _path: &ASTPath, _node: &mut DoWhileStatement) -> Result<(), E> {
            Ok(())
        }
        fn exit_do_while_statement(&mut self, _path: &ASTPath, _node: &mut DoWhileStatement) -> Result<(), E> {
            Ok(())
        }


        fn enter_empty_statement(&mut self, _path: &ASTPath, _node: &mut EmptyStatement) -> Result<(), E> {
            Ok(())
        }
        fn exit_empty_statement(&mut self, _path: &ASTPath, _node: &mut EmptyStatement) -> Result<(), E> {
            Ok(())
        }


        fn enter_export(&mut self, _path: &ASTPath, _node: &mut Export) -> Result<(), E> {
            Ok(())
        }
        fn exit_export(&mut self, _path: &ASTPath, _node: &mut Export) -> Result<(), E> {
            Ok(())
        }


        fn enter_export_all_from(&mut self, _path: &ASTPath, _node: &mut ExportAllFrom) -> Result<(), E> {
            Ok(())
        }
        fn exit_export_all_from(&mut self, _path: &ASTPath, _node: &mut ExportAllFrom) -> Result<(), E> {
            Ok(())
        }


        fn enter_export_default(&mut self, _path: &ASTPath, _node: &mut ExportDefault) -> Result<(), E> {
            Ok(())
        }
        fn exit_export_default(&mut self, _path: &ASTPath, _node: &mut ExportDefault) -> Result<(), E> {
            Ok(())
        }


        fn enter_export_from(&mut self, _path: &ASTPath, _node: &mut ExportFrom) -> Result<(), E> {
            Ok(())
        }
        fn exit_export_from(&mut self, _path: &ASTPath, _node: &mut ExportFrom) -> Result<(), E> {
            Ok(())
        }


        fn enter_export_from_specifier(&mut self, _path: &ASTPath, _node: &mut ExportFromSpecifier) -> Result<(), E> {
            Ok(())
        }
        fn exit_export_from_specifier(&mut self, _path: &ASTPath, _node: &mut ExportFromSpecifier) -> Result<(), E> {
            Ok(())
        }


        fn enter_export_local_specifier(&mut self, _path: &ASTPath, _node: &mut ExportLocalSpecifier) -> Result<(), E> {
            Ok(())
        }
        fn exit_export_local_specifier(&mut self, _path: &ASTPath, _node: &mut ExportLocalSpecifier) -> Result<(), E> {
            Ok(())
        }


        fn enter_export_locals(&mut self, _path: &ASTPath, _node: &mut ExportLocals) -> Result<(), E> {
            Ok(())
        }
        fn exit_export_locals(&mut self, _path: &ASTPath, _node: &mut ExportLocals) -> Result<(), E> {
            Ok(())
        }


        fn enter_expression_statement(&mut self, _path: &ASTPath, _node: &mut ExpressionStatement) -> Result<(), E> {
            Ok(())
        }
        fn exit_expression_statement(&mut self, _path: &ASTPath, _node: &mut ExpressionStatement) -> Result<(), E> {
            Ok(())
        }


        fn enter_for_in_of_binding(&mut self, _path: &ASTPath, _node: &mut ForInOfBinding) -> Result<(), E> {
            Ok(())
        }
        fn exit_for_in_of_binding(&mut self, _path: &ASTPath, _node: &mut ForInOfBinding) -> Result<(), E> {
            Ok(())
        }


        fn enter_for_in_statement(&mut self, _path: &ASTPath, _node: &mut ForInStatement) -> Result<(), E> {
            Ok(())
        }
        fn exit_for_in_statement(&mut self, _path: &ASTPath, _node: &mut ForInStatement) -> Result<(), E> {
            Ok(())
        }


        fn enter_for_of_statement(&mut self, _path: &ASTPath, _node: &mut ForOfStatement) -> Result<(), E> {
            Ok(())
        }
        fn exit_for_of_statement(&mut self, _path: &ASTPath, _node: &mut ForOfStatement) -> Result<(), E> {
            Ok(())
        }


        fn enter_for_statement(&mut self, _path: &ASTPath, _node: &mut ForStatement) -> Result<(), E> {
            Ok(())
        }
        fn exit_for_statement(&mut self, _path: &ASTPath, _node: &mut ForStatement) -> Result<(), E> {
            Ok(())
        }


        fn enter_formal_parameters(&mut self, _path: &ASTPath, _node: &mut FormalParameters) -> Result<(), E> {
            Ok(())
        }
        fn exit_formal_parameters(&mut self, _path: &ASTPath, _node: &mut FormalParameters) -> Result<(), E> {
            Ok(())
        }


        fn enter_function_body(&mut self, _path: &ASTPath, _node: &mut FunctionBody) -> Result<(), E> {
            Ok(())
        }
        fn exit_function_body(&mut self, _path: &ASTPath, _node: &mut FunctionBody) -> Result<(), E> {
            Ok(())
        }


        fn enter_function_declaration(&mut self, _path: &ASTPath, _node: &mut FunctionDeclaration) -> Result<(), E> {
            Ok(())
        }
        fn exit_function_declaration(&mut self, _path: &ASTPath, _node: &mut FunctionDeclaration) -> Result<(), E> {
            Ok(())
        }


        fn enter_function_expression(&mut self, _path: &ASTPath, _node: &mut FunctionExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_function_expression(&mut self, _path: &ASTPath, _node: &mut FunctionExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_getter(&mut self, _path: &ASTPath, _node: &mut Getter) -> Result<(), E> {
            Ok(())
        }
        fn exit_getter(&mut self, _path: &ASTPath, _node: &mut Getter) -> Result<(), E> {
            Ok(())
        }


        fn enter_identifier_expression(&mut self, _path: &ASTPath, _node: &mut IdentifierExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_identifier_expression(&mut self, _path: &ASTPath, _node: &mut IdentifierExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_if_statement(&mut self, _path: &ASTPath, _node: &mut IfStatement) -> Result<(), E> {
            Ok(())
        }
        fn exit_if_statement(&mut self, _path: &ASTPath, _node: &mut IfStatement) -> Result<(), E> {
            Ok(())
        }


        fn enter_import(&mut self, _path: &ASTPath, _node: &mut Import) -> Result<(), E> {
            Ok(())
        }
        fn exit_import(&mut self, _path: &ASTPath, _node: &mut Import) -> Result<(), E> {
            Ok(())
        }


        fn enter_import_namespace(&mut self, _path: &ASTPath, _node: &mut ImportNamespace) -> Result<(), E> {
            Ok(())
        }
        fn exit_import_namespace(&mut self, _path: &ASTPath, _node: &mut ImportNamespace) -> Result<(), E> {
            Ok(())
        }


        fn enter_import_specifier(&mut self, _path: &ASTPath, _node: &mut ImportSpecifier) -> Result<(), E> {
            Ok(())
        }
        fn exit_import_specifier(&mut self, _path: &ASTPath, _node: &mut ImportSpecifier) -> Result<(), E> {
            Ok(())
        }


        fn enter_labelled_statement(&mut self, _path: &ASTPath, _node: &mut LabelledStatement) -> Result<(), E> {
            Ok(())
        }
        fn exit_labelled_statement(&mut self, _path: &ASTPath, _node: &mut LabelledStatement) -> Result<(), E> {
            Ok(())
        }


        fn enter_literal_boolean_expression(&mut self, _path: &ASTPath, _node: &mut LiteralBooleanExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_literal_boolean_expression(&mut self, _path: &ASTPath, _node: &mut LiteralBooleanExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_literal_infinity_expression(&mut self, _path: &ASTPath, _node: &mut LiteralInfinityExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_literal_infinity_expression(&mut self, _path: &ASTPath, _node: &mut LiteralInfinityExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_literal_null_expression(&mut self, _path: &ASTPath, _node: &mut LiteralNullExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_literal_null_expression(&mut self, _path: &ASTPath, _node: &mut LiteralNullExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_literal_numeric_expression(&mut self, _path: &ASTPath, _node: &mut LiteralNumericExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_literal_numeric_expression(&mut self, _path: &ASTPath, _node: &mut LiteralNumericExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_literal_property_name(&mut self, _path: &ASTPath, _node: &mut LiteralPropertyName) -> Result<(), E> {
            Ok(())
        }
        fn exit_literal_property_name(&mut self, _path: &ASTPath, _node: &mut LiteralPropertyName) -> Result<(), E> {
            Ok(())
        }


        fn enter_literal_reg_exp_expression(&mut self, _path: &ASTPath, _node: &mut LiteralRegExpExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_literal_reg_exp_expression(&mut self, _path: &ASTPath, _node: &mut LiteralRegExpExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_literal_string_expression(&mut self, _path: &ASTPath, _node: &mut LiteralStringExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_literal_string_expression(&mut self, _path: &ASTPath, _node: &mut LiteralStringExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_method(&mut self, _path: &ASTPath, _node: &mut Method) -> Result<(), E> {
            Ok(())
        }
        fn exit_method(&mut self, _path: &ASTPath, _node: &mut Method) -> Result<(), E> {
            Ok(())
        }


        fn enter_module(&mut self, _path: &ASTPath, _node: &mut Module) -> Result<(), E> {
            Ok(())
        }
        fn exit_module(&mut self, _path: &ASTPath, _node: &mut Module) -> Result<(), E> {
            Ok(())
        }


        fn enter_new_expression(&mut self, _path: &ASTPath, _node: &mut NewExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_new_expression(&mut self, _path: &ASTPath, _node: &mut NewExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_new_target_expression(&mut self, _path: &ASTPath, _node: &mut NewTargetExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_new_target_expression(&mut self, _path: &ASTPath, _node: &mut NewTargetExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_object_assignment_target(&mut self, _path: &ASTPath, _node: &mut ObjectAssignmentTarget) -> Result<(), E> {
            Ok(())
        }
        fn exit_object_assignment_target(&mut self, _path: &ASTPath, _node: &mut ObjectAssignmentTarget) -> Result<(), E> {
            Ok(())
        }


        fn enter_object_binding(&mut self, _path: &ASTPath, _node: &mut ObjectBinding) -> Result<(), E> {
            Ok(())
        }
        fn exit_object_binding(&mut self, _path: &ASTPath, _node: &mut ObjectBinding) -> Result<(), E> {
            Ok(())
        }


        fn enter_object_expression(&mut self, _path: &ASTPath, _node: &mut ObjectExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_object_expression(&mut self, _path: &ASTPath, _node: &mut ObjectExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_return_statement(&mut self, _path: &ASTPath, _node: &mut ReturnStatement) -> Result<(), E> {
            Ok(())
        }
        fn exit_return_statement(&mut self, _path: &ASTPath, _node: &mut ReturnStatement) -> Result<(), E> {
            Ok(())
        }


        fn enter_script(&mut self, _path: &ASTPath, _node: &mut Script) -> Result<(), E> {
            Ok(())
        }
        fn exit_script(&mut self, _path: &ASTPath, _node: &mut Script) -> Result<(), E> {
            Ok(())
        }


        fn enter_setter(&mut self, _path: &ASTPath, _node: &mut Setter) -> Result<(), E> {
            Ok(())
        }
        fn exit_setter(&mut self, _path: &ASTPath, _node: &mut Setter) -> Result<(), E> {
            Ok(())
        }


        fn enter_shorthand_property(&mut self, _path: &ASTPath, _node: &mut ShorthandProperty) -> Result<(), E> {
            Ok(())
        }
        fn exit_shorthand_property(&mut self, _path: &ASTPath, _node: &mut ShorthandProperty) -> Result<(), E> {
            Ok(())
        }


        fn enter_spread_element(&mut self, _path: &ASTPath, _node: &mut SpreadElement) -> Result<(), E> {
            Ok(())
        }
        fn exit_spread_element(&mut self, _path: &ASTPath, _node: &mut SpreadElement) -> Result<(), E> {
            Ok(())
        }


        fn enter_static_member_assignment_target(&mut self, _path: &ASTPath, _node: &mut StaticMemberAssignmentTarget) -> Result<(), E> {
            Ok(())
        }
        fn exit_static_member_assignment_target(&mut self, _path: &ASTPath, _node: &mut StaticMemberAssignmentTarget) -> Result<(), E> {
            Ok(())
        }


        fn enter_static_member_expression(&mut self, _path: &ASTPath, _node: &mut StaticMemberExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_static_member_expression(&mut self, _path: &ASTPath, _node: &mut StaticMemberExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_super_(&mut self, _path: &ASTPath, _node: &mut Super) -> Result<(), E> {
            Ok(())
        }
        fn exit_super_(&mut self, _path: &ASTPath, _node: &mut Super) -> Result<(), E> {
            Ok(())
        }


        fn enter_switch_case(&mut self, _path: &ASTPath, _node: &mut SwitchCase) -> Result<(), E> {
            Ok(())
        }
        fn exit_switch_case(&mut self, _path: &ASTPath, _node: &mut SwitchCase) -> Result<(), E> {
            Ok(())
        }


        fn enter_switch_default(&mut self, _path: &ASTPath, _node: &mut SwitchDefault) -> Result<(), E> {
            Ok(())
        }
        fn exit_switch_default(&mut self, _path: &ASTPath, _node: &mut SwitchDefault) -> Result<(), E> {
            Ok(())
        }


        fn enter_switch_statement(&mut self, _path: &ASTPath, _node: &mut SwitchStatement) -> Result<(), E> {
            Ok(())
        }
        fn exit_switch_statement(&mut self, _path: &ASTPath, _node: &mut SwitchStatement) -> Result<(), E> {
            Ok(())
        }


        fn enter_switch_statement_with_default(&mut self, _path: &ASTPath, _node: &mut SwitchStatementWithDefault) -> Result<(), E> {
            Ok(())
        }
        fn exit_switch_statement_with_default(&mut self, _path: &ASTPath, _node: &mut SwitchStatementWithDefault) -> Result<(), E> {
            Ok(())
        }


        fn enter_template_element(&mut self, _path: &ASTPath, _node: &mut TemplateElement) -> Result<(), E> {
            Ok(())
        }
        fn exit_template_element(&mut self, _path: &ASTPath, _node: &mut TemplateElement) -> Result<(), E> {
            Ok(())
        }


        fn enter_template_expression(&mut self, _path: &ASTPath, _node: &mut TemplateExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_template_expression(&mut self, _path: &ASTPath, _node: &mut TemplateExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_this_expression(&mut self, _path: &ASTPath, _node: &mut ThisExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_this_expression(&mut self, _path: &ASTPath, _node: &mut ThisExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_throw_statement(&mut self, _path: &ASTPath, _node: &mut ThrowStatement) -> Result<(), E> {
            Ok(())
        }
        fn exit_throw_statement(&mut self, _path: &ASTPath, _node: &mut ThrowStatement) -> Result<(), E> {
            Ok(())
        }


        fn enter_try_catch_statement(&mut self, _path: &ASTPath, _node: &mut TryCatchStatement) -> Result<(), E> {
            Ok(())
        }
        fn exit_try_catch_statement(&mut self, _path: &ASTPath, _node: &mut TryCatchStatement) -> Result<(), E> {
            Ok(())
        }


        fn enter_try_finally_statement(&mut self, _path: &ASTPath, _node: &mut TryFinallyStatement) -> Result<(), E> {
            Ok(())
        }
        fn exit_try_finally_statement(&mut self, _path: &ASTPath, _node: &mut TryFinallyStatement) -> Result<(), E> {
            Ok(())
        }


        fn enter_unary_expression(&mut self, _path: &ASTPath, _node: &mut UnaryExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_unary_expression(&mut self, _path: &ASTPath, _node: &mut UnaryExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_update_expression(&mut self, _path: &ASTPath, _node: &mut UpdateExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_update_expression(&mut self, _path: &ASTPath, _node: &mut UpdateExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_variable_declaration(&mut self, _path: &ASTPath, _node: &mut VariableDeclaration) -> Result<(), E> {
            Ok(())
        }
        fn exit_variable_declaration(&mut self, _path: &ASTPath, _node: &mut VariableDeclaration) -> Result<(), E> {
            Ok(())
        }


        fn enter_variable_declarator(&mut self, _path: &ASTPath, _node: &mut VariableDeclarator) -> Result<(), E> {
            Ok(())
        }
        fn exit_variable_declarator(&mut self, _path: &ASTPath, _node: &mut VariableDeclarator) -> Result<(), E> {
            Ok(())
        }


        fn enter_while_statement(&mut self, _path: &ASTPath, _node: &mut WhileStatement) -> Result<(), E> {
            Ok(())
        }
        fn exit_while_statement(&mut self, _path: &ASTPath, _node: &mut WhileStatement) -> Result<(), E> {
            Ok(())
        }


        fn enter_with_statement(&mut self, _path: &ASTPath, _node: &mut WithStatement) -> Result<(), E> {
            Ok(())
        }
        fn exit_with_statement(&mut self, _path: &ASTPath, _node: &mut WithStatement) -> Result<(), E> {
            Ok(())
        }


        fn enter_yield_expression(&mut self, _path: &ASTPath, _node: &mut YieldExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_yield_expression(&mut self, _path: &ASTPath, _node: &mut YieldExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_yield_star_expression(&mut self, _path: &ASTPath, _node: &mut YieldStarExpression) -> Result<(), E> {
            Ok(())
        }
        fn exit_yield_star_expression(&mut self, _path: &ASTPath, _node: &mut YieldStarExpression) -> Result<(), E> {
            Ok(())
        }


        fn enter_null(&mut self, _path: &ASTPath, _node: &mut Null) -> Result<(), E> {
            Ok(())
        }
        fn exit_null(&mut self, _path: &ASTPath, _node: &mut Null) -> Result<(), E> {
            Ok(())
        }

    }

    pub trait Walker {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E>;
    }

    impl Walker for String {
        fn walk<V, E>(&mut self, _: &mut ASTPath, _: &mut V) -> Result<(), E> where V: Visitor<E> {
            Ok(())
        }
    }
    impl Walker for bool {
        fn walk<V, E>(&mut self, _: &mut ASTPath, _: &mut V) -> Result<(), E> where V: Visitor<E> {
            Ok(())
        }
    }
    impl Walker for f64 {
        fn walk<V, E>(&mut self, _: &mut ASTPath, _: &mut V) -> Result<(), E> where V: Visitor<E> {
            Ok(())
        }
    }
    impl<T> Walker for Option<T> where T: Walker {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            if let Some(ref mut contents) = *self {
                contents.walk(path, visitor)?;
            }
            Ok(())
        }        
    }
    impl<T> Walker for Vec<T> where T: Walker {
        fn walk<V, E>(&mut self, path: &mut ASTPath, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
            for iter in self.iter_mut() {
                iter.walk(path, visitor)?;
            }
            Ok(())
        }
    }
    



    #[derive(Debug)]
    pub struct ASTPathItem {
        pub interface: ASTNode,
        pub field: ASTField,
    }
    pub struct ASTPath {
        /// Some(foo) if we have entered interface foo but no field yet.
        /// Otherwise, None.
        interface: Option<ASTNode>,
        items: Vec<ASTPathItem>,
    }
    impl std::fmt::Debug for ASTPath {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {
            use itertools::Itertools;
            write!(f, "[{items}{more}]",
                items = self.items.iter()
                    .map(|item| format!("{:?}.{:?}", item.interface, item.field))
                    .format(" > "),
                more = if let Some(ref interface) = self.interface { format!(" > {:?}", interface) } else { "".to_string() }
            )
        }
    }
    impl ASTPath {
        pub fn new() -> Self {
            Self {
                interface: None,
                items: vec![],
            }
        }
        fn enter_interface(&mut self, node: ASTNode) {
            debug_assert!(self.interface.is_none());
            self.interface = Some(node);
        }
        fn exit_interface(&mut self, node: ASTNode) {
            let interface = self.interface.take()
                .expect("Could not exit_interface if we're not in an interface");
            debug_assert!(node == interface);
        }
        fn enter_field(&mut self, field: ASTField) {
            let interface = self.interface.take()
                .unwrap();
            self.items.push(ASTPathItem {
                interface,
                field,
            });
        }
        fn exit_field(&mut self, field: ASTField) {
            debug_assert!(self.interface.is_none());
            let ASTPathItem {
                interface,
                field: prev
            } = self.items.pop()
                .expect("Could not exit_field from an empty ASTath");
            debug_assert!(prev == field);
            self.interface = Some(interface);
        }
        pub fn len(&self) -> usize {
            self.items.len()
        }

        pub fn get(&self, index: usize) -> Option<&ASTPathItem> {
            if index >= self.len() {
                return None;
            }
            Some(&self.items[self.len() - index - 1])
        }
    }



     // Field names (by lexicographical order)
     #[derive(Clone, Copy, PartialEq, Eq, Debug)]
    pub enum ASTField {
        Alternate,
        Arguments,
        Binding,
        Body,
        BodyScope,
        Callee,
        CapturedNames,
        Cases,
        CatchClause,
        Consequent,
        Declaration,
        Declarators,
        DefaultBinding,
        DefaultCase,
        Directives,
        Discriminant,
        Elements,
        ExportedName,
        Expression,
        Finalizer,
        Flags,
        HasDirectEval,
        Init,
        IsAsync,
        IsGenerator,
        IsPrefix,
        IsStatic,
        Items,
        Kind,
        Label,
        Left,
        LexicallyDeclaredNames,
        Method,
        ModuleSpecifier,
        Name,
        NamedExports,
        NamedImports,
        NamespaceBinding,
        Object,
        Operand,
        Operator,
        Param,
        ParameterNames,
        ParameterScope,
        Params,
        Pattern,
        PostDefaultCases,
        PreDefaultCases,
        Properties,
        Property,
        RawValue,
        Rest,
        Right,
        Scope,
        Statements,
        Super,
        Tag,
        Test,
        Update,
        Value,
        VarDeclaredNames,
    }
}

pub struct Library {
    // String enum names (by lexicographical order)
    pub binary_operator: NodeName,
    pub compound_assignment_operator: NodeName,
    pub unary_operator: NodeName,
    pub update_operator: NodeName,
    pub variable_declaration_kind: NodeName,


    // Typedef names (by lexicographical order)
    pub arguments: NodeName,
    pub assignment_target: NodeName,
    pub assignment_target_pattern: NodeName,
    pub assignment_target_property: NodeName,
    pub binding: NodeName,
    pub binding_pattern: NodeName,
    pub binding_property: NodeName,
    pub export_declaration: NodeName,
    pub expression: NodeName,
    pub identifier: NodeName,
    pub identifier_name: NodeName,
    pub import_declaration: NodeName,
    pub iteration_statement: NodeName,
    pub label: NodeName,
    pub literal: NodeName,
    pub method_definition: NodeName,
    pub object_property: NodeName,
    pub parameter: NodeName,
    pub program: NodeName,
    pub property_name: NodeName,
    pub simple_assignment_target: NodeName,
    pub statement: NodeName,
    pub string: NodeName,


    // Interface names (by lexicographical order)
    pub array_assignment_target: NodeName,
    pub array_binding: NodeName,
    pub array_expression: NodeName,
    pub arrow_expression: NodeName,
    pub asserted_block_scope: NodeName,
    pub asserted_parameter_scope: NodeName,
    pub asserted_var_scope: NodeName,
    pub assignment_expression: NodeName,
    pub assignment_target_identifier: NodeName,
    pub assignment_target_property_identifier: NodeName,
    pub assignment_target_property_property: NodeName,
    pub assignment_target_with_initializer: NodeName,
    pub await_expression: NodeName,
    pub binary_expression: NodeName,
    pub binding_identifier: NodeName,
    pub binding_property_identifier: NodeName,
    pub binding_property_property: NodeName,
    pub binding_with_initializer: NodeName,
    pub block: NodeName,
    pub break_statement: NodeName,
    pub call_expression: NodeName,
    pub catch_clause: NodeName,
    pub class_declaration: NodeName,
    pub class_element: NodeName,
    pub class_expression: NodeName,
    pub compound_assignment_expression: NodeName,
    pub computed_member_assignment_target: NodeName,
    pub computed_member_expression: NodeName,
    pub computed_property_name: NodeName,
    pub conditional_expression: NodeName,
    pub continue_statement: NodeName,
    pub data_property: NodeName,
    pub debugger_statement: NodeName,
    pub directive: NodeName,
    pub do_while_statement: NodeName,
    pub empty_statement: NodeName,
    pub export: NodeName,
    pub export_all_from: NodeName,
    pub export_default: NodeName,
    pub export_from: NodeName,
    pub export_from_specifier: NodeName,
    pub export_local_specifier: NodeName,
    pub export_locals: NodeName,
    pub expression_statement: NodeName,
    pub for_in_of_binding: NodeName,
    pub for_in_statement: NodeName,
    pub for_of_statement: NodeName,
    pub for_statement: NodeName,
    pub formal_parameters: NodeName,
    pub function_body: NodeName,
    pub function_declaration: NodeName,
    pub function_expression: NodeName,
    pub getter: NodeName,
    pub identifier_expression: NodeName,
    pub if_statement: NodeName,
    pub import: NodeName,
    pub import_namespace: NodeName,
    pub import_specifier: NodeName,
    pub labelled_statement: NodeName,
    pub literal_boolean_expression: NodeName,
    pub literal_infinity_expression: NodeName,
    pub literal_null_expression: NodeName,
    pub literal_numeric_expression: NodeName,
    pub literal_property_name: NodeName,
    pub literal_reg_exp_expression: NodeName,
    pub literal_string_expression: NodeName,
    pub method: NodeName,
    pub module: NodeName,
    pub new_expression: NodeName,
    pub new_target_expression: NodeName,
    pub object_assignment_target: NodeName,
    pub object_binding: NodeName,
    pub object_expression: NodeName,
    pub return_statement: NodeName,
    pub script: NodeName,
    pub setter: NodeName,
    pub shorthand_property: NodeName,
    pub spread_element: NodeName,
    pub static_member_assignment_target: NodeName,
    pub static_member_expression: NodeName,
    pub super_: NodeName,
    pub switch_case: NodeName,
    pub switch_default: NodeName,
    pub switch_statement: NodeName,
    pub switch_statement_with_default: NodeName,
    pub template_element: NodeName,
    pub template_expression: NodeName,
    pub this_expression: NodeName,
    pub throw_statement: NodeName,
    pub try_catch_statement: NodeName,
    pub try_finally_statement: NodeName,
    pub unary_expression: NodeName,
    pub update_expression: NodeName,
    pub variable_declaration: NodeName,
    pub variable_declarator: NodeName,
    pub while_statement: NodeName,
    pub with_statement: NodeName,
    pub yield_expression: NodeName,
    pub yield_star_expression: NodeName,
    pub null: NodeName,



    // Field names (by lexicographical order)
    pub field_alternate: FieldName,
    pub field_arguments: FieldName,
    pub field_binding: FieldName,
    pub field_body: FieldName,
    pub field_body_scope: FieldName,
    pub field_callee: FieldName,
    pub field_captured_names: FieldName,
    pub field_cases: FieldName,
    pub field_catch_clause: FieldName,
    pub field_consequent: FieldName,
    pub field_declaration: FieldName,
    pub field_declarators: FieldName,
    pub field_default_binding: FieldName,
    pub field_default_case: FieldName,
    pub field_directives: FieldName,
    pub field_discriminant: FieldName,
    pub field_elements: FieldName,
    pub field_exported_name: FieldName,
    pub field_expression: FieldName,
    pub field_finalizer: FieldName,
    pub field_flags: FieldName,
    pub field_has_direct_eval: FieldName,
    pub field_init: FieldName,
    pub field_is_async: FieldName,
    pub field_is_generator: FieldName,
    pub field_is_prefix: FieldName,
    pub field_is_static: FieldName,
    pub field_items: FieldName,
    pub field_kind: FieldName,
    pub field_label: FieldName,
    pub field_left: FieldName,
    pub field_lexically_declared_names: FieldName,
    pub field_method: FieldName,
    pub field_module_specifier: FieldName,
    pub field_name: FieldName,
    pub field_named_exports: FieldName,
    pub field_named_imports: FieldName,
    pub field_namespace_binding: FieldName,
    pub field_object: FieldName,
    pub field_operand: FieldName,
    pub field_operator: FieldName,
    pub field_param: FieldName,
    pub field_parameter_names: FieldName,
    pub field_parameter_scope: FieldName,
    pub field_params: FieldName,
    pub field_pattern: FieldName,
    pub field_post_default_cases: FieldName,
    pub field_pre_default_cases: FieldName,
    pub field_properties: FieldName,
    pub field_property: FieldName,
    pub field_raw_value: FieldName,
    pub field_rest: FieldName,
    pub field_right: FieldName,
    pub field_scope: FieldName,
    pub field_statements: FieldName,
    pub field_super_: FieldName,
    pub field_tag: FieldName,
    pub field_test: FieldName,
    pub field_update: FieldName,
    pub field_value: FieldName,
    pub field_var_declared_names: FieldName,
}
impl Library {
    pub fn new(builder: &mut SyntaxBuilder) -> Self {
        let names = Library {
            // String enum names (by lexicographical order)
            binary_operator: builder.node_name("BinaryOperator"),
            compound_assignment_operator: builder.node_name("CompoundAssignmentOperator"),
            unary_operator: builder.node_name("UnaryOperator"),
            update_operator: builder.node_name("UpdateOperator"),
            variable_declaration_kind: builder.node_name("VariableDeclarationKind"),


            // Typedef names (by lexicographical order)
            arguments: builder.node_name("Arguments"),
            assignment_target: builder.node_name("AssignmentTarget"),
            assignment_target_pattern: builder.node_name("AssignmentTargetPattern"),
            assignment_target_property: builder.node_name("AssignmentTargetProperty"),
            binding: builder.node_name("Binding"),
            binding_pattern: builder.node_name("BindingPattern"),
            binding_property: builder.node_name("BindingProperty"),
            export_declaration: builder.node_name("ExportDeclaration"),
            expression: builder.node_name("Expression"),
            identifier: builder.node_name("Identifier"),
            identifier_name: builder.node_name("IdentifierName"),
            import_declaration: builder.node_name("ImportDeclaration"),
            iteration_statement: builder.node_name("IterationStatement"),
            label: builder.node_name("Label"),
            literal: builder.node_name("Literal"),
            method_definition: builder.node_name("MethodDefinition"),
            object_property: builder.node_name("ObjectProperty"),
            parameter: builder.node_name("Parameter"),
            program: builder.node_name("Program"),
            property_name: builder.node_name("PropertyName"),
            simple_assignment_target: builder.node_name("SimpleAssignmentTarget"),
            statement: builder.node_name("Statement"),
            string: builder.node_name("string"),


            // Interface names (by lexicographical order)
            array_assignment_target: builder.node_name("ArrayAssignmentTarget"),
            array_binding: builder.node_name("ArrayBinding"),
            array_expression: builder.node_name("ArrayExpression"),
            arrow_expression: builder.node_name("ArrowExpression"),
            asserted_block_scope: builder.node_name("AssertedBlockScope"),
            asserted_parameter_scope: builder.node_name("AssertedParameterScope"),
            asserted_var_scope: builder.node_name("AssertedVarScope"),
            assignment_expression: builder.node_name("AssignmentExpression"),
            assignment_target_identifier: builder.node_name("AssignmentTargetIdentifier"),
            assignment_target_property_identifier: builder.node_name("AssignmentTargetPropertyIdentifier"),
            assignment_target_property_property: builder.node_name("AssignmentTargetPropertyProperty"),
            assignment_target_with_initializer: builder.node_name("AssignmentTargetWithInitializer"),
            await_expression: builder.node_name("AwaitExpression"),
            binary_expression: builder.node_name("BinaryExpression"),
            binding_identifier: builder.node_name("BindingIdentifier"),
            binding_property_identifier: builder.node_name("BindingPropertyIdentifier"),
            binding_property_property: builder.node_name("BindingPropertyProperty"),
            binding_with_initializer: builder.node_name("BindingWithInitializer"),
            block: builder.node_name("Block"),
            break_statement: builder.node_name("BreakStatement"),
            call_expression: builder.node_name("CallExpression"),
            catch_clause: builder.node_name("CatchClause"),
            class_declaration: builder.node_name("ClassDeclaration"),
            class_element: builder.node_name("ClassElement"),
            class_expression: builder.node_name("ClassExpression"),
            compound_assignment_expression: builder.node_name("CompoundAssignmentExpression"),
            computed_member_assignment_target: builder.node_name("ComputedMemberAssignmentTarget"),
            computed_member_expression: builder.node_name("ComputedMemberExpression"),
            computed_property_name: builder.node_name("ComputedPropertyName"),
            conditional_expression: builder.node_name("ConditionalExpression"),
            continue_statement: builder.node_name("ContinueStatement"),
            data_property: builder.node_name("DataProperty"),
            debugger_statement: builder.node_name("DebuggerStatement"),
            directive: builder.node_name("Directive"),
            do_while_statement: builder.node_name("DoWhileStatement"),
            empty_statement: builder.node_name("EmptyStatement"),
            export: builder.node_name("Export"),
            export_all_from: builder.node_name("ExportAllFrom"),
            export_default: builder.node_name("ExportDefault"),
            export_from: builder.node_name("ExportFrom"),
            export_from_specifier: builder.node_name("ExportFromSpecifier"),
            export_local_specifier: builder.node_name("ExportLocalSpecifier"),
            export_locals: builder.node_name("ExportLocals"),
            expression_statement: builder.node_name("ExpressionStatement"),
            for_in_of_binding: builder.node_name("ForInOfBinding"),
            for_in_statement: builder.node_name("ForInStatement"),
            for_of_statement: builder.node_name("ForOfStatement"),
            for_statement: builder.node_name("ForStatement"),
            formal_parameters: builder.node_name("FormalParameters"),
            function_body: builder.node_name("FunctionBody"),
            function_declaration: builder.node_name("FunctionDeclaration"),
            function_expression: builder.node_name("FunctionExpression"),
            getter: builder.node_name("Getter"),
            identifier_expression: builder.node_name("IdentifierExpression"),
            if_statement: builder.node_name("IfStatement"),
            import: builder.node_name("Import"),
            import_namespace: builder.node_name("ImportNamespace"),
            import_specifier: builder.node_name("ImportSpecifier"),
            labelled_statement: builder.node_name("LabelledStatement"),
            literal_boolean_expression: builder.node_name("LiteralBooleanExpression"),
            literal_infinity_expression: builder.node_name("LiteralInfinityExpression"),
            literal_null_expression: builder.node_name("LiteralNullExpression"),
            literal_numeric_expression: builder.node_name("LiteralNumericExpression"),
            literal_property_name: builder.node_name("LiteralPropertyName"),
            literal_reg_exp_expression: builder.node_name("LiteralRegExpExpression"),
            literal_string_expression: builder.node_name("LiteralStringExpression"),
            method: builder.node_name("Method"),
            module: builder.node_name("Module"),
            new_expression: builder.node_name("NewExpression"),
            new_target_expression: builder.node_name("NewTargetExpression"),
            object_assignment_target: builder.node_name("ObjectAssignmentTarget"),
            object_binding: builder.node_name("ObjectBinding"),
            object_expression: builder.node_name("ObjectExpression"),
            return_statement: builder.node_name("ReturnStatement"),
            script: builder.node_name("Script"),
            setter: builder.node_name("Setter"),
            shorthand_property: builder.node_name("ShorthandProperty"),
            spread_element: builder.node_name("SpreadElement"),
            static_member_assignment_target: builder.node_name("StaticMemberAssignmentTarget"),
            static_member_expression: builder.node_name("StaticMemberExpression"),
            super_: builder.node_name("Super"),
            switch_case: builder.node_name("SwitchCase"),
            switch_default: builder.node_name("SwitchDefault"),
            switch_statement: builder.node_name("SwitchStatement"),
            switch_statement_with_default: builder.node_name("SwitchStatementWithDefault"),
            template_element: builder.node_name("TemplateElement"),
            template_expression: builder.node_name("TemplateExpression"),
            this_expression: builder.node_name("ThisExpression"),
            throw_statement: builder.node_name("ThrowStatement"),
            try_catch_statement: builder.node_name("TryCatchStatement"),
            try_finally_statement: builder.node_name("TryFinallyStatement"),
            unary_expression: builder.node_name("UnaryExpression"),
            update_expression: builder.node_name("UpdateExpression"),
            variable_declaration: builder.node_name("VariableDeclaration"),
            variable_declarator: builder.node_name("VariableDeclarator"),
            while_statement: builder.node_name("WhileStatement"),
            with_statement: builder.node_name("WithStatement"),
            yield_expression: builder.node_name("YieldExpression"),
            yield_star_expression: builder.node_name("YieldStarExpression"),
            null: builder.node_name("_Null"),



            // Field names (by lexicographical order)
            field_alternate: builder.field_name("alternate"),
            field_arguments: builder.field_name("arguments"),
            field_binding: builder.field_name("binding"),
            field_body: builder.field_name("body"),
            field_body_scope: builder.field_name("bodyScope"),
            field_callee: builder.field_name("callee"),
            field_captured_names: builder.field_name("capturedNames"),
            field_cases: builder.field_name("cases"),
            field_catch_clause: builder.field_name("catchClause"),
            field_consequent: builder.field_name("consequent"),
            field_declaration: builder.field_name("declaration"),
            field_declarators: builder.field_name("declarators"),
            field_default_binding: builder.field_name("defaultBinding"),
            field_default_case: builder.field_name("defaultCase"),
            field_directives: builder.field_name("directives"),
            field_discriminant: builder.field_name("discriminant"),
            field_elements: builder.field_name("elements"),
            field_exported_name: builder.field_name("exportedName"),
            field_expression: builder.field_name("expression"),
            field_finalizer: builder.field_name("finalizer"),
            field_flags: builder.field_name("flags"),
            field_has_direct_eval: builder.field_name("hasDirectEval"),
            field_init: builder.field_name("init"),
            field_is_async: builder.field_name("isAsync"),
            field_is_generator: builder.field_name("isGenerator"),
            field_is_prefix: builder.field_name("isPrefix"),
            field_is_static: builder.field_name("isStatic"),
            field_items: builder.field_name("items"),
            field_kind: builder.field_name("kind"),
            field_label: builder.field_name("label"),
            field_left: builder.field_name("left"),
            field_lexically_declared_names: builder.field_name("lexicallyDeclaredNames"),
            field_method: builder.field_name("method"),
            field_module_specifier: builder.field_name("moduleSpecifier"),
            field_name: builder.field_name("name"),
            field_named_exports: builder.field_name("namedExports"),
            field_named_imports: builder.field_name("namedImports"),
            field_namespace_binding: builder.field_name("namespaceBinding"),
            field_object: builder.field_name("object"),
            field_operand: builder.field_name("operand"),
            field_operator: builder.field_name("operator"),
            field_param: builder.field_name("param"),
            field_parameter_names: builder.field_name("parameterNames"),
            field_parameter_scope: builder.field_name("parameterScope"),
            field_params: builder.field_name("params"),
            field_pattern: builder.field_name("pattern"),
            field_post_default_cases: builder.field_name("postDefaultCases"),
            field_pre_default_cases: builder.field_name("preDefaultCases"),
            field_properties: builder.field_name("properties"),
            field_property: builder.field_name("property"),
            field_raw_value: builder.field_name("rawValue"),
            field_rest: builder.field_name("rest"),
            field_right: builder.field_name("right"),
            field_scope: builder.field_name("scope"),
            field_statements: builder.field_name("statements"),
            field_super_: builder.field_name("super"),
            field_tag: builder.field_name("tag"),
            field_test: builder.field_name("test"),
            field_update: builder.field_name("update"),
            field_value: builder.field_name("value"),
            field_var_declared_names: builder.field_name("varDeclaredNames"),
        };



        // Enumerations
        builder.add_string_enum(&names.binary_operator).unwrap()
            .with_strings(&[
                ",",
                "||",
                "&&",
                "|",
                "^",
                "&",
                "==",
                "!=",
                "===",
                "!==",
                "<",
                "<=",
                ">",
                ">=",
                "in",
                "instanceof",
                "<<",
                ">>",
                ">>>",
                "+",
                "-",
                "*",
                "/",
                "%",
                "**"
           ]);

        builder.add_string_enum(&names.compound_assignment_operator).unwrap()
            .with_strings(&[
                "+=",
                "-=",
                "*=",
                "/=",
                "%=",
                "**=",
                "<<=",
                ">>=",
                ">>>=",
                "|=",
                "^=",
                "&="
           ]);

        builder.add_string_enum(&names.variable_declaration_kind).unwrap()
            .with_strings(&[
                "var",
                "let",
                "const"
           ]);

        builder.add_string_enum(&names.unary_operator).unwrap()
            .with_strings(&[
                "+",
                "-",
                "!",
                "~",
                "typeof",
                "void",
                "delete"
           ]);

        builder.add_string_enum(&names.update_operator).unwrap()
            .with_strings(&[
                "++",
                "--"
           ]);

        builder.add_typedef(&names.assignment_target_property).unwrap()
            .with_type(
                    Type::sum(&[
                        Type::named(&names.assignment_target_property_identifier),
                        Type::named(&names.assignment_target_property_property)
                    ]).required());

        builder.add_typedef(&names.iteration_statement).unwrap()
            .with_type(
                    Type::sum(&[
                        Type::named(&names.do_while_statement),
                        Type::named(&names.for_in_statement),
                        Type::named(&names.for_of_statement),
                        Type::named(&names.for_statement),
                        Type::named(&names.while_statement)
                    ]).required());

        builder.add_typedef(&names.literal).unwrap()
            .with_type(
                    Type::sum(&[
                        Type::named(&names.literal_boolean_expression),
                        Type::named(&names.literal_infinity_expression),
                        Type::named(&names.literal_null_expression),
                        Type::named(&names.literal_numeric_expression),
                        Type::named(&names.literal_string_expression)
                    ]).required());

        builder.add_typedef(&names.simple_assignment_target).unwrap()
            .with_type(
                    Type::sum(&[
                        Type::named(&names.assignment_target_identifier),
                        Type::named(&names.computed_member_assignment_target),
                        Type::named(&names.static_member_assignment_target)
                    ]).required());

        builder.add_typedef(&names.statement).unwrap()
            .with_type(
                    Type::sum(&[
                        Type::named(&names.block),
                        Type::named(&names.break_statement),
                        Type::named(&names.continue_statement),
                        Type::named(&names.class_declaration),
                        Type::named(&names.debugger_statement),
                        Type::named(&names.empty_statement),
                        Type::named(&names.expression_statement),
                        Type::named(&names.function_declaration),
                        Type::named(&names.if_statement),
                        Type::named(&names.iteration_statement),
                        Type::named(&names.labelled_statement),
                        Type::named(&names.return_statement),
                        Type::named(&names.switch_statement),
                        Type::named(&names.switch_statement_with_default),
                        Type::named(&names.throw_statement),
                        Type::named(&names.try_catch_statement),
                        Type::named(&names.try_finally_statement),
                        Type::named(&names.variable_declaration),
                        Type::named(&names.with_statement)
                    ]).required());

        builder.add_typedef(&names.property_name).unwrap()
            .with_type(
                    Type::sum(&[
                        Type::named(&names.computed_property_name),
                        Type::named(&names.literal_property_name)
                    ]).required());

        builder.add_typedef(&names.method_definition).unwrap()
            .with_type(
                    Type::sum(&[
                        Type::named(&names.method),
                        Type::named(&names.getter),
                        Type::named(&names.setter)
                    ]).required());

        builder.add_typedef(&names.object_property).unwrap()
            .with_type(
                    Type::sum(&[
                        Type::named(&names.method_definition),
                        Type::named(&names.data_property),
                        Type::named(&names.shorthand_property)
                    ]).required());

        builder.add_typedef(&names.expression).unwrap()
            .with_type(
                    Type::sum(&[
                        Type::named(&names.literal),
                        Type::named(&names.literal_reg_exp_expression),
                        Type::named(&names.array_expression),
                        Type::named(&names.arrow_expression),
                        Type::named(&names.assignment_expression),
                        Type::named(&names.binary_expression),
                        Type::named(&names.call_expression),
                        Type::named(&names.compound_assignment_expression),
                        Type::named(&names.computed_member_expression),
                        Type::named(&names.conditional_expression),
                        Type::named(&names.class_expression),
                        Type::named(&names.function_expression),
                        Type::named(&names.identifier_expression),
                        Type::named(&names.new_expression),
                        Type::named(&names.new_target_expression),
                        Type::named(&names.object_expression),
                        Type::named(&names.unary_expression),
                        Type::named(&names.static_member_expression),
                        Type::named(&names.template_expression),
                        Type::named(&names.this_expression),
                        Type::named(&names.update_expression),
                        Type::named(&names.yield_expression),
                        Type::named(&names.yield_star_expression),
                        Type::named(&names.await_expression)
                    ]).required());

        builder.add_typedef(&names.identifier).unwrap()
            .with_type(
                    Type::named(&names.string).required());

        builder.add_typedef(&names.identifier_name).unwrap()
            .with_type(
                    Type::named(&names.string).required());

        builder.add_typedef(&names.label).unwrap()
            .with_type(
                    Type::named(&names.string).required());

        builder.add_typedef(&names.binding).unwrap()
            .with_type(
                    Type::sum(&[
                        Type::named(&names.binding_pattern),
                        Type::named(&names.binding_identifier)
                    ]).required());

        builder.add_typedef(&names.parameter).unwrap()
            .with_type(
                    Type::sum(&[
                        Type::named(&names.binding),
                        Type::named(&names.binding_with_initializer)
                    ]).required());

        builder.add_typedef(&names.assignment_target).unwrap()
            .with_type(
                    Type::sum(&[
                        Type::named(&names.assignment_target_pattern),
                        Type::named(&names.simple_assignment_target)
                    ]).required());

        builder.add_typedef(&names.import_declaration).unwrap()
            .with_type(
                    Type::sum(&[
                        Type::named(&names.import_namespace),
                        Type::named(&names.import)
                    ]).required());

        builder.add_typedef(&names.assignment_target_pattern).unwrap()
            .with_type(
                    Type::sum(&[
                        Type::named(&names.object_assignment_target),
                        Type::named(&names.array_assignment_target)
                    ]).required());

        builder.add_typedef(&names.program).unwrap()
            .with_type(
                    Type::sum(&[
                        Type::named(&names.script),
                        Type::named(&names.module)
                    ]).required());

        builder.add_typedef(&names.binding_pattern).unwrap()
            .with_type(
                    Type::sum(&[
                        Type::named(&names.object_binding),
                        Type::named(&names.array_binding)
                    ]).required());

        builder.add_typedef(&names.string).unwrap()
            .with_type(
                    Type::string().required());

        builder.add_typedef(&names.arguments).unwrap()
            .with_type(
                    Type::sum(&[
                        Type::named(&names.spread_element),
                        Type::named(&names.expression)
                    ]).required().array().required());

        builder.add_typedef(&names.export_declaration).unwrap()
            .with_type(
                    Type::sum(&[
                        Type::named(&names.export_all_from),
                        Type::named(&names.export_from),
                        Type::named(&names.export_locals),
                        Type::named(&names.export_default),
                        Type::named(&names.export)
                    ]).required());

        builder.add_typedef(&names.binding_property).unwrap()
            .with_type(
                    Type::sum(&[
                        Type::named(&names.binding_property_identifier),
                        Type::named(&names.binding_property_property)
                    ]).required());

        builder.add_interface(&names.await_expression).unwrap()
            .with_field(
                 &names.field_expression,
                 Type::named(&names.expression).required()
            );

        builder.add_interface(&names.function_declaration).unwrap()
            .with_field(
                 &names.field_is_async,
                 Type::bool().required()
            )
            .with_field(
                 &names.field_is_generator,
                 Type::bool().required()
            )
            .with_field(
                 &names.field_parameter_scope,
                 Type::named(&names.asserted_parameter_scope).optional()
            )
            .with_field(
                 &names.field_body_scope,
                 Type::named(&names.asserted_var_scope).optional()
            )
            .with_field(
                 &names.field_name,
                 Type::named(&names.binding_identifier).required()
            )
            .with_field(
                 &names.field_params,
                 Type::named(&names.formal_parameters).required()
            )
            .with_field(
                 &names.field_body,
                 Type::named(&names.function_body).required()
            );

        builder.add_interface(&names.null).unwrap()
;

        builder.add_interface(&names.method).unwrap()
            .with_field(
                 &names.field_is_async,
                 Type::bool().required()
            )
            .with_field(
                 &names.field_is_generator,
                 Type::bool().required()
            )
            .with_field(
                 &names.field_parameter_scope,
                 Type::named(&names.asserted_parameter_scope).optional()
            )
            .with_field(
                 &names.field_body_scope,
                 Type::named(&names.asserted_var_scope).optional()
            )
            .with_field(
                 &names.field_name,
                 Type::named(&names.property_name).required()
            )
            .with_field(
                 &names.field_params,
                 Type::named(&names.formal_parameters).required()
            )
            .with_field(
                 &names.field_body,
                 Type::named(&names.function_body).required()
            );

        builder.add_interface(&names.unary_expression).unwrap()
            .with_field(
                 &names.field_operator,
                 Type::named(&names.unary_operator).required()
            )
            .with_field(
                 &names.field_operand,
                 Type::named(&names.expression).required()
            );

        builder.add_interface(&names.for_in_of_binding).unwrap()
            .with_field(
                 &names.field_kind,
                 Type::named(&names.variable_declaration_kind).required()
            )
            .with_field(
                 &names.field_binding,
                 Type::named(&names.binding).required()
            );

        builder.add_interface(&names.block).unwrap()
            .with_field(
                 &names.field_scope,
                 Type::named(&names.asserted_block_scope).optional()
            )
            .with_field(
                 &names.field_statements,
                 Type::named(&names.statement).required().array().required()
            );

        builder.add_interface(&names.new_expression).unwrap()
            .with_field(
                 &names.field_callee,
                 Type::named(&names.expression).required()
            )
            .with_field(
                 &names.field_arguments,
                 Type::named(&names.arguments).required()
            );

        builder.add_interface(&names.import_specifier).unwrap()
            .with_field(
                 &names.field_name,
                 Type::named(&names.identifier_name).optional()
            )
            .with_field(
                 &names.field_binding,
                 Type::named(&names.binding_identifier).required()
            );

        builder.add_interface(&names.catch_clause).unwrap()
            .with_field(
                 &names.field_binding,
                 Type::named(&names.binding).required()
            )
            .with_field(
                 &names.field_body,
                 Type::named(&names.block).required()
            );

        builder.add_interface(&names.literal_infinity_expression).unwrap()
;

        builder.add_interface(&names.binding_property_identifier).unwrap()
            .with_field(
                 &names.field_binding,
                 Type::named(&names.binding_identifier).required()
            )
            .with_field(
                 &names.field_init,
                 Type::named(&names.expression).optional()
            );

        builder.add_interface(&names.computed_member_assignment_target).unwrap()
            .with_field(
                 &names.field_object,
                 Type::sum(&[
                     Type::named(&names.expression),
                     Type::named(&names.super_)
                 ]).required()
            )
            .with_field(
                 &names.field_expression,
                 Type::named(&names.expression).required()
            );

        builder.add_interface(&names.literal_reg_exp_expression).unwrap()
            .with_field(
                 &names.field_pattern,
                 Type::named(&names.string).required()
            )
            .with_field(
                 &names.field_flags,
                 Type::named(&names.string).required()
            );

        builder.add_interface(&names.new_target_expression).unwrap()
;

        builder.add_interface(&names.module).unwrap()
            .with_field(
                 &names.field_scope,
                 Type::named(&names.asserted_var_scope).optional()
            )
            .with_field(
                 &names.field_directives,
                 Type::named(&names.directive).required().array().required()
            )
            .with_field(
                 &names.field_items,
                 Type::sum(&[
                     Type::named(&names.import_declaration),
                     Type::named(&names.export_declaration),
                     Type::named(&names.statement)
                 ]).required().array().required()
            );

        builder.add_interface(&names.if_statement).unwrap()
            .with_field(
                 &names.field_test,
                 Type::named(&names.expression).required()
            )
            .with_field(
                 &names.field_consequent,
                 Type::named(&names.statement).required()
            )
            .with_field(
                 &names.field_alternate,
                 Type::named(&names.statement).optional()
            );

        builder.add_interface(&names.super_).unwrap()
;

        builder.add_interface(&names.try_catch_statement).unwrap()
            .with_field(
                 &names.field_body,
                 Type::named(&names.block).required()
            )
            .with_field(
                 &names.field_catch_clause,
                 Type::named(&names.catch_clause).required()
            );

        builder.add_interface(&names.yield_expression).unwrap()
            .with_field(
                 &names.field_expression,
                 Type::named(&names.expression).optional()
            );

        builder.add_interface(&names.computed_property_name).unwrap()
            .with_field(
                 &names.field_expression,
                 Type::named(&names.expression).required()
            );

        builder.add_interface(&names.directive).unwrap()
            .with_field(
                 &names.field_raw_value,
                 Type::named(&names.string).required()
            );

        builder.add_interface(&names.object_assignment_target).unwrap()
            .with_field(
                 &names.field_properties,
                 Type::named(&names.assignment_target_property).required().array().required()
            );

        builder.add_interface(&names.function_body).unwrap()
            .with_field(
                 &names.field_directives,
                 Type::named(&names.directive).required().array().required()
            )
            .with_field(
                 &names.field_statements,
                 Type::named(&names.statement).required().array().required()
            );

        builder.add_interface(&names.labelled_statement).unwrap()
            .with_field(
                 &names.field_label,
                 Type::named(&names.label).required()
            )
            .with_field(
                 &names.field_body,
                 Type::named(&names.statement).required()
            );

        builder.add_interface(&names.export_all_from).unwrap()
            .with_field(
                 &names.field_module_specifier,
                 Type::named(&names.string).required()
            );

        builder.add_interface(&names.literal_property_name).unwrap()
            .with_field(
                 &names.field_value,
                 Type::named(&names.string).required()
            );

        builder.add_interface(&names.class_declaration).unwrap()
            .with_field(
                 &names.field_name,
                 Type::named(&names.binding_identifier).required()
            )
            .with_field(
                 &names.field_super_,
                 Type::named(&names.expression).optional()
            )
            .with_field(
                 &names.field_elements,
                 Type::named(&names.class_element).required().array().required()
            );

        builder.add_interface(&names.call_expression).unwrap()
            .with_field(
                 &names.field_callee,
                 Type::sum(&[
                     Type::named(&names.expression),
                     Type::named(&names.super_)
                 ]).required()
            )
            .with_field(
                 &names.field_arguments,
                 Type::named(&names.arguments).required()
            );

        builder.add_interface(&names.switch_case).unwrap()
            .with_field(
                 &names.field_test,
                 Type::named(&names.expression).required()
            )
            .with_field(
                 &names.field_consequent,
                 Type::named(&names.statement).required().array().required()
            );

        builder.add_interface(&names.try_finally_statement).unwrap()
            .with_field(
                 &names.field_body,
                 Type::named(&names.block).required()
            )
            .with_field(
                 &names.field_catch_clause,
                 Type::named(&names.catch_clause).optional()
            )
            .with_field(
                 &names.field_finalizer,
                 Type::named(&names.block).required()
            );

        builder.add_interface(&names.template_element).unwrap()
            .with_field(
                 &names.field_raw_value,
                 Type::named(&names.string).required()
            );

        builder.add_interface(&names.compound_assignment_expression).unwrap()
            .with_field(
                 &names.field_operator,
                 Type::named(&names.compound_assignment_operator).required()
            )
            .with_field(
                 &names.field_binding,
                 Type::named(&names.simple_assignment_target).required()
            )
            .with_field(
                 &names.field_expression,
                 Type::named(&names.expression).required()
            );

        builder.add_interface(&names.template_expression).unwrap()
            .with_field(
                 &names.field_tag,
                 Type::named(&names.expression).optional()
            )
            .with_field(
                 &names.field_elements,
                 Type::sum(&[
                     Type::named(&names.expression),
                     Type::named(&names.template_element)
                 ]).required().array().required()
            );

        builder.add_interface(&names.expression_statement).unwrap()
            .with_field(
                 &names.field_expression,
                 Type::named(&names.expression).required()
            );

        builder.add_interface(&names.while_statement).unwrap()
            .with_field(
                 &names.field_test,
                 Type::named(&names.expression).required()
            )
            .with_field(
                 &names.field_body,
                 Type::named(&names.statement).required()
            );

        builder.add_interface(&names.conditional_expression).unwrap()
            .with_field(
                 &names.field_test,
                 Type::named(&names.expression).required()
            )
            .with_field(
                 &names.field_consequent,
                 Type::named(&names.expression).required()
            )
            .with_field(
                 &names.field_alternate,
                 Type::named(&names.expression).required()
            );

        builder.add_interface(&names.class_element).unwrap()
            .with_field(
                 &names.field_is_static,
                 Type::bool().required()
            )
            .with_field(
                 &names.field_method,
                 Type::named(&names.method_definition).required()
            );

        builder.add_interface(&names.computed_member_expression).unwrap()
            .with_field(
                 &names.field_object,
                 Type::sum(&[
                     Type::named(&names.expression),
                     Type::named(&names.super_)
                 ]).required()
            )
            .with_field(
                 &names.field_expression,
                 Type::named(&names.expression).required()
            );

        builder.add_interface(&names.shorthand_property).unwrap()
            .with_field(
                 &names.field_name,
                 Type::named(&names.identifier_expression).required()
            );

        builder.add_interface(&names.array_assignment_target).unwrap()
            .with_field(
                 &names.field_elements,
                 Type::sum(&[
                     Type::named(&names.assignment_target),
                     Type::named(&names.assignment_target_with_initializer)
                 ]).required().array().required()
            )
            .with_field(
                 &names.field_rest,
                 Type::named(&names.assignment_target).optional()
            );

        builder.add_interface(&names.for_in_statement).unwrap()
            .with_field(
                 &names.field_left,
                 Type::sum(&[
                     Type::named(&names.for_in_of_binding),
                     Type::named(&names.assignment_target)
                 ]).required()
            )
            .with_field(
                 &names.field_right,
                 Type::named(&names.expression).required()
            )
            .with_field(
                 &names.field_body,
                 Type::named(&names.statement).required()
            );

        builder.add_interface(&names.with_statement).unwrap()
            .with_field(
                 &names.field_object,
                 Type::named(&names.expression).required()
            )
            .with_field(
                 &names.field_body,
                 Type::named(&names.statement).required()
            );

        builder.add_interface(&names.arrow_expression).unwrap()
            .with_field(
                 &names.field_is_async,
                 Type::bool().required()
            )
            .with_field(
                 &names.field_parameter_scope,
                 Type::named(&names.asserted_parameter_scope).optional()
            )
            .with_field(
                 &names.field_body_scope,
                 Type::named(&names.asserted_var_scope).optional()
            )
            .with_field(
                 &names.field_params,
                 Type::named(&names.formal_parameters).required()
            )
            .with_field(
                 &names.field_body,
                 Type::sum(&[
                     Type::named(&names.function_body),
                     Type::named(&names.expression)
                 ]).required()
            );

        builder.add_interface(&names.variable_declarator).unwrap()
            .with_field(
                 &names.field_binding,
                 Type::named(&names.binding).required()
            )
            .with_field(
                 &names.field_init,
                 Type::named(&names.expression).optional()
            );

        builder.add_interface(&names.switch_default).unwrap()
            .with_field(
                 &names.field_consequent,
                 Type::named(&names.statement).required().array().required()
            );

        builder.add_interface(&names.debugger_statement).unwrap()
;

        builder.add_interface(&names.export_from_specifier).unwrap()
            .with_field(
                 &names.field_name,
                 Type::named(&names.identifier_name).required()
            )
            .with_field(
                 &names.field_exported_name,
                 Type::named(&names.identifier_name).optional()
            );

        builder.add_interface(&names.export_local_specifier).unwrap()
            .with_field(
                 &names.field_name,
                 Type::named(&names.identifier_expression).required()
            )
            .with_field(
                 &names.field_exported_name,
                 Type::named(&names.identifier_name).optional()
            );

        builder.add_interface(&names.yield_star_expression).unwrap()
            .with_field(
                 &names.field_expression,
                 Type::named(&names.expression).required()
            );

        builder.add_interface(&names.switch_statement).unwrap()
            .with_field(
                 &names.field_discriminant,
                 Type::named(&names.expression).required()
            )
            .with_field(
                 &names.field_cases,
                 Type::named(&names.switch_case).required().array().required()
            );

        builder.add_interface(&names.asserted_parameter_scope).unwrap()
            .with_field(
                 &names.field_parameter_names,
                 Type::named(&names.identifier_name).required().array().required()
            )
            .with_field(
                 &names.field_captured_names,
                 Type::named(&names.identifier_name).required().array().required()
            )
            .with_field(
                 &names.field_has_direct_eval,
                 Type::bool().required()
            );

        builder.add_interface(&names.export).unwrap()
            .with_field(
                 &names.field_declaration,
                 Type::sum(&[
                     Type::named(&names.function_declaration),
                     Type::named(&names.class_declaration),
                     Type::named(&names.variable_declaration)
                 ]).required()
            );

        builder.add_interface(&names.spread_element).unwrap()
            .with_field(
                 &names.field_expression,
                 Type::named(&names.expression).required()
            );

        builder.add_interface(&names.throw_statement).unwrap()
            .with_field(
                 &names.field_expression,
                 Type::named(&names.expression).required()
            );

        builder.add_interface(&names.getter).unwrap()
            .with_field(
                 &names.field_body_scope,
                 Type::named(&names.asserted_var_scope).optional()
            )
            .with_field(
                 &names.field_name,
                 Type::named(&names.property_name).required()
            )
            .with_field(
                 &names.field_body,
                 Type::named(&names.function_body).required()
            );

        builder.add_interface(&names.return_statement).unwrap()
            .with_field(
                 &names.field_expression,
                 Type::named(&names.expression).optional()
            );

        builder.add_interface(&names.binding_identifier).unwrap()
            .with_field(
                 &names.field_name,
                 Type::named(&names.identifier).required()
            );

        builder.add_interface(&names.for_statement).unwrap()
            .with_field(
                 &names.field_init,
                 Type::sum(&[
                     Type::named(&names.variable_declaration),
                     Type::named(&names.expression)
                 ]).optional()
            )
            .with_field(
                 &names.field_test,
                 Type::named(&names.expression).optional()
            )
            .with_field(
                 &names.field_update,
                 Type::named(&names.expression).optional()
            )
            .with_field(
                 &names.field_body,
                 Type::named(&names.statement).required()
            );

        builder.add_interface(&names.binding_property_property).unwrap()
            .with_field(
                 &names.field_name,
                 Type::named(&names.property_name).required()
            )
            .with_field(
                 &names.field_binding,
                 Type::sum(&[
                     Type::named(&names.binding),
                     Type::named(&names.binding_with_initializer)
                 ]).required()
            );

        builder.add_interface(&names.import).unwrap()
            .with_field(
                 &names.field_module_specifier,
                 Type::named(&names.string).required()
            )
            .with_field(
                 &names.field_default_binding,
                 Type::named(&names.binding_identifier).optional()
            )
            .with_field(
                 &names.field_named_imports,
                 Type::named(&names.import_specifier).required().array().required()
            );

        builder.add_interface(&names.empty_statement).unwrap()
;

        builder.add_interface(&names.assignment_target_with_initializer).unwrap()
            .with_field(
                 &names.field_binding,
                 Type::named(&names.assignment_target).required()
            )
            .with_field(
                 &names.field_init,
                 Type::named(&names.expression).required()
            );

        builder.add_interface(&names.asserted_var_scope).unwrap()
            .with_field(
                 &names.field_lexically_declared_names,
                 Type::named(&names.identifier_name).required().array().required()
            )
            .with_field(
                 &names.field_var_declared_names,
                 Type::named(&names.identifier_name).required().array().required()
            )
            .with_field(
                 &names.field_captured_names,
                 Type::named(&names.identifier_name).required().array().required()
            )
            .with_field(
                 &names.field_has_direct_eval,
                 Type::bool().required()
            );

        builder.add_interface(&names.literal_null_expression).unwrap()
;

        builder.add_interface(&names.break_statement).unwrap()
            .with_field(
                 &names.field_label,
                 Type::named(&names.label).optional()
            );

        builder.add_interface(&names.static_member_assignment_target).unwrap()
            .with_field(
                 &names.field_object,
                 Type::sum(&[
                     Type::named(&names.expression),
                     Type::named(&names.super_)
                 ]).required()
            )
            .with_field(
                 &names.field_property,
                 Type::named(&names.identifier_name).required()
            );

        builder.add_interface(&names.setter).unwrap()
            .with_field(
                 &names.field_parameter_scope,
                 Type::named(&names.asserted_parameter_scope).optional()
            )
            .with_field(
                 &names.field_body_scope,
                 Type::named(&names.asserted_var_scope).optional()
            )
            .with_field(
                 &names.field_name,
                 Type::named(&names.property_name).required()
            )
            .with_field(
                 &names.field_param,
                 Type::named(&names.parameter).required()
            )
            .with_field(
                 &names.field_body,
                 Type::named(&names.function_body).required()
            );

        builder.add_interface(&names.assignment_expression).unwrap()
            .with_field(
                 &names.field_binding,
                 Type::named(&names.assignment_target).required()
            )
            .with_field(
                 &names.field_expression,
                 Type::named(&names.expression).required()
            );

        builder.add_interface(&names.export_default).unwrap()
            .with_field(
                 &names.field_body,
                 Type::sum(&[
                     Type::named(&names.function_declaration),
                     Type::named(&names.class_declaration),
                     Type::named(&names.expression)
                 ]).required()
            );

        builder.add_interface(&names.formal_parameters).unwrap()
            .with_field(
                 &names.field_items,
                 Type::named(&names.parameter).required().array().required()
            )
            .with_field(
                 &names.field_rest,
                 Type::named(&names.binding).optional()
            );

        builder.add_interface(&names.switch_statement_with_default).unwrap()
            .with_field(
                 &names.field_discriminant,
                 Type::named(&names.expression).required()
            )
            .with_field(
                 &names.field_pre_default_cases,
                 Type::named(&names.switch_case).required().array().required()
            )
            .with_field(
                 &names.field_default_case,
                 Type::named(&names.switch_default).required()
            )
            .with_field(
                 &names.field_post_default_cases,
                 Type::named(&names.switch_case).required().array().required()
            );

        builder.add_interface(&names.assignment_target_property_property).unwrap()
            .with_field(
                 &names.field_name,
                 Type::named(&names.property_name).required()
            )
            .with_field(
                 &names.field_binding,
                 Type::sum(&[
                     Type::named(&names.assignment_target),
                     Type::named(&names.assignment_target_with_initializer)
                 ]).required()
            );

        builder.add_interface(&names.literal_boolean_expression).unwrap()
            .with_field(
                 &names.field_value,
                 Type::bool().required()
            );

        builder.add_interface(&names.assignment_target_identifier).unwrap()
            .with_field(
                 &names.field_name,
                 Type::named(&names.identifier).required()
            );

        builder.add_interface(&names.object_binding).unwrap()
            .with_field(
                 &names.field_properties,
                 Type::named(&names.binding_property).required().array().required()
            );

        builder.add_interface(&names.export_from).unwrap()
            .with_field(
                 &names.field_named_exports,
                 Type::named(&names.export_from_specifier).required().array().required()
            )
            .with_field(
                 &names.field_module_specifier,
                 Type::named(&names.string).required()
            );

        builder.add_interface(&names.binary_expression).unwrap()
            .with_field(
                 &names.field_operator,
                 Type::named(&names.binary_operator).required()
            )
            .with_field(
                 &names.field_left,
                 Type::named(&names.expression).required()
            )
            .with_field(
                 &names.field_right,
                 Type::named(&names.expression).required()
            );

        builder.add_interface(&names.export_locals).unwrap()
            .with_field(
                 &names.field_named_exports,
                 Type::named(&names.export_local_specifier).required().array().required()
            );

        builder.add_interface(&names.static_member_expression).unwrap()
            .with_field(
                 &names.field_object,
                 Type::sum(&[
                     Type::named(&names.expression),
                     Type::named(&names.super_)
                 ]).required()
            )
            .with_field(
                 &names.field_property,
                 Type::named(&names.identifier_name).required()
            );

        builder.add_interface(&names.for_of_statement).unwrap()
            .with_field(
                 &names.field_left,
                 Type::sum(&[
                     Type::named(&names.for_in_of_binding),
                     Type::named(&names.assignment_target)
                 ]).required()
            )
            .with_field(
                 &names.field_right,
                 Type::named(&names.expression).required()
            )
            .with_field(
                 &names.field_body,
                 Type::named(&names.statement).required()
            );

        builder.add_interface(&names.this_expression).unwrap()
;

        builder.add_interface(&names.array_expression).unwrap()
            .with_field(
                 &names.field_elements,
                 Type::sum(&[
                     Type::named(&names.spread_element),
                     Type::named(&names.expression)
                 ]).optional().array().required()
            );

        builder.add_interface(&names.literal_numeric_expression).unwrap()
            .with_field(
                 &names.field_value,
                 Type::number().required()
            );

        builder.add_interface(&names.continue_statement).unwrap()
            .with_field(
                 &names.field_label,
                 Type::named(&names.label).optional()
            );

        builder.add_interface(&names.binding_with_initializer).unwrap()
            .with_field(
                 &names.field_binding,
                 Type::named(&names.binding).required()
            )
            .with_field(
                 &names.field_init,
                 Type::named(&names.expression).required()
            );

        builder.add_interface(&names.do_while_statement).unwrap()
            .with_field(
                 &names.field_test,
                 Type::named(&names.expression).required()
            )
            .with_field(
                 &names.field_body,
                 Type::named(&names.statement).required()
            );

        builder.add_interface(&names.import_namespace).unwrap()
            .with_field(
                 &names.field_module_specifier,
                 Type::named(&names.string).required()
            )
            .with_field(
                 &names.field_default_binding,
                 Type::named(&names.binding_identifier).optional()
            )
            .with_field(
                 &names.field_namespace_binding,
                 Type::named(&names.binding_identifier).required()
            );

        builder.add_interface(&names.array_binding).unwrap()
            .with_field(
                 &names.field_elements,
                 Type::sum(&[
                     Type::named(&names.binding),
                     Type::named(&names.binding_with_initializer)
                 ]).optional().array().required()
            )
            .with_field(
                 &names.field_rest,
                 Type::named(&names.binding).optional()
            );

        builder.add_interface(&names.object_expression).unwrap()
            .with_field(
                 &names.field_properties,
                 Type::named(&names.object_property).required().array().required()
            );

        builder.add_interface(&names.variable_declaration).unwrap()
            .with_field(
                 &names.field_kind,
                 Type::named(&names.variable_declaration_kind).required()
            )
            .with_field(
                 &names.field_declarators,
                 Type::named(&names.variable_declarator).required().array().required()
            );

        builder.add_interface(&names.assignment_target_property_identifier).unwrap()
            .with_field(
                 &names.field_binding,
                 Type::named(&names.assignment_target_identifier).required()
            )
            .with_field(
                 &names.field_init,
                 Type::named(&names.expression).optional()
            );

        builder.add_interface(&names.data_property).unwrap()
            .with_field(
                 &names.field_name,
                 Type::named(&names.property_name).required()
            )
            .with_field(
                 &names.field_expression,
                 Type::named(&names.expression).required()
            );

        builder.add_interface(&names.update_expression).unwrap()
            .with_field(
                 &names.field_is_prefix,
                 Type::bool().required()
            )
            .with_field(
                 &names.field_operator,
                 Type::named(&names.update_operator).required()
            )
            .with_field(
                 &names.field_operand,
                 Type::named(&names.simple_assignment_target).required()
            );

        builder.add_interface(&names.literal_string_expression).unwrap()
            .with_field(
                 &names.field_value,
                 Type::named(&names.string).required()
            );

        builder.add_interface(&names.asserted_block_scope).unwrap()
            .with_field(
                 &names.field_lexically_declared_names,
                 Type::named(&names.identifier_name).required().array().required()
            )
            .with_field(
                 &names.field_captured_names,
                 Type::named(&names.identifier_name).required().array().required()
            )
            .with_field(
                 &names.field_has_direct_eval,
                 Type::bool().required()
            );

        builder.add_interface(&names.class_expression).unwrap()
            .with_field(
                 &names.field_name,
                 Type::named(&names.binding_identifier).optional()
            )
            .with_field(
                 &names.field_super_,
                 Type::named(&names.expression).optional()
            )
            .with_field(
                 &names.field_elements,
                 Type::named(&names.class_element).required().array().required()
            );

        builder.add_interface(&names.identifier_expression).unwrap()
            .with_field(
                 &names.field_name,
                 Type::named(&names.identifier).required()
            );

        builder.add_interface(&names.function_expression).unwrap()
            .with_field(
                 &names.field_is_async,
                 Type::bool().required()
            )
            .with_field(
                 &names.field_is_generator,
                 Type::bool().required()
            )
            .with_field(
                 &names.field_parameter_scope,
                 Type::named(&names.asserted_parameter_scope).optional()
            )
            .with_field(
                 &names.field_body_scope,
                 Type::named(&names.asserted_var_scope).optional()
            )
            .with_field(
                 &names.field_name,
                 Type::named(&names.binding_identifier).optional()
            )
            .with_field(
                 &names.field_params,
                 Type::named(&names.formal_parameters).required()
            )
            .with_field(
                 &names.field_body,
                 Type::named(&names.function_body).required()
            );

        builder.add_interface(&names.script).unwrap()
            .with_field(
                 &names.field_scope,
                 Type::named(&names.asserted_var_scope).optional()
            )
            .with_field(
                 &names.field_directives,
                 Type::named(&names.directive).required().array().required()
            )
            .with_field(
                 &names.field_statements,
                 Type::named(&names.statement).required().array().required()
            );

        names
    }
}
