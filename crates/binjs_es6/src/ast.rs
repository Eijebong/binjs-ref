// This file is autogenerated.
 use binjs_shared;
use binjs_shared::{ FromJSON, FromJSONError, ToJSON };
use std;
use json;
use json::JsonValue as JSON;

// String enums (by lexicographical order)
#[derive(PartialEq, Debug, Clone)]
pub enum BinaryOperator {
     Comma,
     LogicalOr,
     LogicalAnd,
     BitOr,
     BitXor,
     BitAnd,
     Eq,
     Neq,
     StrictEq,
     StrictNeq,
     LessThan,
     LeqThan,
     GreaterThan,
     GeqThan,
     In,
     Instanceof,
     Lsh,
     Rsh,
     Ursh,
     Plus,
     Minus,
     Mul,
     Div,
     Mod,
     Pow
    }

impl FromJSON for BinaryOperator {
    fn import(source: &JSON) -> Result<Self, FromJSONError > {
        match source.as_str() {
           Some(",") => Ok(BinaryOperator::Comma),
           Some("||") => Ok(BinaryOperator::LogicalOr),
           Some("&&") => Ok(BinaryOperator::LogicalAnd),
           Some("|") => Ok(BinaryOperator::BitOr),
           Some("^") => Ok(BinaryOperator::BitXor),
           Some("&") => Ok(BinaryOperator::BitAnd),
           Some("==") => Ok(BinaryOperator::Eq),
           Some("!=") => Ok(BinaryOperator::Neq),
           Some("===") => Ok(BinaryOperator::StrictEq),
           Some("!==") => Ok(BinaryOperator::StrictNeq),
           Some("<") => Ok(BinaryOperator::LessThan),
           Some("<=") => Ok(BinaryOperator::LeqThan),
           Some(">") => Ok(BinaryOperator::GreaterThan),
           Some(">=") => Ok(BinaryOperator::GeqThan),
           Some("in") => Ok(BinaryOperator::In),
           Some("instanceof") => Ok(BinaryOperator::Instanceof),
           Some("<<") => Ok(BinaryOperator::Lsh),
           Some(">>") => Ok(BinaryOperator::Rsh),
           Some(">>>") => Ok(BinaryOperator::Ursh),
           Some("+") => Ok(BinaryOperator::Plus),
           Some("-") => Ok(BinaryOperator::Minus),
           Some("*") => Ok(BinaryOperator::Mul),
           Some("/") => Ok(BinaryOperator::Div),
           Some("%") => Ok(BinaryOperator::Mod),
           Some("**") => Ok(BinaryOperator::Pow),
            _ => Err(FromJSONError {
                expected: "Instance of BinaryOperator".to_string(),
                got: source.dump(),
            })
        }
    }
}


impl ToJSON for BinaryOperator {
    fn export(&self) -> JSON {
        json::from(match *self {
           BinaryOperator::Comma => ",",
           BinaryOperator::LogicalOr => "||",
           BinaryOperator::LogicalAnd => "&&",
           BinaryOperator::BitOr => "|",
           BinaryOperator::BitXor => "^",
           BinaryOperator::BitAnd => "&",
           BinaryOperator::Eq => "==",
           BinaryOperator::Neq => "!=",
           BinaryOperator::StrictEq => "===",
           BinaryOperator::StrictNeq => "!==",
           BinaryOperator::LessThan => "<",
           BinaryOperator::LeqThan => "<=",
           BinaryOperator::GreaterThan => ">",
           BinaryOperator::GeqThan => ">=",
           BinaryOperator::In => "in",
           BinaryOperator::Instanceof => "instanceof",
           BinaryOperator::Lsh => "<<",
           BinaryOperator::Rsh => ">>",
           BinaryOperator::Ursh => ">>>",
           BinaryOperator::Plus => "+",
           BinaryOperator::Minus => "-",
           BinaryOperator::Mul => "*",
           BinaryOperator::Div => "/",
           BinaryOperator::Mod => "%",
           BinaryOperator::Pow => "**"
        })
    }
}


impl Walker for BinaryOperator {
    fn walk<V, E>(&mut self, _: &mut Path, _: &mut V) -> Result<(), E> where V: Visitor<E> {
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub enum CompoundAssignmentOperator {
     PlusAssign,
     MinusAssign,
     MulAssign,
     DivAssign,
     ModAssign,
     PowAssign,
     LshAssign,
     RshAssign,
     UrshAssign,
     BitOrAssign,
     BitXorAssign,
     BitAndAssign
    }

impl FromJSON for CompoundAssignmentOperator {
    fn import(source: &JSON) -> Result<Self, FromJSONError > {
        match source.as_str() {
           Some("+=") => Ok(CompoundAssignmentOperator::PlusAssign),
           Some("-=") => Ok(CompoundAssignmentOperator::MinusAssign),
           Some("*=") => Ok(CompoundAssignmentOperator::MulAssign),
           Some("/=") => Ok(CompoundAssignmentOperator::DivAssign),
           Some("%=") => Ok(CompoundAssignmentOperator::ModAssign),
           Some("**=") => Ok(CompoundAssignmentOperator::PowAssign),
           Some("<<=") => Ok(CompoundAssignmentOperator::LshAssign),
           Some(">>=") => Ok(CompoundAssignmentOperator::RshAssign),
           Some(">>>=") => Ok(CompoundAssignmentOperator::UrshAssign),
           Some("|=") => Ok(CompoundAssignmentOperator::BitOrAssign),
           Some("^=") => Ok(CompoundAssignmentOperator::BitXorAssign),
           Some("&=") => Ok(CompoundAssignmentOperator::BitAndAssign),
            _ => Err(FromJSONError {
                expected: "Instance of CompoundAssignmentOperator".to_string(),
                got: source.dump(),
            })
        }
    }
}


impl ToJSON for CompoundAssignmentOperator {
    fn export(&self) -> JSON {
        json::from(match *self {
           CompoundAssignmentOperator::PlusAssign => "+=",
           CompoundAssignmentOperator::MinusAssign => "-=",
           CompoundAssignmentOperator::MulAssign => "*=",
           CompoundAssignmentOperator::DivAssign => "/=",
           CompoundAssignmentOperator::ModAssign => "%=",
           CompoundAssignmentOperator::PowAssign => "**=",
           CompoundAssignmentOperator::LshAssign => "<<=",
           CompoundAssignmentOperator::RshAssign => ">>=",
           CompoundAssignmentOperator::UrshAssign => ">>>=",
           CompoundAssignmentOperator::BitOrAssign => "|=",
           CompoundAssignmentOperator::BitXorAssign => "^=",
           CompoundAssignmentOperator::BitAndAssign => "&="
        })
    }
}


impl Walker for CompoundAssignmentOperator {
    fn walk<V, E>(&mut self, _: &mut Path, _: &mut V) -> Result<(), E> where V: Visitor<E> {
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub enum UnaryOperator {
     Plus,
     Minus,
     Not,
     BitNot,
     Typeof,
     Void,
     Delete
    }

impl FromJSON for UnaryOperator {
    fn import(source: &JSON) -> Result<Self, FromJSONError > {
        match source.as_str() {
           Some("+") => Ok(UnaryOperator::Plus),
           Some("-") => Ok(UnaryOperator::Minus),
           Some("!") => Ok(UnaryOperator::Not),
           Some("~") => Ok(UnaryOperator::BitNot),
           Some("typeof") => Ok(UnaryOperator::Typeof),
           Some("void") => Ok(UnaryOperator::Void),
           Some("delete") => Ok(UnaryOperator::Delete),
            _ => Err(FromJSONError {
                expected: "Instance of UnaryOperator".to_string(),
                got: source.dump(),
            })
        }
    }
}


impl ToJSON for UnaryOperator {
    fn export(&self) -> JSON {
        json::from(match *self {
           UnaryOperator::Plus => "+",
           UnaryOperator::Minus => "-",
           UnaryOperator::Not => "!",
           UnaryOperator::BitNot => "~",
           UnaryOperator::Typeof => "typeof",
           UnaryOperator::Void => "void",
           UnaryOperator::Delete => "delete"
        })
    }
}


impl Walker for UnaryOperator {
    fn walk<V, E>(&mut self, _: &mut Path, _: &mut V) -> Result<(), E> where V: Visitor<E> {
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub enum UpdateOperator {
     Incr,
     Decr
    }

impl FromJSON for UpdateOperator {
    fn import(source: &JSON) -> Result<Self, FromJSONError > {
        match source.as_str() {
           Some("++") => Ok(UpdateOperator::Incr),
           Some("--") => Ok(UpdateOperator::Decr),
            _ => Err(FromJSONError {
                expected: "Instance of UpdateOperator".to_string(),
                got: source.dump(),
            })
        }
    }
}


impl ToJSON for UpdateOperator {
    fn export(&self) -> JSON {
        json::from(match *self {
           UpdateOperator::Incr => "++",
           UpdateOperator::Decr => "--"
        })
    }
}


impl Walker for UpdateOperator {
    fn walk<V, E>(&mut self, _: &mut Path, _: &mut V) -> Result<(), E> where V: Visitor<E> {
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub enum VariableDeclarationKind {
     Var,
     Let,
     Const
    }

impl FromJSON for VariableDeclarationKind {
    fn import(source: &JSON) -> Result<Self, FromJSONError > {
        match source.as_str() {
           Some("var") => Ok(VariableDeclarationKind::Var),
           Some("let") => Ok(VariableDeclarationKind::Let),
           Some("const") => Ok(VariableDeclarationKind::Const),
            _ => Err(FromJSONError {
                expected: "Instance of VariableDeclarationKind".to_string(),
                got: source.dump(),
            })
        }
    }
}


impl ToJSON for VariableDeclarationKind {
    fn export(&self) -> JSON {
        json::from(match *self {
           VariableDeclarationKind::Var => "var",
           VariableDeclarationKind::Let => "let",
           VariableDeclarationKind::Const => "const"
        })
    }
}


impl Walker for VariableDeclarationKind {
    fn walk<V, E>(&mut self, _: &mut Path, _: &mut V) -> Result<(), E> where V: Visitor<E> {
        Ok(())
    }
}





// Type sums (by lexicographical order)
#[derive(PartialEq, Debug, Clone)]
pub enum AssignmentTarget {
    ComputedMemberAssignmentTarget(Box<ComputedMemberAssignmentTarget>),
    ArrayAssignmentTarget(Box<ArrayAssignmentTarget>),
    ObjectAssignmentTarget(Box<ObjectAssignmentTarget>),
    StaticMemberAssignmentTarget(Box<StaticMemberAssignmentTarget>),
    AssignmentTargetIdentifier(Box<AssignmentTargetIdentifier>)
}

impl FromJSON for AssignmentTarget {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("ComputedMemberAssignmentTarget") => Ok(AssignmentTarget::ComputedMemberAssignmentTarget(Box::new(FromJSON::import(value)?))),
           Some("ArrayAssignmentTarget") => Ok(AssignmentTarget::ArrayAssignmentTarget(Box::new(FromJSON::import(value)?))),
           Some("ObjectAssignmentTarget") => Ok(AssignmentTarget::ObjectAssignmentTarget(Box::new(FromJSON::import(value)?))),
           Some("StaticMemberAssignmentTarget") => Ok(AssignmentTarget::StaticMemberAssignmentTarget(Box::new(FromJSON::import(value)?))),
           Some("AssignmentTargetIdentifier") => Ok(AssignmentTarget::AssignmentTargetIdentifier(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of AssignmentTarget".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for AssignmentTarget {
    fn export(&self) -> JSON {
        match *self {
           AssignmentTarget::ComputedMemberAssignmentTarget(box ref value) => value.export(),
           AssignmentTarget::ArrayAssignmentTarget(box ref value) => value.export(),
           AssignmentTarget::ObjectAssignmentTarget(box ref value) => value.export(),
           AssignmentTarget::StaticMemberAssignmentTarget(box ref value) => value.export(),
           AssignmentTarget::AssignmentTargetIdentifier(box ref value) => value.export()
        }
    }
}


impl Walker for AssignmentTarget {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          AssignmentTarget::ComputedMemberAssignmentTarget(box ref mut value) => value.walk(path, visitor),
          AssignmentTarget::ArrayAssignmentTarget(box ref mut value) => value.walk(path, visitor),
          AssignmentTarget::ObjectAssignmentTarget(box ref mut value) => value.walk(path, visitor),
          AssignmentTarget::StaticMemberAssignmentTarget(box ref mut value) => value.walk(path, visitor),
          AssignmentTarget::AssignmentTargetIdentifier(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum AssignmentTargetOrAssignmentTargetWithInitializer {
    StaticMemberAssignmentTarget(Box<StaticMemberAssignmentTarget>),
    ObjectAssignmentTarget(Box<ObjectAssignmentTarget>),
    ComputedMemberAssignmentTarget(Box<ComputedMemberAssignmentTarget>),
    ArrayAssignmentTarget(Box<ArrayAssignmentTarget>),
    AssignmentTargetIdentifier(Box<AssignmentTargetIdentifier>),
    AssignmentTargetWithInitializer(Box<AssignmentTargetWithInitializer>)
}

impl FromJSON for AssignmentTargetOrAssignmentTargetWithInitializer {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("StaticMemberAssignmentTarget") => Ok(AssignmentTargetOrAssignmentTargetWithInitializer::StaticMemberAssignmentTarget(Box::new(FromJSON::import(value)?))),
           Some("ObjectAssignmentTarget") => Ok(AssignmentTargetOrAssignmentTargetWithInitializer::ObjectAssignmentTarget(Box::new(FromJSON::import(value)?))),
           Some("ComputedMemberAssignmentTarget") => Ok(AssignmentTargetOrAssignmentTargetWithInitializer::ComputedMemberAssignmentTarget(Box::new(FromJSON::import(value)?))),
           Some("ArrayAssignmentTarget") => Ok(AssignmentTargetOrAssignmentTargetWithInitializer::ArrayAssignmentTarget(Box::new(FromJSON::import(value)?))),
           Some("AssignmentTargetIdentifier") => Ok(AssignmentTargetOrAssignmentTargetWithInitializer::AssignmentTargetIdentifier(Box::new(FromJSON::import(value)?))),
           Some("AssignmentTargetWithInitializer") => Ok(AssignmentTargetOrAssignmentTargetWithInitializer::AssignmentTargetWithInitializer(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of AssignmentTargetOrAssignmentTargetWithInitializer".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for AssignmentTargetOrAssignmentTargetWithInitializer {
    fn export(&self) -> JSON {
        match *self {
           AssignmentTargetOrAssignmentTargetWithInitializer::StaticMemberAssignmentTarget(box ref value) => value.export(),
           AssignmentTargetOrAssignmentTargetWithInitializer::ObjectAssignmentTarget(box ref value) => value.export(),
           AssignmentTargetOrAssignmentTargetWithInitializer::ComputedMemberAssignmentTarget(box ref value) => value.export(),
           AssignmentTargetOrAssignmentTargetWithInitializer::ArrayAssignmentTarget(box ref value) => value.export(),
           AssignmentTargetOrAssignmentTargetWithInitializer::AssignmentTargetIdentifier(box ref value) => value.export(),
           AssignmentTargetOrAssignmentTargetWithInitializer::AssignmentTargetWithInitializer(box ref value) => value.export()
        }
    }
}


impl Walker for AssignmentTargetOrAssignmentTargetWithInitializer {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          AssignmentTargetOrAssignmentTargetWithInitializer::StaticMemberAssignmentTarget(box ref mut value) => value.walk(path, visitor),
          AssignmentTargetOrAssignmentTargetWithInitializer::ObjectAssignmentTarget(box ref mut value) => value.walk(path, visitor),
          AssignmentTargetOrAssignmentTargetWithInitializer::ComputedMemberAssignmentTarget(box ref mut value) => value.walk(path, visitor),
          AssignmentTargetOrAssignmentTargetWithInitializer::ArrayAssignmentTarget(box ref mut value) => value.walk(path, visitor),
          AssignmentTargetOrAssignmentTargetWithInitializer::AssignmentTargetIdentifier(box ref mut value) => value.walk(path, visitor),
          AssignmentTargetOrAssignmentTargetWithInitializer::AssignmentTargetWithInitializer(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum AssignmentTargetPattern {
    ObjectAssignmentTarget(Box<ObjectAssignmentTarget>),
    ArrayAssignmentTarget(Box<ArrayAssignmentTarget>)
}

impl FromJSON for AssignmentTargetPattern {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("ObjectAssignmentTarget") => Ok(AssignmentTargetPattern::ObjectAssignmentTarget(Box::new(FromJSON::import(value)?))),
           Some("ArrayAssignmentTarget") => Ok(AssignmentTargetPattern::ArrayAssignmentTarget(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of AssignmentTargetPattern".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for AssignmentTargetPattern {
    fn export(&self) -> JSON {
        match *self {
           AssignmentTargetPattern::ObjectAssignmentTarget(box ref value) => value.export(),
           AssignmentTargetPattern::ArrayAssignmentTarget(box ref value) => value.export()
        }
    }
}


impl Walker for AssignmentTargetPattern {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          AssignmentTargetPattern::ObjectAssignmentTarget(box ref mut value) => value.walk(path, visitor),
          AssignmentTargetPattern::ArrayAssignmentTarget(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum AssignmentTargetProperty {
    AssignmentTargetPropertyProperty(Box<AssignmentTargetPropertyProperty>),
    AssignmentTargetPropertyIdentifier(Box<AssignmentTargetPropertyIdentifier>)
}

impl FromJSON for AssignmentTargetProperty {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("AssignmentTargetPropertyProperty") => Ok(AssignmentTargetProperty::AssignmentTargetPropertyProperty(Box::new(FromJSON::import(value)?))),
           Some("AssignmentTargetPropertyIdentifier") => Ok(AssignmentTargetProperty::AssignmentTargetPropertyIdentifier(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of AssignmentTargetProperty".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for AssignmentTargetProperty {
    fn export(&self) -> JSON {
        match *self {
           AssignmentTargetProperty::AssignmentTargetPropertyProperty(box ref value) => value.export(),
           AssignmentTargetProperty::AssignmentTargetPropertyIdentifier(box ref value) => value.export()
        }
    }
}


impl Walker for AssignmentTargetProperty {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          AssignmentTargetProperty::AssignmentTargetPropertyProperty(box ref mut value) => value.walk(path, visitor),
          AssignmentTargetProperty::AssignmentTargetPropertyIdentifier(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum Binding {
    BindingIdentifier(Box<BindingIdentifier>),
    ArrayBinding(Box<ArrayBinding>),
    ObjectBinding(Box<ObjectBinding>)
}

impl FromJSON for Binding {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("BindingIdentifier") => Ok(Binding::BindingIdentifier(Box::new(FromJSON::import(value)?))),
           Some("ArrayBinding") => Ok(Binding::ArrayBinding(Box::new(FromJSON::import(value)?))),
           Some("ObjectBinding") => Ok(Binding::ObjectBinding(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of Binding".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for Binding {
    fn export(&self) -> JSON {
        match *self {
           Binding::BindingIdentifier(box ref value) => value.export(),
           Binding::ArrayBinding(box ref value) => value.export(),
           Binding::ObjectBinding(box ref value) => value.export()
        }
    }
}


impl Walker for Binding {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          Binding::BindingIdentifier(box ref mut value) => value.walk(path, visitor),
          Binding::ArrayBinding(box ref mut value) => value.walk(path, visitor),
          Binding::ObjectBinding(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum BindingOrBindingWithInitializer {
    ObjectBinding(Box<ObjectBinding>),
    BindingIdentifier(Box<BindingIdentifier>),
    BindingWithInitializer(Box<BindingWithInitializer>),
    ArrayBinding(Box<ArrayBinding>)
}

impl FromJSON for BindingOrBindingWithInitializer {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("ObjectBinding") => Ok(BindingOrBindingWithInitializer::ObjectBinding(Box::new(FromJSON::import(value)?))),
           Some("BindingIdentifier") => Ok(BindingOrBindingWithInitializer::BindingIdentifier(Box::new(FromJSON::import(value)?))),
           Some("BindingWithInitializer") => Ok(BindingOrBindingWithInitializer::BindingWithInitializer(Box::new(FromJSON::import(value)?))),
           Some("ArrayBinding") => Ok(BindingOrBindingWithInitializer::ArrayBinding(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of BindingOrBindingWithInitializer".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for BindingOrBindingWithInitializer {
    fn export(&self) -> JSON {
        match *self {
           BindingOrBindingWithInitializer::ObjectBinding(box ref value) => value.export(),
           BindingOrBindingWithInitializer::BindingIdentifier(box ref value) => value.export(),
           BindingOrBindingWithInitializer::BindingWithInitializer(box ref value) => value.export(),
           BindingOrBindingWithInitializer::ArrayBinding(box ref value) => value.export()
        }
    }
}


impl Walker for BindingOrBindingWithInitializer {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          BindingOrBindingWithInitializer::ObjectBinding(box ref mut value) => value.walk(path, visitor),
          BindingOrBindingWithInitializer::BindingIdentifier(box ref mut value) => value.walk(path, visitor),
          BindingOrBindingWithInitializer::BindingWithInitializer(box ref mut value) => value.walk(path, visitor),
          BindingOrBindingWithInitializer::ArrayBinding(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum BindingPattern {
    ObjectBinding(Box<ObjectBinding>),
    ArrayBinding(Box<ArrayBinding>)
}

impl FromJSON for BindingPattern {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("ObjectBinding") => Ok(BindingPattern::ObjectBinding(Box::new(FromJSON::import(value)?))),
           Some("ArrayBinding") => Ok(BindingPattern::ArrayBinding(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of BindingPattern".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for BindingPattern {
    fn export(&self) -> JSON {
        match *self {
           BindingPattern::ObjectBinding(box ref value) => value.export(),
           BindingPattern::ArrayBinding(box ref value) => value.export()
        }
    }
}


impl Walker for BindingPattern {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          BindingPattern::ObjectBinding(box ref mut value) => value.walk(path, visitor),
          BindingPattern::ArrayBinding(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum BindingProperty {
    BindingPropertyIdentifier(Box<BindingPropertyIdentifier>),
    BindingPropertyProperty(Box<BindingPropertyProperty>)
}

impl FromJSON for BindingProperty {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("BindingPropertyIdentifier") => Ok(BindingProperty::BindingPropertyIdentifier(Box::new(FromJSON::import(value)?))),
           Some("BindingPropertyProperty") => Ok(BindingProperty::BindingPropertyProperty(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of BindingProperty".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for BindingProperty {
    fn export(&self) -> JSON {
        match *self {
           BindingProperty::BindingPropertyIdentifier(box ref value) => value.export(),
           BindingProperty::BindingPropertyProperty(box ref value) => value.export()
        }
    }
}


impl Walker for BindingProperty {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          BindingProperty::BindingPropertyIdentifier(box ref mut value) => value.walk(path, visitor),
          BindingProperty::BindingPropertyProperty(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum ExportDeclaration {
    ExportDefault(Box<ExportDefault>),
    ExportAllFrom(Box<ExportAllFrom>),
    ExportFrom(Box<ExportFrom>),
    Export(Box<Export>),
    ExportLocals(Box<ExportLocals>)
}

impl FromJSON for ExportDeclaration {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("ExportDefault") => Ok(ExportDeclaration::ExportDefault(Box::new(FromJSON::import(value)?))),
           Some("ExportAllFrom") => Ok(ExportDeclaration::ExportAllFrom(Box::new(FromJSON::import(value)?))),
           Some("ExportFrom") => Ok(ExportDeclaration::ExportFrom(Box::new(FromJSON::import(value)?))),
           Some("Export") => Ok(ExportDeclaration::Export(Box::new(FromJSON::import(value)?))),
           Some("ExportLocals") => Ok(ExportDeclaration::ExportLocals(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of ExportDeclaration".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for ExportDeclaration {
    fn export(&self) -> JSON {
        match *self {
           ExportDeclaration::ExportDefault(box ref value) => value.export(),
           ExportDeclaration::ExportAllFrom(box ref value) => value.export(),
           ExportDeclaration::ExportFrom(box ref value) => value.export(),
           ExportDeclaration::Export(box ref value) => value.export(),
           ExportDeclaration::ExportLocals(box ref value) => value.export()
        }
    }
}


impl Walker for ExportDeclaration {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          ExportDeclaration::ExportDefault(box ref mut value) => value.walk(path, visitor),
          ExportDeclaration::ExportAllFrom(box ref mut value) => value.walk(path, visitor),
          ExportDeclaration::ExportFrom(box ref mut value) => value.walk(path, visitor),
          ExportDeclaration::Export(box ref mut value) => value.walk(path, visitor),
          ExportDeclaration::ExportLocals(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum Expression {
    IdentifierExpression(Box<IdentifierExpression>),
    ComputedMemberExpression(Box<ComputedMemberExpression>),
    NewTargetExpression(Box<NewTargetExpression>),
    YieldStarExpression(Box<YieldStarExpression>),
    LiteralBooleanExpression(Box<LiteralBooleanExpression>),
    ThisExpression(Box<ThisExpression>),
    AwaitExpression(Box<AwaitExpression>),
    ArrowExpression(Box<ArrowExpression>),
    LiteralInfinityExpression(Box<LiteralInfinityExpression>),
    LiteralStringExpression(Box<LiteralStringExpression>),
    ClassExpression(Box<ClassExpression>),
    CallExpression(Box<CallExpression>),
    FunctionExpression(Box<FunctionExpression>),
    LiteralNullExpression(Box<LiteralNullExpression>),
    LiteralRegExpExpression(Box<LiteralRegExpExpression>),
    ObjectExpression(Box<ObjectExpression>),
    YieldExpression(Box<YieldExpression>),
    NewExpression(Box<NewExpression>),
    ArrayExpression(Box<ArrayExpression>),
    UpdateExpression(Box<UpdateExpression>),
    CompoundAssignmentExpression(Box<CompoundAssignmentExpression>),
    UnaryExpression(Box<UnaryExpression>),
    TemplateExpression(Box<TemplateExpression>),
    StaticMemberExpression(Box<StaticMemberExpression>),
    BinaryExpression(Box<BinaryExpression>),
    ConditionalExpression(Box<ConditionalExpression>),
    AssignmentExpression(Box<AssignmentExpression>),
    LiteralNumericExpression(Box<LiteralNumericExpression>)
}

impl FromJSON for Expression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("IdentifierExpression") => Ok(Expression::IdentifierExpression(Box::new(FromJSON::import(value)?))),
           Some("ComputedMemberExpression") => Ok(Expression::ComputedMemberExpression(Box::new(FromJSON::import(value)?))),
           Some("NewTargetExpression") => Ok(Expression::NewTargetExpression(Box::new(FromJSON::import(value)?))),
           Some("YieldStarExpression") => Ok(Expression::YieldStarExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralBooleanExpression") => Ok(Expression::LiteralBooleanExpression(Box::new(FromJSON::import(value)?))),
           Some("ThisExpression") => Ok(Expression::ThisExpression(Box::new(FromJSON::import(value)?))),
           Some("AwaitExpression") => Ok(Expression::AwaitExpression(Box::new(FromJSON::import(value)?))),
           Some("ArrowExpression") => Ok(Expression::ArrowExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralInfinityExpression") => Ok(Expression::LiteralInfinityExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralStringExpression") => Ok(Expression::LiteralStringExpression(Box::new(FromJSON::import(value)?))),
           Some("ClassExpression") => Ok(Expression::ClassExpression(Box::new(FromJSON::import(value)?))),
           Some("CallExpression") => Ok(Expression::CallExpression(Box::new(FromJSON::import(value)?))),
           Some("FunctionExpression") => Ok(Expression::FunctionExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralNullExpression") => Ok(Expression::LiteralNullExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralRegExpExpression") => Ok(Expression::LiteralRegExpExpression(Box::new(FromJSON::import(value)?))),
           Some("ObjectExpression") => Ok(Expression::ObjectExpression(Box::new(FromJSON::import(value)?))),
           Some("YieldExpression") => Ok(Expression::YieldExpression(Box::new(FromJSON::import(value)?))),
           Some("NewExpression") => Ok(Expression::NewExpression(Box::new(FromJSON::import(value)?))),
           Some("ArrayExpression") => Ok(Expression::ArrayExpression(Box::new(FromJSON::import(value)?))),
           Some("UpdateExpression") => Ok(Expression::UpdateExpression(Box::new(FromJSON::import(value)?))),
           Some("CompoundAssignmentExpression") => Ok(Expression::CompoundAssignmentExpression(Box::new(FromJSON::import(value)?))),
           Some("UnaryExpression") => Ok(Expression::UnaryExpression(Box::new(FromJSON::import(value)?))),
           Some("TemplateExpression") => Ok(Expression::TemplateExpression(Box::new(FromJSON::import(value)?))),
           Some("StaticMemberExpression") => Ok(Expression::StaticMemberExpression(Box::new(FromJSON::import(value)?))),
           Some("BinaryExpression") => Ok(Expression::BinaryExpression(Box::new(FromJSON::import(value)?))),
           Some("ConditionalExpression") => Ok(Expression::ConditionalExpression(Box::new(FromJSON::import(value)?))),
           Some("AssignmentExpression") => Ok(Expression::AssignmentExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralNumericExpression") => Ok(Expression::LiteralNumericExpression(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of Expression".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for Expression {
    fn export(&self) -> JSON {
        match *self {
           Expression::IdentifierExpression(box ref value) => value.export(),
           Expression::ComputedMemberExpression(box ref value) => value.export(),
           Expression::NewTargetExpression(box ref value) => value.export(),
           Expression::YieldStarExpression(box ref value) => value.export(),
           Expression::LiteralBooleanExpression(box ref value) => value.export(),
           Expression::ThisExpression(box ref value) => value.export(),
           Expression::AwaitExpression(box ref value) => value.export(),
           Expression::ArrowExpression(box ref value) => value.export(),
           Expression::LiteralInfinityExpression(box ref value) => value.export(),
           Expression::LiteralStringExpression(box ref value) => value.export(),
           Expression::ClassExpression(box ref value) => value.export(),
           Expression::CallExpression(box ref value) => value.export(),
           Expression::FunctionExpression(box ref value) => value.export(),
           Expression::LiteralNullExpression(box ref value) => value.export(),
           Expression::LiteralRegExpExpression(box ref value) => value.export(),
           Expression::ObjectExpression(box ref value) => value.export(),
           Expression::YieldExpression(box ref value) => value.export(),
           Expression::NewExpression(box ref value) => value.export(),
           Expression::ArrayExpression(box ref value) => value.export(),
           Expression::UpdateExpression(box ref value) => value.export(),
           Expression::CompoundAssignmentExpression(box ref value) => value.export(),
           Expression::UnaryExpression(box ref value) => value.export(),
           Expression::TemplateExpression(box ref value) => value.export(),
           Expression::StaticMemberExpression(box ref value) => value.export(),
           Expression::BinaryExpression(box ref value) => value.export(),
           Expression::ConditionalExpression(box ref value) => value.export(),
           Expression::AssignmentExpression(box ref value) => value.export(),
           Expression::LiteralNumericExpression(box ref value) => value.export()
        }
    }
}


impl Walker for Expression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          Expression::IdentifierExpression(box ref mut value) => value.walk(path, visitor),
          Expression::ComputedMemberExpression(box ref mut value) => value.walk(path, visitor),
          Expression::NewTargetExpression(box ref mut value) => value.walk(path, visitor),
          Expression::YieldStarExpression(box ref mut value) => value.walk(path, visitor),
          Expression::LiteralBooleanExpression(box ref mut value) => value.walk(path, visitor),
          Expression::ThisExpression(box ref mut value) => value.walk(path, visitor),
          Expression::AwaitExpression(box ref mut value) => value.walk(path, visitor),
          Expression::ArrowExpression(box ref mut value) => value.walk(path, visitor),
          Expression::LiteralInfinityExpression(box ref mut value) => value.walk(path, visitor),
          Expression::LiteralStringExpression(box ref mut value) => value.walk(path, visitor),
          Expression::ClassExpression(box ref mut value) => value.walk(path, visitor),
          Expression::CallExpression(box ref mut value) => value.walk(path, visitor),
          Expression::FunctionExpression(box ref mut value) => value.walk(path, visitor),
          Expression::LiteralNullExpression(box ref mut value) => value.walk(path, visitor),
          Expression::LiteralRegExpExpression(box ref mut value) => value.walk(path, visitor),
          Expression::ObjectExpression(box ref mut value) => value.walk(path, visitor),
          Expression::YieldExpression(box ref mut value) => value.walk(path, visitor),
          Expression::NewExpression(box ref mut value) => value.walk(path, visitor),
          Expression::ArrayExpression(box ref mut value) => value.walk(path, visitor),
          Expression::UpdateExpression(box ref mut value) => value.walk(path, visitor),
          Expression::CompoundAssignmentExpression(box ref mut value) => value.walk(path, visitor),
          Expression::UnaryExpression(box ref mut value) => value.walk(path, visitor),
          Expression::TemplateExpression(box ref mut value) => value.walk(path, visitor),
          Expression::StaticMemberExpression(box ref mut value) => value.walk(path, visitor),
          Expression::BinaryExpression(box ref mut value) => value.walk(path, visitor),
          Expression::ConditionalExpression(box ref mut value) => value.walk(path, visitor),
          Expression::AssignmentExpression(box ref mut value) => value.walk(path, visitor),
          Expression::LiteralNumericExpression(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum ExpressionOrSuper {
    BinaryExpression(Box<BinaryExpression>),
    StaticMemberExpression(Box<StaticMemberExpression>),
    TemplateExpression(Box<TemplateExpression>),
    YieldExpression(Box<YieldExpression>),
    NewTargetExpression(Box<NewTargetExpression>),
    UpdateExpression(Box<UpdateExpression>),
    LiteralStringExpression(Box<LiteralStringExpression>),
    ObjectExpression(Box<ObjectExpression>),
    LiteralInfinityExpression(Box<LiteralInfinityExpression>),
    LiteralBooleanExpression(Box<LiteralBooleanExpression>),
    CallExpression(Box<CallExpression>),
    AwaitExpression(Box<AwaitExpression>),
    Super(Box<Super>),
    LiteralNullExpression(Box<LiteralNullExpression>),
    ClassExpression(Box<ClassExpression>),
    ArrayExpression(Box<ArrayExpression>),
    FunctionExpression(Box<FunctionExpression>),
    IdentifierExpression(Box<IdentifierExpression>),
    YieldStarExpression(Box<YieldStarExpression>),
    ComputedMemberExpression(Box<ComputedMemberExpression>),
    UnaryExpression(Box<UnaryExpression>),
    ConditionalExpression(Box<ConditionalExpression>),
    LiteralNumericExpression(Box<LiteralNumericExpression>),
    AssignmentExpression(Box<AssignmentExpression>),
    ArrowExpression(Box<ArrowExpression>),
    NewExpression(Box<NewExpression>),
    LiteralRegExpExpression(Box<LiteralRegExpExpression>),
    ThisExpression(Box<ThisExpression>),
    CompoundAssignmentExpression(Box<CompoundAssignmentExpression>)
}

impl FromJSON for ExpressionOrSuper {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("BinaryExpression") => Ok(ExpressionOrSuper::BinaryExpression(Box::new(FromJSON::import(value)?))),
           Some("StaticMemberExpression") => Ok(ExpressionOrSuper::StaticMemberExpression(Box::new(FromJSON::import(value)?))),
           Some("TemplateExpression") => Ok(ExpressionOrSuper::TemplateExpression(Box::new(FromJSON::import(value)?))),
           Some("YieldExpression") => Ok(ExpressionOrSuper::YieldExpression(Box::new(FromJSON::import(value)?))),
           Some("NewTargetExpression") => Ok(ExpressionOrSuper::NewTargetExpression(Box::new(FromJSON::import(value)?))),
           Some("UpdateExpression") => Ok(ExpressionOrSuper::UpdateExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralStringExpression") => Ok(ExpressionOrSuper::LiteralStringExpression(Box::new(FromJSON::import(value)?))),
           Some("ObjectExpression") => Ok(ExpressionOrSuper::ObjectExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralInfinityExpression") => Ok(ExpressionOrSuper::LiteralInfinityExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralBooleanExpression") => Ok(ExpressionOrSuper::LiteralBooleanExpression(Box::new(FromJSON::import(value)?))),
           Some("CallExpression") => Ok(ExpressionOrSuper::CallExpression(Box::new(FromJSON::import(value)?))),
           Some("AwaitExpression") => Ok(ExpressionOrSuper::AwaitExpression(Box::new(FromJSON::import(value)?))),
           Some("Super") => Ok(ExpressionOrSuper::Super(Box::new(FromJSON::import(value)?))),
           Some("LiteralNullExpression") => Ok(ExpressionOrSuper::LiteralNullExpression(Box::new(FromJSON::import(value)?))),
           Some("ClassExpression") => Ok(ExpressionOrSuper::ClassExpression(Box::new(FromJSON::import(value)?))),
           Some("ArrayExpression") => Ok(ExpressionOrSuper::ArrayExpression(Box::new(FromJSON::import(value)?))),
           Some("FunctionExpression") => Ok(ExpressionOrSuper::FunctionExpression(Box::new(FromJSON::import(value)?))),
           Some("IdentifierExpression") => Ok(ExpressionOrSuper::IdentifierExpression(Box::new(FromJSON::import(value)?))),
           Some("YieldStarExpression") => Ok(ExpressionOrSuper::YieldStarExpression(Box::new(FromJSON::import(value)?))),
           Some("ComputedMemberExpression") => Ok(ExpressionOrSuper::ComputedMemberExpression(Box::new(FromJSON::import(value)?))),
           Some("UnaryExpression") => Ok(ExpressionOrSuper::UnaryExpression(Box::new(FromJSON::import(value)?))),
           Some("ConditionalExpression") => Ok(ExpressionOrSuper::ConditionalExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralNumericExpression") => Ok(ExpressionOrSuper::LiteralNumericExpression(Box::new(FromJSON::import(value)?))),
           Some("AssignmentExpression") => Ok(ExpressionOrSuper::AssignmentExpression(Box::new(FromJSON::import(value)?))),
           Some("ArrowExpression") => Ok(ExpressionOrSuper::ArrowExpression(Box::new(FromJSON::import(value)?))),
           Some("NewExpression") => Ok(ExpressionOrSuper::NewExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralRegExpExpression") => Ok(ExpressionOrSuper::LiteralRegExpExpression(Box::new(FromJSON::import(value)?))),
           Some("ThisExpression") => Ok(ExpressionOrSuper::ThisExpression(Box::new(FromJSON::import(value)?))),
           Some("CompoundAssignmentExpression") => Ok(ExpressionOrSuper::CompoundAssignmentExpression(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of ExpressionOrSuper".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for ExpressionOrSuper {
    fn export(&self) -> JSON {
        match *self {
           ExpressionOrSuper::BinaryExpression(box ref value) => value.export(),
           ExpressionOrSuper::StaticMemberExpression(box ref value) => value.export(),
           ExpressionOrSuper::TemplateExpression(box ref value) => value.export(),
           ExpressionOrSuper::YieldExpression(box ref value) => value.export(),
           ExpressionOrSuper::NewTargetExpression(box ref value) => value.export(),
           ExpressionOrSuper::UpdateExpression(box ref value) => value.export(),
           ExpressionOrSuper::LiteralStringExpression(box ref value) => value.export(),
           ExpressionOrSuper::ObjectExpression(box ref value) => value.export(),
           ExpressionOrSuper::LiteralInfinityExpression(box ref value) => value.export(),
           ExpressionOrSuper::LiteralBooleanExpression(box ref value) => value.export(),
           ExpressionOrSuper::CallExpression(box ref value) => value.export(),
           ExpressionOrSuper::AwaitExpression(box ref value) => value.export(),
           ExpressionOrSuper::Super(box ref value) => value.export(),
           ExpressionOrSuper::LiteralNullExpression(box ref value) => value.export(),
           ExpressionOrSuper::ClassExpression(box ref value) => value.export(),
           ExpressionOrSuper::ArrayExpression(box ref value) => value.export(),
           ExpressionOrSuper::FunctionExpression(box ref value) => value.export(),
           ExpressionOrSuper::IdentifierExpression(box ref value) => value.export(),
           ExpressionOrSuper::YieldStarExpression(box ref value) => value.export(),
           ExpressionOrSuper::ComputedMemberExpression(box ref value) => value.export(),
           ExpressionOrSuper::UnaryExpression(box ref value) => value.export(),
           ExpressionOrSuper::ConditionalExpression(box ref value) => value.export(),
           ExpressionOrSuper::LiteralNumericExpression(box ref value) => value.export(),
           ExpressionOrSuper::AssignmentExpression(box ref value) => value.export(),
           ExpressionOrSuper::ArrowExpression(box ref value) => value.export(),
           ExpressionOrSuper::NewExpression(box ref value) => value.export(),
           ExpressionOrSuper::LiteralRegExpExpression(box ref value) => value.export(),
           ExpressionOrSuper::ThisExpression(box ref value) => value.export(),
           ExpressionOrSuper::CompoundAssignmentExpression(box ref value) => value.export()
        }
    }
}


impl Walker for ExpressionOrSuper {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          ExpressionOrSuper::BinaryExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::StaticMemberExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::TemplateExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::YieldExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::NewTargetExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::UpdateExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::LiteralStringExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::ObjectExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::LiteralInfinityExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::LiteralBooleanExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::CallExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::AwaitExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::Super(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::LiteralNullExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::ClassExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::ArrayExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::FunctionExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::IdentifierExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::YieldStarExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::ComputedMemberExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::UnaryExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::ConditionalExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::LiteralNumericExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::AssignmentExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::ArrowExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::NewExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::LiteralRegExpExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::ThisExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrSuper::CompoundAssignmentExpression(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum ExpressionOrTemplateElement {
    IdentifierExpression(Box<IdentifierExpression>),
    StaticMemberExpression(Box<StaticMemberExpression>),
    LiteralBooleanExpression(Box<LiteralBooleanExpression>),
    FunctionExpression(Box<FunctionExpression>),
    AwaitExpression(Box<AwaitExpression>),
    ArrowExpression(Box<ArrowExpression>),
    NewExpression(Box<NewExpression>),
    LiteralStringExpression(Box<LiteralStringExpression>),
    UpdateExpression(Box<UpdateExpression>),
    YieldStarExpression(Box<YieldStarExpression>),
    ArrayExpression(Box<ArrayExpression>),
    LiteralNullExpression(Box<LiteralNullExpression>),
    ObjectExpression(Box<ObjectExpression>),
    CompoundAssignmentExpression(Box<CompoundAssignmentExpression>),
    TemplateElement(Box<TemplateElement>),
    LiteralRegExpExpression(Box<LiteralRegExpExpression>),
    NewTargetExpression(Box<NewTargetExpression>),
    YieldExpression(Box<YieldExpression>),
    ThisExpression(Box<ThisExpression>),
    LiteralNumericExpression(Box<LiteralNumericExpression>),
    TemplateExpression(Box<TemplateExpression>),
    UnaryExpression(Box<UnaryExpression>),
    CallExpression(Box<CallExpression>),
    ClassExpression(Box<ClassExpression>),
    ComputedMemberExpression(Box<ComputedMemberExpression>),
    AssignmentExpression(Box<AssignmentExpression>),
    BinaryExpression(Box<BinaryExpression>),
    ConditionalExpression(Box<ConditionalExpression>),
    LiteralInfinityExpression(Box<LiteralInfinityExpression>)
}

impl FromJSON for ExpressionOrTemplateElement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("IdentifierExpression") => Ok(ExpressionOrTemplateElement::IdentifierExpression(Box::new(FromJSON::import(value)?))),
           Some("StaticMemberExpression") => Ok(ExpressionOrTemplateElement::StaticMemberExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralBooleanExpression") => Ok(ExpressionOrTemplateElement::LiteralBooleanExpression(Box::new(FromJSON::import(value)?))),
           Some("FunctionExpression") => Ok(ExpressionOrTemplateElement::FunctionExpression(Box::new(FromJSON::import(value)?))),
           Some("AwaitExpression") => Ok(ExpressionOrTemplateElement::AwaitExpression(Box::new(FromJSON::import(value)?))),
           Some("ArrowExpression") => Ok(ExpressionOrTemplateElement::ArrowExpression(Box::new(FromJSON::import(value)?))),
           Some("NewExpression") => Ok(ExpressionOrTemplateElement::NewExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralStringExpression") => Ok(ExpressionOrTemplateElement::LiteralStringExpression(Box::new(FromJSON::import(value)?))),
           Some("UpdateExpression") => Ok(ExpressionOrTemplateElement::UpdateExpression(Box::new(FromJSON::import(value)?))),
           Some("YieldStarExpression") => Ok(ExpressionOrTemplateElement::YieldStarExpression(Box::new(FromJSON::import(value)?))),
           Some("ArrayExpression") => Ok(ExpressionOrTemplateElement::ArrayExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralNullExpression") => Ok(ExpressionOrTemplateElement::LiteralNullExpression(Box::new(FromJSON::import(value)?))),
           Some("ObjectExpression") => Ok(ExpressionOrTemplateElement::ObjectExpression(Box::new(FromJSON::import(value)?))),
           Some("CompoundAssignmentExpression") => Ok(ExpressionOrTemplateElement::CompoundAssignmentExpression(Box::new(FromJSON::import(value)?))),
           Some("TemplateElement") => Ok(ExpressionOrTemplateElement::TemplateElement(Box::new(FromJSON::import(value)?))),
           Some("LiteralRegExpExpression") => Ok(ExpressionOrTemplateElement::LiteralRegExpExpression(Box::new(FromJSON::import(value)?))),
           Some("NewTargetExpression") => Ok(ExpressionOrTemplateElement::NewTargetExpression(Box::new(FromJSON::import(value)?))),
           Some("YieldExpression") => Ok(ExpressionOrTemplateElement::YieldExpression(Box::new(FromJSON::import(value)?))),
           Some("ThisExpression") => Ok(ExpressionOrTemplateElement::ThisExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralNumericExpression") => Ok(ExpressionOrTemplateElement::LiteralNumericExpression(Box::new(FromJSON::import(value)?))),
           Some("TemplateExpression") => Ok(ExpressionOrTemplateElement::TemplateExpression(Box::new(FromJSON::import(value)?))),
           Some("UnaryExpression") => Ok(ExpressionOrTemplateElement::UnaryExpression(Box::new(FromJSON::import(value)?))),
           Some("CallExpression") => Ok(ExpressionOrTemplateElement::CallExpression(Box::new(FromJSON::import(value)?))),
           Some("ClassExpression") => Ok(ExpressionOrTemplateElement::ClassExpression(Box::new(FromJSON::import(value)?))),
           Some("ComputedMemberExpression") => Ok(ExpressionOrTemplateElement::ComputedMemberExpression(Box::new(FromJSON::import(value)?))),
           Some("AssignmentExpression") => Ok(ExpressionOrTemplateElement::AssignmentExpression(Box::new(FromJSON::import(value)?))),
           Some("BinaryExpression") => Ok(ExpressionOrTemplateElement::BinaryExpression(Box::new(FromJSON::import(value)?))),
           Some("ConditionalExpression") => Ok(ExpressionOrTemplateElement::ConditionalExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralInfinityExpression") => Ok(ExpressionOrTemplateElement::LiteralInfinityExpression(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of ExpressionOrTemplateElement".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for ExpressionOrTemplateElement {
    fn export(&self) -> JSON {
        match *self {
           ExpressionOrTemplateElement::IdentifierExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::StaticMemberExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::LiteralBooleanExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::FunctionExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::AwaitExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::ArrowExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::NewExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::LiteralStringExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::UpdateExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::YieldStarExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::ArrayExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::LiteralNullExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::ObjectExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::CompoundAssignmentExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::TemplateElement(box ref value) => value.export(),
           ExpressionOrTemplateElement::LiteralRegExpExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::NewTargetExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::YieldExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::ThisExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::LiteralNumericExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::TemplateExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::UnaryExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::CallExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::ClassExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::ComputedMemberExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::AssignmentExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::BinaryExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::ConditionalExpression(box ref value) => value.export(),
           ExpressionOrTemplateElement::LiteralInfinityExpression(box ref value) => value.export()
        }
    }
}


impl Walker for ExpressionOrTemplateElement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          ExpressionOrTemplateElement::IdentifierExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::StaticMemberExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::LiteralBooleanExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::FunctionExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::AwaitExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::ArrowExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::NewExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::LiteralStringExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::UpdateExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::YieldStarExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::ArrayExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::LiteralNullExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::ObjectExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::CompoundAssignmentExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::TemplateElement(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::LiteralRegExpExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::NewTargetExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::YieldExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::ThisExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::LiteralNumericExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::TemplateExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::UnaryExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::CallExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::ClassExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::ComputedMemberExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::AssignmentExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::BinaryExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::ConditionalExpression(box ref mut value) => value.walk(path, visitor),
          ExpressionOrTemplateElement::LiteralInfinityExpression(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum ForInOfBindingOrAssignmentTarget {
    StaticMemberAssignmentTarget(Box<StaticMemberAssignmentTarget>),
    ObjectAssignmentTarget(Box<ObjectAssignmentTarget>),
    ComputedMemberAssignmentTarget(Box<ComputedMemberAssignmentTarget>),
    AssignmentTargetIdentifier(Box<AssignmentTargetIdentifier>),
    ForInOfBinding(Box<ForInOfBinding>),
    ArrayAssignmentTarget(Box<ArrayAssignmentTarget>)
}

impl FromJSON for ForInOfBindingOrAssignmentTarget {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("StaticMemberAssignmentTarget") => Ok(ForInOfBindingOrAssignmentTarget::StaticMemberAssignmentTarget(Box::new(FromJSON::import(value)?))),
           Some("ObjectAssignmentTarget") => Ok(ForInOfBindingOrAssignmentTarget::ObjectAssignmentTarget(Box::new(FromJSON::import(value)?))),
           Some("ComputedMemberAssignmentTarget") => Ok(ForInOfBindingOrAssignmentTarget::ComputedMemberAssignmentTarget(Box::new(FromJSON::import(value)?))),
           Some("AssignmentTargetIdentifier") => Ok(ForInOfBindingOrAssignmentTarget::AssignmentTargetIdentifier(Box::new(FromJSON::import(value)?))),
           Some("ForInOfBinding") => Ok(ForInOfBindingOrAssignmentTarget::ForInOfBinding(Box::new(FromJSON::import(value)?))),
           Some("ArrayAssignmentTarget") => Ok(ForInOfBindingOrAssignmentTarget::ArrayAssignmentTarget(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of ForInOfBindingOrAssignmentTarget".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for ForInOfBindingOrAssignmentTarget {
    fn export(&self) -> JSON {
        match *self {
           ForInOfBindingOrAssignmentTarget::StaticMemberAssignmentTarget(box ref value) => value.export(),
           ForInOfBindingOrAssignmentTarget::ObjectAssignmentTarget(box ref value) => value.export(),
           ForInOfBindingOrAssignmentTarget::ComputedMemberAssignmentTarget(box ref value) => value.export(),
           ForInOfBindingOrAssignmentTarget::AssignmentTargetIdentifier(box ref value) => value.export(),
           ForInOfBindingOrAssignmentTarget::ForInOfBinding(box ref value) => value.export(),
           ForInOfBindingOrAssignmentTarget::ArrayAssignmentTarget(box ref value) => value.export()
        }
    }
}


impl Walker for ForInOfBindingOrAssignmentTarget {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          ForInOfBindingOrAssignmentTarget::StaticMemberAssignmentTarget(box ref mut value) => value.walk(path, visitor),
          ForInOfBindingOrAssignmentTarget::ObjectAssignmentTarget(box ref mut value) => value.walk(path, visitor),
          ForInOfBindingOrAssignmentTarget::ComputedMemberAssignmentTarget(box ref mut value) => value.walk(path, visitor),
          ForInOfBindingOrAssignmentTarget::AssignmentTargetIdentifier(box ref mut value) => value.walk(path, visitor),
          ForInOfBindingOrAssignmentTarget::ForInOfBinding(box ref mut value) => value.walk(path, visitor),
          ForInOfBindingOrAssignmentTarget::ArrayAssignmentTarget(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum FunctionBodyOrExpression {
    StaticMemberExpression(Box<StaticMemberExpression>),
    LiteralInfinityExpression(Box<LiteralInfinityExpression>),
    TemplateExpression(Box<TemplateExpression>),
    CallExpression(Box<CallExpression>),
    ThisExpression(Box<ThisExpression>),
    YieldStarExpression(Box<YieldStarExpression>),
    FunctionBody(Box<FunctionBody>),
    LiteralNullExpression(Box<LiteralNullExpression>),
    UnaryExpression(Box<UnaryExpression>),
    LiteralRegExpExpression(Box<LiteralRegExpExpression>),
    AssignmentExpression(Box<AssignmentExpression>),
    ArrayExpression(Box<ArrayExpression>),
    IdentifierExpression(Box<IdentifierExpression>),
    ConditionalExpression(Box<ConditionalExpression>),
    LiteralNumericExpression(Box<LiteralNumericExpression>),
    FunctionExpression(Box<FunctionExpression>),
    LiteralStringExpression(Box<LiteralStringExpression>),
    LiteralBooleanExpression(Box<LiteralBooleanExpression>),
    UpdateExpression(Box<UpdateExpression>),
    ComputedMemberExpression(Box<ComputedMemberExpression>),
    BinaryExpression(Box<BinaryExpression>),
    ClassExpression(Box<ClassExpression>),
    YieldExpression(Box<YieldExpression>),
    NewExpression(Box<NewExpression>),
    ArrowExpression(Box<ArrowExpression>),
    AwaitExpression(Box<AwaitExpression>),
    CompoundAssignmentExpression(Box<CompoundAssignmentExpression>),
    NewTargetExpression(Box<NewTargetExpression>),
    ObjectExpression(Box<ObjectExpression>)
}

impl FromJSON for FunctionBodyOrExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("StaticMemberExpression") => Ok(FunctionBodyOrExpression::StaticMemberExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralInfinityExpression") => Ok(FunctionBodyOrExpression::LiteralInfinityExpression(Box::new(FromJSON::import(value)?))),
           Some("TemplateExpression") => Ok(FunctionBodyOrExpression::TemplateExpression(Box::new(FromJSON::import(value)?))),
           Some("CallExpression") => Ok(FunctionBodyOrExpression::CallExpression(Box::new(FromJSON::import(value)?))),
           Some("ThisExpression") => Ok(FunctionBodyOrExpression::ThisExpression(Box::new(FromJSON::import(value)?))),
           Some("YieldStarExpression") => Ok(FunctionBodyOrExpression::YieldStarExpression(Box::new(FromJSON::import(value)?))),
           Some("FunctionBody") => Ok(FunctionBodyOrExpression::FunctionBody(Box::new(FromJSON::import(value)?))),
           Some("LiteralNullExpression") => Ok(FunctionBodyOrExpression::LiteralNullExpression(Box::new(FromJSON::import(value)?))),
           Some("UnaryExpression") => Ok(FunctionBodyOrExpression::UnaryExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralRegExpExpression") => Ok(FunctionBodyOrExpression::LiteralRegExpExpression(Box::new(FromJSON::import(value)?))),
           Some("AssignmentExpression") => Ok(FunctionBodyOrExpression::AssignmentExpression(Box::new(FromJSON::import(value)?))),
           Some("ArrayExpression") => Ok(FunctionBodyOrExpression::ArrayExpression(Box::new(FromJSON::import(value)?))),
           Some("IdentifierExpression") => Ok(FunctionBodyOrExpression::IdentifierExpression(Box::new(FromJSON::import(value)?))),
           Some("ConditionalExpression") => Ok(FunctionBodyOrExpression::ConditionalExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralNumericExpression") => Ok(FunctionBodyOrExpression::LiteralNumericExpression(Box::new(FromJSON::import(value)?))),
           Some("FunctionExpression") => Ok(FunctionBodyOrExpression::FunctionExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralStringExpression") => Ok(FunctionBodyOrExpression::LiteralStringExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralBooleanExpression") => Ok(FunctionBodyOrExpression::LiteralBooleanExpression(Box::new(FromJSON::import(value)?))),
           Some("UpdateExpression") => Ok(FunctionBodyOrExpression::UpdateExpression(Box::new(FromJSON::import(value)?))),
           Some("ComputedMemberExpression") => Ok(FunctionBodyOrExpression::ComputedMemberExpression(Box::new(FromJSON::import(value)?))),
           Some("BinaryExpression") => Ok(FunctionBodyOrExpression::BinaryExpression(Box::new(FromJSON::import(value)?))),
           Some("ClassExpression") => Ok(FunctionBodyOrExpression::ClassExpression(Box::new(FromJSON::import(value)?))),
           Some("YieldExpression") => Ok(FunctionBodyOrExpression::YieldExpression(Box::new(FromJSON::import(value)?))),
           Some("NewExpression") => Ok(FunctionBodyOrExpression::NewExpression(Box::new(FromJSON::import(value)?))),
           Some("ArrowExpression") => Ok(FunctionBodyOrExpression::ArrowExpression(Box::new(FromJSON::import(value)?))),
           Some("AwaitExpression") => Ok(FunctionBodyOrExpression::AwaitExpression(Box::new(FromJSON::import(value)?))),
           Some("CompoundAssignmentExpression") => Ok(FunctionBodyOrExpression::CompoundAssignmentExpression(Box::new(FromJSON::import(value)?))),
           Some("NewTargetExpression") => Ok(FunctionBodyOrExpression::NewTargetExpression(Box::new(FromJSON::import(value)?))),
           Some("ObjectExpression") => Ok(FunctionBodyOrExpression::ObjectExpression(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of FunctionBodyOrExpression".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for FunctionBodyOrExpression {
    fn export(&self) -> JSON {
        match *self {
           FunctionBodyOrExpression::StaticMemberExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::LiteralInfinityExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::TemplateExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::CallExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::ThisExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::YieldStarExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::FunctionBody(box ref value) => value.export(),
           FunctionBodyOrExpression::LiteralNullExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::UnaryExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::LiteralRegExpExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::AssignmentExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::ArrayExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::IdentifierExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::ConditionalExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::LiteralNumericExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::FunctionExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::LiteralStringExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::LiteralBooleanExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::UpdateExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::ComputedMemberExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::BinaryExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::ClassExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::YieldExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::NewExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::ArrowExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::AwaitExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::CompoundAssignmentExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::NewTargetExpression(box ref value) => value.export(),
           FunctionBodyOrExpression::ObjectExpression(box ref value) => value.export()
        }
    }
}


impl Walker for FunctionBodyOrExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          FunctionBodyOrExpression::StaticMemberExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::LiteralInfinityExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::TemplateExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::CallExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::ThisExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::YieldStarExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::FunctionBody(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::LiteralNullExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::UnaryExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::LiteralRegExpExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::AssignmentExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::ArrayExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::IdentifierExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::ConditionalExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::LiteralNumericExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::FunctionExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::LiteralStringExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::LiteralBooleanExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::UpdateExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::ComputedMemberExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::BinaryExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::ClassExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::YieldExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::NewExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::ArrowExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::AwaitExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::CompoundAssignmentExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::NewTargetExpression(box ref mut value) => value.walk(path, visitor),
          FunctionBodyOrExpression::ObjectExpression(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum FunctionDeclarationOrClassDeclarationOrExpression {
    TemplateExpression(Box<TemplateExpression>),
    ClassDeclaration(Box<ClassDeclaration>),
    AssignmentExpression(Box<AssignmentExpression>),
    StaticMemberExpression(Box<StaticMemberExpression>),
    AwaitExpression(Box<AwaitExpression>),
    ObjectExpression(Box<ObjectExpression>),
    ConditionalExpression(Box<ConditionalExpression>),
    ThisExpression(Box<ThisExpression>),
    LiteralNullExpression(Box<LiteralNullExpression>),
    ComputedMemberExpression(Box<ComputedMemberExpression>),
    LiteralNumericExpression(Box<LiteralNumericExpression>),
    NewTargetExpression(Box<NewTargetExpression>),
    NewExpression(Box<NewExpression>),
    CompoundAssignmentExpression(Box<CompoundAssignmentExpression>),
    YieldExpression(Box<YieldExpression>),
    LiteralInfinityExpression(Box<LiteralInfinityExpression>),
    CallExpression(Box<CallExpression>),
    FunctionDeclaration(Box<FunctionDeclaration>),
    ClassExpression(Box<ClassExpression>),
    LiteralBooleanExpression(Box<LiteralBooleanExpression>),
    IdentifierExpression(Box<IdentifierExpression>),
    UpdateExpression(Box<UpdateExpression>),
    LiteralRegExpExpression(Box<LiteralRegExpExpression>),
    ArrowExpression(Box<ArrowExpression>),
    LiteralStringExpression(Box<LiteralStringExpression>),
    YieldStarExpression(Box<YieldStarExpression>),
    BinaryExpression(Box<BinaryExpression>),
    ArrayExpression(Box<ArrayExpression>),
    FunctionExpression(Box<FunctionExpression>),
    UnaryExpression(Box<UnaryExpression>)
}

impl FromJSON for FunctionDeclarationOrClassDeclarationOrExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("TemplateExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::TemplateExpression(Box::new(FromJSON::import(value)?))),
           Some("ClassDeclaration") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::ClassDeclaration(Box::new(FromJSON::import(value)?))),
           Some("AssignmentExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::AssignmentExpression(Box::new(FromJSON::import(value)?))),
           Some("StaticMemberExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::StaticMemberExpression(Box::new(FromJSON::import(value)?))),
           Some("AwaitExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::AwaitExpression(Box::new(FromJSON::import(value)?))),
           Some("ObjectExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::ObjectExpression(Box::new(FromJSON::import(value)?))),
           Some("ConditionalExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::ConditionalExpression(Box::new(FromJSON::import(value)?))),
           Some("ThisExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::ThisExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralNullExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::LiteralNullExpression(Box::new(FromJSON::import(value)?))),
           Some("ComputedMemberExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::ComputedMemberExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralNumericExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::LiteralNumericExpression(Box::new(FromJSON::import(value)?))),
           Some("NewTargetExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::NewTargetExpression(Box::new(FromJSON::import(value)?))),
           Some("NewExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::NewExpression(Box::new(FromJSON::import(value)?))),
           Some("CompoundAssignmentExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::CompoundAssignmentExpression(Box::new(FromJSON::import(value)?))),
           Some("YieldExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::YieldExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralInfinityExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::LiteralInfinityExpression(Box::new(FromJSON::import(value)?))),
           Some("CallExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::CallExpression(Box::new(FromJSON::import(value)?))),
           Some("FunctionDeclaration") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::FunctionDeclaration(Box::new(FromJSON::import(value)?))),
           Some("ClassExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::ClassExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralBooleanExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::LiteralBooleanExpression(Box::new(FromJSON::import(value)?))),
           Some("IdentifierExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::IdentifierExpression(Box::new(FromJSON::import(value)?))),
           Some("UpdateExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::UpdateExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralRegExpExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::LiteralRegExpExpression(Box::new(FromJSON::import(value)?))),
           Some("ArrowExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::ArrowExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralStringExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::LiteralStringExpression(Box::new(FromJSON::import(value)?))),
           Some("YieldStarExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::YieldStarExpression(Box::new(FromJSON::import(value)?))),
           Some("BinaryExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::BinaryExpression(Box::new(FromJSON::import(value)?))),
           Some("ArrayExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::ArrayExpression(Box::new(FromJSON::import(value)?))),
           Some("FunctionExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::FunctionExpression(Box::new(FromJSON::import(value)?))),
           Some("UnaryExpression") => Ok(FunctionDeclarationOrClassDeclarationOrExpression::UnaryExpression(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of FunctionDeclarationOrClassDeclarationOrExpression".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for FunctionDeclarationOrClassDeclarationOrExpression {
    fn export(&self) -> JSON {
        match *self {
           FunctionDeclarationOrClassDeclarationOrExpression::TemplateExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::ClassDeclaration(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::AssignmentExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::StaticMemberExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::AwaitExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::ObjectExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::ConditionalExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::ThisExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::LiteralNullExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::ComputedMemberExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::LiteralNumericExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::NewTargetExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::NewExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::CompoundAssignmentExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::YieldExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::LiteralInfinityExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::CallExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::FunctionDeclaration(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::ClassExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::LiteralBooleanExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::IdentifierExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::UpdateExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::LiteralRegExpExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::ArrowExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::LiteralStringExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::YieldStarExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::BinaryExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::ArrayExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::FunctionExpression(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrExpression::UnaryExpression(box ref value) => value.export()
        }
    }
}


impl Walker for FunctionDeclarationOrClassDeclarationOrExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          FunctionDeclarationOrClassDeclarationOrExpression::TemplateExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::ClassDeclaration(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::AssignmentExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::StaticMemberExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::AwaitExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::ObjectExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::ConditionalExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::ThisExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::LiteralNullExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::ComputedMemberExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::LiteralNumericExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::NewTargetExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::NewExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::CompoundAssignmentExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::YieldExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::LiteralInfinityExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::CallExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::FunctionDeclaration(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::ClassExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::LiteralBooleanExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::IdentifierExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::UpdateExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::LiteralRegExpExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::ArrowExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::LiteralStringExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::YieldStarExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::BinaryExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::ArrayExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::FunctionExpression(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrExpression::UnaryExpression(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum FunctionDeclarationOrClassDeclarationOrVariableDeclaration {
    ClassDeclaration(Box<ClassDeclaration>),
    FunctionDeclaration(Box<FunctionDeclaration>),
    VariableDeclaration(Box<VariableDeclaration>)
}

impl FromJSON for FunctionDeclarationOrClassDeclarationOrVariableDeclaration {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("ClassDeclaration") => Ok(FunctionDeclarationOrClassDeclarationOrVariableDeclaration::ClassDeclaration(Box::new(FromJSON::import(value)?))),
           Some("FunctionDeclaration") => Ok(FunctionDeclarationOrClassDeclarationOrVariableDeclaration::FunctionDeclaration(Box::new(FromJSON::import(value)?))),
           Some("VariableDeclaration") => Ok(FunctionDeclarationOrClassDeclarationOrVariableDeclaration::VariableDeclaration(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of FunctionDeclarationOrClassDeclarationOrVariableDeclaration".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for FunctionDeclarationOrClassDeclarationOrVariableDeclaration {
    fn export(&self) -> JSON {
        match *self {
           FunctionDeclarationOrClassDeclarationOrVariableDeclaration::ClassDeclaration(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrVariableDeclaration::FunctionDeclaration(box ref value) => value.export(),
           FunctionDeclarationOrClassDeclarationOrVariableDeclaration::VariableDeclaration(box ref value) => value.export()
        }
    }
}


impl Walker for FunctionDeclarationOrClassDeclarationOrVariableDeclaration {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          FunctionDeclarationOrClassDeclarationOrVariableDeclaration::ClassDeclaration(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrVariableDeclaration::FunctionDeclaration(box ref mut value) => value.walk(path, visitor),
          FunctionDeclarationOrClassDeclarationOrVariableDeclaration::VariableDeclaration(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum ImportDeclaration {
    ImportNamespace(Box<ImportNamespace>),
    Import(Box<Import>)
}

impl FromJSON for ImportDeclaration {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("ImportNamespace") => Ok(ImportDeclaration::ImportNamespace(Box::new(FromJSON::import(value)?))),
           Some("Import") => Ok(ImportDeclaration::Import(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of ImportDeclaration".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for ImportDeclaration {
    fn export(&self) -> JSON {
        match *self {
           ImportDeclaration::ImportNamespace(box ref value) => value.export(),
           ImportDeclaration::Import(box ref value) => value.export()
        }
    }
}


impl Walker for ImportDeclaration {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          ImportDeclaration::ImportNamespace(box ref mut value) => value.walk(path, visitor),
          ImportDeclaration::Import(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum ImportDeclarationOrExportDeclarationOrStatement {
    ClassDeclaration(Box<ClassDeclaration>),
    BreakStatement(Box<BreakStatement>),
    Export(Box<Export>),
    ExportAllFrom(Box<ExportAllFrom>),
    Import(Box<Import>),
    SwitchStatementWithDefault(Box<SwitchStatementWithDefault>),
    ContinueStatement(Box<ContinueStatement>),
    DoWhileStatement(Box<DoWhileStatement>),
    ForStatement(Box<ForStatement>),
    TryFinallyStatement(Box<TryFinallyStatement>),
    SwitchStatement(Box<SwitchStatement>),
    ReturnStatement(Box<ReturnStatement>),
    IfStatement(Box<IfStatement>),
    WithStatement(Box<WithStatement>),
    ExpressionStatement(Box<ExpressionStatement>),
    TryCatchStatement(Box<TryCatchStatement>),
    ForInStatement(Box<ForInStatement>),
    ImportNamespace(Box<ImportNamespace>),
    ExportFrom(Box<ExportFrom>),
    WhileStatement(Box<WhileStatement>),
    VariableDeclaration(Box<VariableDeclaration>),
    ThrowStatement(Box<ThrowStatement>),
    LabelledStatement(Box<LabelledStatement>),
    EmptyStatement(Box<EmptyStatement>),
    FunctionDeclaration(Box<FunctionDeclaration>),
    ForOfStatement(Box<ForOfStatement>),
    ExportLocals(Box<ExportLocals>),
    DebuggerStatement(Box<DebuggerStatement>),
    ExportDefault(Box<ExportDefault>),
    Block(Box<Block>)
}

impl FromJSON for ImportDeclarationOrExportDeclarationOrStatement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("ClassDeclaration") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ClassDeclaration(Box::new(FromJSON::import(value)?))),
           Some("BreakStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::BreakStatement(Box::new(FromJSON::import(value)?))),
           Some("Export") => Ok(ImportDeclarationOrExportDeclarationOrStatement::Export(Box::new(FromJSON::import(value)?))),
           Some("ExportAllFrom") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ExportAllFrom(Box::new(FromJSON::import(value)?))),
           Some("Import") => Ok(ImportDeclarationOrExportDeclarationOrStatement::Import(Box::new(FromJSON::import(value)?))),
           Some("SwitchStatementWithDefault") => Ok(ImportDeclarationOrExportDeclarationOrStatement::SwitchStatementWithDefault(Box::new(FromJSON::import(value)?))),
           Some("ContinueStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ContinueStatement(Box::new(FromJSON::import(value)?))),
           Some("DoWhileStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::DoWhileStatement(Box::new(FromJSON::import(value)?))),
           Some("ForStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ForStatement(Box::new(FromJSON::import(value)?))),
           Some("TryFinallyStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::TryFinallyStatement(Box::new(FromJSON::import(value)?))),
           Some("SwitchStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::SwitchStatement(Box::new(FromJSON::import(value)?))),
           Some("ReturnStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ReturnStatement(Box::new(FromJSON::import(value)?))),
           Some("IfStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::IfStatement(Box::new(FromJSON::import(value)?))),
           Some("WithStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::WithStatement(Box::new(FromJSON::import(value)?))),
           Some("ExpressionStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ExpressionStatement(Box::new(FromJSON::import(value)?))),
           Some("TryCatchStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::TryCatchStatement(Box::new(FromJSON::import(value)?))),
           Some("ForInStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ForInStatement(Box::new(FromJSON::import(value)?))),
           Some("ImportNamespace") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ImportNamespace(Box::new(FromJSON::import(value)?))),
           Some("ExportFrom") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ExportFrom(Box::new(FromJSON::import(value)?))),
           Some("WhileStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::WhileStatement(Box::new(FromJSON::import(value)?))),
           Some("VariableDeclaration") => Ok(ImportDeclarationOrExportDeclarationOrStatement::VariableDeclaration(Box::new(FromJSON::import(value)?))),
           Some("ThrowStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ThrowStatement(Box::new(FromJSON::import(value)?))),
           Some("LabelledStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::LabelledStatement(Box::new(FromJSON::import(value)?))),
           Some("EmptyStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::EmptyStatement(Box::new(FromJSON::import(value)?))),
           Some("FunctionDeclaration") => Ok(ImportDeclarationOrExportDeclarationOrStatement::FunctionDeclaration(Box::new(FromJSON::import(value)?))),
           Some("ForOfStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ForOfStatement(Box::new(FromJSON::import(value)?))),
           Some("ExportLocals") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ExportLocals(Box::new(FromJSON::import(value)?))),
           Some("DebuggerStatement") => Ok(ImportDeclarationOrExportDeclarationOrStatement::DebuggerStatement(Box::new(FromJSON::import(value)?))),
           Some("ExportDefault") => Ok(ImportDeclarationOrExportDeclarationOrStatement::ExportDefault(Box::new(FromJSON::import(value)?))),
           Some("Block") => Ok(ImportDeclarationOrExportDeclarationOrStatement::Block(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of ImportDeclarationOrExportDeclarationOrStatement".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for ImportDeclarationOrExportDeclarationOrStatement {
    fn export(&self) -> JSON {
        match *self {
           ImportDeclarationOrExportDeclarationOrStatement::ClassDeclaration(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::BreakStatement(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::Export(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::ExportAllFrom(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::Import(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::SwitchStatementWithDefault(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::ContinueStatement(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::DoWhileStatement(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::ForStatement(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::TryFinallyStatement(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::SwitchStatement(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::ReturnStatement(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::IfStatement(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::WithStatement(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::ExpressionStatement(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::TryCatchStatement(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::ForInStatement(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::ImportNamespace(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::ExportFrom(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::WhileStatement(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::VariableDeclaration(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::ThrowStatement(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::LabelledStatement(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::EmptyStatement(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::FunctionDeclaration(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::ForOfStatement(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::ExportLocals(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::DebuggerStatement(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::ExportDefault(box ref value) => value.export(),
           ImportDeclarationOrExportDeclarationOrStatement::Block(box ref value) => value.export()
        }
    }
}


impl Walker for ImportDeclarationOrExportDeclarationOrStatement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          ImportDeclarationOrExportDeclarationOrStatement::ClassDeclaration(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::BreakStatement(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::Export(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::ExportAllFrom(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::Import(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::SwitchStatementWithDefault(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::ContinueStatement(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::DoWhileStatement(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::ForStatement(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::TryFinallyStatement(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::SwitchStatement(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::ReturnStatement(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::IfStatement(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::WithStatement(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::ExpressionStatement(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::TryCatchStatement(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::ForInStatement(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::ImportNamespace(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::ExportFrom(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::WhileStatement(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::VariableDeclaration(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::ThrowStatement(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::LabelledStatement(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::EmptyStatement(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::FunctionDeclaration(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::ForOfStatement(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::ExportLocals(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::DebuggerStatement(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::ExportDefault(box ref mut value) => value.walk(path, visitor),
          ImportDeclarationOrExportDeclarationOrStatement::Block(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum IterationStatement {
    WhileStatement(Box<WhileStatement>),
    ForInStatement(Box<ForInStatement>),
    ForOfStatement(Box<ForOfStatement>),
    ForStatement(Box<ForStatement>),
    DoWhileStatement(Box<DoWhileStatement>)
}

impl FromJSON for IterationStatement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("WhileStatement") => Ok(IterationStatement::WhileStatement(Box::new(FromJSON::import(value)?))),
           Some("ForInStatement") => Ok(IterationStatement::ForInStatement(Box::new(FromJSON::import(value)?))),
           Some("ForOfStatement") => Ok(IterationStatement::ForOfStatement(Box::new(FromJSON::import(value)?))),
           Some("ForStatement") => Ok(IterationStatement::ForStatement(Box::new(FromJSON::import(value)?))),
           Some("DoWhileStatement") => Ok(IterationStatement::DoWhileStatement(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of IterationStatement".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for IterationStatement {
    fn export(&self) -> JSON {
        match *self {
           IterationStatement::WhileStatement(box ref value) => value.export(),
           IterationStatement::ForInStatement(box ref value) => value.export(),
           IterationStatement::ForOfStatement(box ref value) => value.export(),
           IterationStatement::ForStatement(box ref value) => value.export(),
           IterationStatement::DoWhileStatement(box ref value) => value.export()
        }
    }
}


impl Walker for IterationStatement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          IterationStatement::WhileStatement(box ref mut value) => value.walk(path, visitor),
          IterationStatement::ForInStatement(box ref mut value) => value.walk(path, visitor),
          IterationStatement::ForOfStatement(box ref mut value) => value.walk(path, visitor),
          IterationStatement::ForStatement(box ref mut value) => value.walk(path, visitor),
          IterationStatement::DoWhileStatement(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum Literal {
    LiteralBooleanExpression(Box<LiteralBooleanExpression>),
    LiteralStringExpression(Box<LiteralStringExpression>),
    LiteralInfinityExpression(Box<LiteralInfinityExpression>),
    LiteralNumericExpression(Box<LiteralNumericExpression>),
    LiteralNullExpression(Box<LiteralNullExpression>)
}

impl FromJSON for Literal {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("LiteralBooleanExpression") => Ok(Literal::LiteralBooleanExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralStringExpression") => Ok(Literal::LiteralStringExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralInfinityExpression") => Ok(Literal::LiteralInfinityExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralNumericExpression") => Ok(Literal::LiteralNumericExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralNullExpression") => Ok(Literal::LiteralNullExpression(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of Literal".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for Literal {
    fn export(&self) -> JSON {
        match *self {
           Literal::LiteralBooleanExpression(box ref value) => value.export(),
           Literal::LiteralStringExpression(box ref value) => value.export(),
           Literal::LiteralInfinityExpression(box ref value) => value.export(),
           Literal::LiteralNumericExpression(box ref value) => value.export(),
           Literal::LiteralNullExpression(box ref value) => value.export()
        }
    }
}


impl Walker for Literal {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          Literal::LiteralBooleanExpression(box ref mut value) => value.walk(path, visitor),
          Literal::LiteralStringExpression(box ref mut value) => value.walk(path, visitor),
          Literal::LiteralInfinityExpression(box ref mut value) => value.walk(path, visitor),
          Literal::LiteralNumericExpression(box ref mut value) => value.walk(path, visitor),
          Literal::LiteralNullExpression(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum MethodDefinition {
    Getter(Box<Getter>),
    Method(Box<Method>),
    Setter(Box<Setter>)
}

impl FromJSON for MethodDefinition {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("Getter") => Ok(MethodDefinition::Getter(Box::new(FromJSON::import(value)?))),
           Some("Method") => Ok(MethodDefinition::Method(Box::new(FromJSON::import(value)?))),
           Some("Setter") => Ok(MethodDefinition::Setter(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of MethodDefinition".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for MethodDefinition {
    fn export(&self) -> JSON {
        match *self {
           MethodDefinition::Getter(box ref value) => value.export(),
           MethodDefinition::Method(box ref value) => value.export(),
           MethodDefinition::Setter(box ref value) => value.export()
        }
    }
}


impl Walker for MethodDefinition {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          MethodDefinition::Getter(box ref mut value) => value.walk(path, visitor),
          MethodDefinition::Method(box ref mut value) => value.walk(path, visitor),
          MethodDefinition::Setter(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum ObjectProperty {
    Setter(Box<Setter>),
    Method(Box<Method>),
    Getter(Box<Getter>),
    DataProperty(Box<DataProperty>),
    ShorthandProperty(Box<ShorthandProperty>)
}

impl FromJSON for ObjectProperty {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("Setter") => Ok(ObjectProperty::Setter(Box::new(FromJSON::import(value)?))),
           Some("Method") => Ok(ObjectProperty::Method(Box::new(FromJSON::import(value)?))),
           Some("Getter") => Ok(ObjectProperty::Getter(Box::new(FromJSON::import(value)?))),
           Some("DataProperty") => Ok(ObjectProperty::DataProperty(Box::new(FromJSON::import(value)?))),
           Some("ShorthandProperty") => Ok(ObjectProperty::ShorthandProperty(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of ObjectProperty".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for ObjectProperty {
    fn export(&self) -> JSON {
        match *self {
           ObjectProperty::Setter(box ref value) => value.export(),
           ObjectProperty::Method(box ref value) => value.export(),
           ObjectProperty::Getter(box ref value) => value.export(),
           ObjectProperty::DataProperty(box ref value) => value.export(),
           ObjectProperty::ShorthandProperty(box ref value) => value.export()
        }
    }
}


impl Walker for ObjectProperty {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          ObjectProperty::Setter(box ref mut value) => value.walk(path, visitor),
          ObjectProperty::Method(box ref mut value) => value.walk(path, visitor),
          ObjectProperty::Getter(box ref mut value) => value.walk(path, visitor),
          ObjectProperty::DataProperty(box ref mut value) => value.walk(path, visitor),
          ObjectProperty::ShorthandProperty(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum Parameter {
    ObjectBinding(Box<ObjectBinding>),
    BindingIdentifier(Box<BindingIdentifier>),
    ArrayBinding(Box<ArrayBinding>),
    BindingWithInitializer(Box<BindingWithInitializer>)
}

impl FromJSON for Parameter {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("ObjectBinding") => Ok(Parameter::ObjectBinding(Box::new(FromJSON::import(value)?))),
           Some("BindingIdentifier") => Ok(Parameter::BindingIdentifier(Box::new(FromJSON::import(value)?))),
           Some("ArrayBinding") => Ok(Parameter::ArrayBinding(Box::new(FromJSON::import(value)?))),
           Some("BindingWithInitializer") => Ok(Parameter::BindingWithInitializer(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of Parameter".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for Parameter {
    fn export(&self) -> JSON {
        match *self {
           Parameter::ObjectBinding(box ref value) => value.export(),
           Parameter::BindingIdentifier(box ref value) => value.export(),
           Parameter::ArrayBinding(box ref value) => value.export(),
           Parameter::BindingWithInitializer(box ref value) => value.export()
        }
    }
}


impl Walker for Parameter {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          Parameter::ObjectBinding(box ref mut value) => value.walk(path, visitor),
          Parameter::BindingIdentifier(box ref mut value) => value.walk(path, visitor),
          Parameter::ArrayBinding(box ref mut value) => value.walk(path, visitor),
          Parameter::BindingWithInitializer(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum Program {
    Module(Box<Module>),
    Script(Box<Script>)
}

impl FromJSON for Program {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("Module") => Ok(Program::Module(Box::new(FromJSON::import(value)?))),
           Some("Script") => Ok(Program::Script(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of Program".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for Program {
    fn export(&self) -> JSON {
        match *self {
           Program::Module(box ref value) => value.export(),
           Program::Script(box ref value) => value.export()
        }
    }
}


impl Walker for Program {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          Program::Module(box ref mut value) => value.walk(path, visitor),
          Program::Script(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum PropertyName {
    LiteralPropertyName(Box<LiteralPropertyName>),
    ComputedPropertyName(Box<ComputedPropertyName>)
}

impl FromJSON for PropertyName {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("LiteralPropertyName") => Ok(PropertyName::LiteralPropertyName(Box::new(FromJSON::import(value)?))),
           Some("ComputedPropertyName") => Ok(PropertyName::ComputedPropertyName(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of PropertyName".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for PropertyName {
    fn export(&self) -> JSON {
        match *self {
           PropertyName::LiteralPropertyName(box ref value) => value.export(),
           PropertyName::ComputedPropertyName(box ref value) => value.export()
        }
    }
}


impl Walker for PropertyName {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          PropertyName::LiteralPropertyName(box ref mut value) => value.walk(path, visitor),
          PropertyName::ComputedPropertyName(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum SimpleAssignmentTarget {
    StaticMemberAssignmentTarget(Box<StaticMemberAssignmentTarget>),
    ComputedMemberAssignmentTarget(Box<ComputedMemberAssignmentTarget>),
    AssignmentTargetIdentifier(Box<AssignmentTargetIdentifier>)
}

impl FromJSON for SimpleAssignmentTarget {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("StaticMemberAssignmentTarget") => Ok(SimpleAssignmentTarget::StaticMemberAssignmentTarget(Box::new(FromJSON::import(value)?))),
           Some("ComputedMemberAssignmentTarget") => Ok(SimpleAssignmentTarget::ComputedMemberAssignmentTarget(Box::new(FromJSON::import(value)?))),
           Some("AssignmentTargetIdentifier") => Ok(SimpleAssignmentTarget::AssignmentTargetIdentifier(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of SimpleAssignmentTarget".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for SimpleAssignmentTarget {
    fn export(&self) -> JSON {
        match *self {
           SimpleAssignmentTarget::StaticMemberAssignmentTarget(box ref value) => value.export(),
           SimpleAssignmentTarget::ComputedMemberAssignmentTarget(box ref value) => value.export(),
           SimpleAssignmentTarget::AssignmentTargetIdentifier(box ref value) => value.export()
        }
    }
}


impl Walker for SimpleAssignmentTarget {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          SimpleAssignmentTarget::StaticMemberAssignmentTarget(box ref mut value) => value.walk(path, visitor),
          SimpleAssignmentTarget::ComputedMemberAssignmentTarget(box ref mut value) => value.walk(path, visitor),
          SimpleAssignmentTarget::AssignmentTargetIdentifier(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum SpreadElementOrExpression {
    LiteralNumericExpression(Box<LiteralNumericExpression>),
    LiteralRegExpExpression(Box<LiteralRegExpExpression>),
    YieldStarExpression(Box<YieldStarExpression>),
    ObjectExpression(Box<ObjectExpression>),
    ConditionalExpression(Box<ConditionalExpression>),
    TemplateExpression(Box<TemplateExpression>),
    LiteralNullExpression(Box<LiteralNullExpression>),
    ClassExpression(Box<ClassExpression>),
    ArrowExpression(Box<ArrowExpression>),
    SpreadElement(Box<SpreadElement>),
    YieldExpression(Box<YieldExpression>),
    LiteralBooleanExpression(Box<LiteralBooleanExpression>),
    ThisExpression(Box<ThisExpression>),
    IdentifierExpression(Box<IdentifierExpression>),
    StaticMemberExpression(Box<StaticMemberExpression>),
    CallExpression(Box<CallExpression>),
    AwaitExpression(Box<AwaitExpression>),
    ComputedMemberExpression(Box<ComputedMemberExpression>),
    BinaryExpression(Box<BinaryExpression>),
    FunctionExpression(Box<FunctionExpression>),
    LiteralInfinityExpression(Box<LiteralInfinityExpression>),
    CompoundAssignmentExpression(Box<CompoundAssignmentExpression>),
    AssignmentExpression(Box<AssignmentExpression>),
    ArrayExpression(Box<ArrayExpression>),
    NewExpression(Box<NewExpression>),
    UnaryExpression(Box<UnaryExpression>),
    LiteralStringExpression(Box<LiteralStringExpression>),
    NewTargetExpression(Box<NewTargetExpression>),
    UpdateExpression(Box<UpdateExpression>)
}

impl FromJSON for SpreadElementOrExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("LiteralNumericExpression") => Ok(SpreadElementOrExpression::LiteralNumericExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralRegExpExpression") => Ok(SpreadElementOrExpression::LiteralRegExpExpression(Box::new(FromJSON::import(value)?))),
           Some("YieldStarExpression") => Ok(SpreadElementOrExpression::YieldStarExpression(Box::new(FromJSON::import(value)?))),
           Some("ObjectExpression") => Ok(SpreadElementOrExpression::ObjectExpression(Box::new(FromJSON::import(value)?))),
           Some("ConditionalExpression") => Ok(SpreadElementOrExpression::ConditionalExpression(Box::new(FromJSON::import(value)?))),
           Some("TemplateExpression") => Ok(SpreadElementOrExpression::TemplateExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralNullExpression") => Ok(SpreadElementOrExpression::LiteralNullExpression(Box::new(FromJSON::import(value)?))),
           Some("ClassExpression") => Ok(SpreadElementOrExpression::ClassExpression(Box::new(FromJSON::import(value)?))),
           Some("ArrowExpression") => Ok(SpreadElementOrExpression::ArrowExpression(Box::new(FromJSON::import(value)?))),
           Some("SpreadElement") => Ok(SpreadElementOrExpression::SpreadElement(Box::new(FromJSON::import(value)?))),
           Some("YieldExpression") => Ok(SpreadElementOrExpression::YieldExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralBooleanExpression") => Ok(SpreadElementOrExpression::LiteralBooleanExpression(Box::new(FromJSON::import(value)?))),
           Some("ThisExpression") => Ok(SpreadElementOrExpression::ThisExpression(Box::new(FromJSON::import(value)?))),
           Some("IdentifierExpression") => Ok(SpreadElementOrExpression::IdentifierExpression(Box::new(FromJSON::import(value)?))),
           Some("StaticMemberExpression") => Ok(SpreadElementOrExpression::StaticMemberExpression(Box::new(FromJSON::import(value)?))),
           Some("CallExpression") => Ok(SpreadElementOrExpression::CallExpression(Box::new(FromJSON::import(value)?))),
           Some("AwaitExpression") => Ok(SpreadElementOrExpression::AwaitExpression(Box::new(FromJSON::import(value)?))),
           Some("ComputedMemberExpression") => Ok(SpreadElementOrExpression::ComputedMemberExpression(Box::new(FromJSON::import(value)?))),
           Some("BinaryExpression") => Ok(SpreadElementOrExpression::BinaryExpression(Box::new(FromJSON::import(value)?))),
           Some("FunctionExpression") => Ok(SpreadElementOrExpression::FunctionExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralInfinityExpression") => Ok(SpreadElementOrExpression::LiteralInfinityExpression(Box::new(FromJSON::import(value)?))),
           Some("CompoundAssignmentExpression") => Ok(SpreadElementOrExpression::CompoundAssignmentExpression(Box::new(FromJSON::import(value)?))),
           Some("AssignmentExpression") => Ok(SpreadElementOrExpression::AssignmentExpression(Box::new(FromJSON::import(value)?))),
           Some("ArrayExpression") => Ok(SpreadElementOrExpression::ArrayExpression(Box::new(FromJSON::import(value)?))),
           Some("NewExpression") => Ok(SpreadElementOrExpression::NewExpression(Box::new(FromJSON::import(value)?))),
           Some("UnaryExpression") => Ok(SpreadElementOrExpression::UnaryExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralStringExpression") => Ok(SpreadElementOrExpression::LiteralStringExpression(Box::new(FromJSON::import(value)?))),
           Some("NewTargetExpression") => Ok(SpreadElementOrExpression::NewTargetExpression(Box::new(FromJSON::import(value)?))),
           Some("UpdateExpression") => Ok(SpreadElementOrExpression::UpdateExpression(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of SpreadElementOrExpression".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for SpreadElementOrExpression {
    fn export(&self) -> JSON {
        match *self {
           SpreadElementOrExpression::LiteralNumericExpression(box ref value) => value.export(),
           SpreadElementOrExpression::LiteralRegExpExpression(box ref value) => value.export(),
           SpreadElementOrExpression::YieldStarExpression(box ref value) => value.export(),
           SpreadElementOrExpression::ObjectExpression(box ref value) => value.export(),
           SpreadElementOrExpression::ConditionalExpression(box ref value) => value.export(),
           SpreadElementOrExpression::TemplateExpression(box ref value) => value.export(),
           SpreadElementOrExpression::LiteralNullExpression(box ref value) => value.export(),
           SpreadElementOrExpression::ClassExpression(box ref value) => value.export(),
           SpreadElementOrExpression::ArrowExpression(box ref value) => value.export(),
           SpreadElementOrExpression::SpreadElement(box ref value) => value.export(),
           SpreadElementOrExpression::YieldExpression(box ref value) => value.export(),
           SpreadElementOrExpression::LiteralBooleanExpression(box ref value) => value.export(),
           SpreadElementOrExpression::ThisExpression(box ref value) => value.export(),
           SpreadElementOrExpression::IdentifierExpression(box ref value) => value.export(),
           SpreadElementOrExpression::StaticMemberExpression(box ref value) => value.export(),
           SpreadElementOrExpression::CallExpression(box ref value) => value.export(),
           SpreadElementOrExpression::AwaitExpression(box ref value) => value.export(),
           SpreadElementOrExpression::ComputedMemberExpression(box ref value) => value.export(),
           SpreadElementOrExpression::BinaryExpression(box ref value) => value.export(),
           SpreadElementOrExpression::FunctionExpression(box ref value) => value.export(),
           SpreadElementOrExpression::LiteralInfinityExpression(box ref value) => value.export(),
           SpreadElementOrExpression::CompoundAssignmentExpression(box ref value) => value.export(),
           SpreadElementOrExpression::AssignmentExpression(box ref value) => value.export(),
           SpreadElementOrExpression::ArrayExpression(box ref value) => value.export(),
           SpreadElementOrExpression::NewExpression(box ref value) => value.export(),
           SpreadElementOrExpression::UnaryExpression(box ref value) => value.export(),
           SpreadElementOrExpression::LiteralStringExpression(box ref value) => value.export(),
           SpreadElementOrExpression::NewTargetExpression(box ref value) => value.export(),
           SpreadElementOrExpression::UpdateExpression(box ref value) => value.export()
        }
    }
}


impl Walker for SpreadElementOrExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          SpreadElementOrExpression::LiteralNumericExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::LiteralRegExpExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::YieldStarExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::ObjectExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::ConditionalExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::TemplateExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::LiteralNullExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::ClassExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::ArrowExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::SpreadElement(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::YieldExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::LiteralBooleanExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::ThisExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::IdentifierExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::StaticMemberExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::CallExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::AwaitExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::ComputedMemberExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::BinaryExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::FunctionExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::LiteralInfinityExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::CompoundAssignmentExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::AssignmentExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::ArrayExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::NewExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::UnaryExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::LiteralStringExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::NewTargetExpression(box ref mut value) => value.walk(path, visitor),
          SpreadElementOrExpression::UpdateExpression(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum Statement {
    IfStatement(Box<IfStatement>),
    SwitchStatementWithDefault(Box<SwitchStatementWithDefault>),
    TryCatchStatement(Box<TryCatchStatement>),
    Block(Box<Block>),
    BreakStatement(Box<BreakStatement>),
    EmptyStatement(Box<EmptyStatement>),
    LabelledStatement(Box<LabelledStatement>),
    ForOfStatement(Box<ForOfStatement>),
    SwitchStatement(Box<SwitchStatement>),
    TryFinallyStatement(Box<TryFinallyStatement>),
    ExpressionStatement(Box<ExpressionStatement>),
    WhileStatement(Box<WhileStatement>),
    ThrowStatement(Box<ThrowStatement>),
    ForStatement(Box<ForStatement>),
    DebuggerStatement(Box<DebuggerStatement>),
    VariableDeclaration(Box<VariableDeclaration>),
    WithStatement(Box<WithStatement>),
    ForInStatement(Box<ForInStatement>),
    ClassDeclaration(Box<ClassDeclaration>),
    ContinueStatement(Box<ContinueStatement>),
    DoWhileStatement(Box<DoWhileStatement>),
    FunctionDeclaration(Box<FunctionDeclaration>),
    ReturnStatement(Box<ReturnStatement>)
}

impl FromJSON for Statement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("IfStatement") => Ok(Statement::IfStatement(Box::new(FromJSON::import(value)?))),
           Some("SwitchStatementWithDefault") => Ok(Statement::SwitchStatementWithDefault(Box::new(FromJSON::import(value)?))),
           Some("TryCatchStatement") => Ok(Statement::TryCatchStatement(Box::new(FromJSON::import(value)?))),
           Some("Block") => Ok(Statement::Block(Box::new(FromJSON::import(value)?))),
           Some("BreakStatement") => Ok(Statement::BreakStatement(Box::new(FromJSON::import(value)?))),
           Some("EmptyStatement") => Ok(Statement::EmptyStatement(Box::new(FromJSON::import(value)?))),
           Some("LabelledStatement") => Ok(Statement::LabelledStatement(Box::new(FromJSON::import(value)?))),
           Some("ForOfStatement") => Ok(Statement::ForOfStatement(Box::new(FromJSON::import(value)?))),
           Some("SwitchStatement") => Ok(Statement::SwitchStatement(Box::new(FromJSON::import(value)?))),
           Some("TryFinallyStatement") => Ok(Statement::TryFinallyStatement(Box::new(FromJSON::import(value)?))),
           Some("ExpressionStatement") => Ok(Statement::ExpressionStatement(Box::new(FromJSON::import(value)?))),
           Some("WhileStatement") => Ok(Statement::WhileStatement(Box::new(FromJSON::import(value)?))),
           Some("ThrowStatement") => Ok(Statement::ThrowStatement(Box::new(FromJSON::import(value)?))),
           Some("ForStatement") => Ok(Statement::ForStatement(Box::new(FromJSON::import(value)?))),
           Some("DebuggerStatement") => Ok(Statement::DebuggerStatement(Box::new(FromJSON::import(value)?))),
           Some("VariableDeclaration") => Ok(Statement::VariableDeclaration(Box::new(FromJSON::import(value)?))),
           Some("WithStatement") => Ok(Statement::WithStatement(Box::new(FromJSON::import(value)?))),
           Some("ForInStatement") => Ok(Statement::ForInStatement(Box::new(FromJSON::import(value)?))),
           Some("ClassDeclaration") => Ok(Statement::ClassDeclaration(Box::new(FromJSON::import(value)?))),
           Some("ContinueStatement") => Ok(Statement::ContinueStatement(Box::new(FromJSON::import(value)?))),
           Some("DoWhileStatement") => Ok(Statement::DoWhileStatement(Box::new(FromJSON::import(value)?))),
           Some("FunctionDeclaration") => Ok(Statement::FunctionDeclaration(Box::new(FromJSON::import(value)?))),
           Some("ReturnStatement") => Ok(Statement::ReturnStatement(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of Statement".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for Statement {
    fn export(&self) -> JSON {
        match *self {
           Statement::IfStatement(box ref value) => value.export(),
           Statement::SwitchStatementWithDefault(box ref value) => value.export(),
           Statement::TryCatchStatement(box ref value) => value.export(),
           Statement::Block(box ref value) => value.export(),
           Statement::BreakStatement(box ref value) => value.export(),
           Statement::EmptyStatement(box ref value) => value.export(),
           Statement::LabelledStatement(box ref value) => value.export(),
           Statement::ForOfStatement(box ref value) => value.export(),
           Statement::SwitchStatement(box ref value) => value.export(),
           Statement::TryFinallyStatement(box ref value) => value.export(),
           Statement::ExpressionStatement(box ref value) => value.export(),
           Statement::WhileStatement(box ref value) => value.export(),
           Statement::ThrowStatement(box ref value) => value.export(),
           Statement::ForStatement(box ref value) => value.export(),
           Statement::DebuggerStatement(box ref value) => value.export(),
           Statement::VariableDeclaration(box ref value) => value.export(),
           Statement::WithStatement(box ref value) => value.export(),
           Statement::ForInStatement(box ref value) => value.export(),
           Statement::ClassDeclaration(box ref value) => value.export(),
           Statement::ContinueStatement(box ref value) => value.export(),
           Statement::DoWhileStatement(box ref value) => value.export(),
           Statement::FunctionDeclaration(box ref value) => value.export(),
           Statement::ReturnStatement(box ref value) => value.export()
        }
    }
}


impl Walker for Statement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          Statement::IfStatement(box ref mut value) => value.walk(path, visitor),
          Statement::SwitchStatementWithDefault(box ref mut value) => value.walk(path, visitor),
          Statement::TryCatchStatement(box ref mut value) => value.walk(path, visitor),
          Statement::Block(box ref mut value) => value.walk(path, visitor),
          Statement::BreakStatement(box ref mut value) => value.walk(path, visitor),
          Statement::EmptyStatement(box ref mut value) => value.walk(path, visitor),
          Statement::LabelledStatement(box ref mut value) => value.walk(path, visitor),
          Statement::ForOfStatement(box ref mut value) => value.walk(path, visitor),
          Statement::SwitchStatement(box ref mut value) => value.walk(path, visitor),
          Statement::TryFinallyStatement(box ref mut value) => value.walk(path, visitor),
          Statement::ExpressionStatement(box ref mut value) => value.walk(path, visitor),
          Statement::WhileStatement(box ref mut value) => value.walk(path, visitor),
          Statement::ThrowStatement(box ref mut value) => value.walk(path, visitor),
          Statement::ForStatement(box ref mut value) => value.walk(path, visitor),
          Statement::DebuggerStatement(box ref mut value) => value.walk(path, visitor),
          Statement::VariableDeclaration(box ref mut value) => value.walk(path, visitor),
          Statement::WithStatement(box ref mut value) => value.walk(path, visitor),
          Statement::ForInStatement(box ref mut value) => value.walk(path, visitor),
          Statement::ClassDeclaration(box ref mut value) => value.walk(path, visitor),
          Statement::ContinueStatement(box ref mut value) => value.walk(path, visitor),
          Statement::DoWhileStatement(box ref mut value) => value.walk(path, visitor),
          Statement::FunctionDeclaration(box ref mut value) => value.walk(path, visitor),
          Statement::ReturnStatement(box ref mut value) => value.walk(path, visitor)
        }
    }
}


#[derive(PartialEq, Debug, Clone)]
pub enum VariableDeclarationOrExpression {
    YieldStarExpression(Box<YieldStarExpression>),
    ClassExpression(Box<ClassExpression>),
    NewExpression(Box<NewExpression>),
    NewTargetExpression(Box<NewTargetExpression>),
    UnaryExpression(Box<UnaryExpression>),
    CompoundAssignmentExpression(Box<CompoundAssignmentExpression>),
    LiteralInfinityExpression(Box<LiteralInfinityExpression>),
    IdentifierExpression(Box<IdentifierExpression>),
    VariableDeclaration(Box<VariableDeclaration>),
    AwaitExpression(Box<AwaitExpression>),
    ComputedMemberExpression(Box<ComputedMemberExpression>),
    YieldExpression(Box<YieldExpression>),
    UpdateExpression(Box<UpdateExpression>),
    ThisExpression(Box<ThisExpression>),
    LiteralNullExpression(Box<LiteralNullExpression>),
    ObjectExpression(Box<ObjectExpression>),
    CallExpression(Box<CallExpression>),
    BinaryExpression(Box<BinaryExpression>),
    TemplateExpression(Box<TemplateExpression>),
    StaticMemberExpression(Box<StaticMemberExpression>),
    ConditionalExpression(Box<ConditionalExpression>),
    ArrayExpression(Box<ArrayExpression>),
    AssignmentExpression(Box<AssignmentExpression>),
    ArrowExpression(Box<ArrowExpression>),
    LiteralStringExpression(Box<LiteralStringExpression>),
    LiteralRegExpExpression(Box<LiteralRegExpExpression>),
    FunctionExpression(Box<FunctionExpression>),
    LiteralBooleanExpression(Box<LiteralBooleanExpression>),
    LiteralNumericExpression(Box<LiteralNumericExpression>)
}

impl FromJSON for VariableDeclarationOrExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
           Some("YieldStarExpression") => Ok(VariableDeclarationOrExpression::YieldStarExpression(Box::new(FromJSON::import(value)?))),
           Some("ClassExpression") => Ok(VariableDeclarationOrExpression::ClassExpression(Box::new(FromJSON::import(value)?))),
           Some("NewExpression") => Ok(VariableDeclarationOrExpression::NewExpression(Box::new(FromJSON::import(value)?))),
           Some("NewTargetExpression") => Ok(VariableDeclarationOrExpression::NewTargetExpression(Box::new(FromJSON::import(value)?))),
           Some("UnaryExpression") => Ok(VariableDeclarationOrExpression::UnaryExpression(Box::new(FromJSON::import(value)?))),
           Some("CompoundAssignmentExpression") => Ok(VariableDeclarationOrExpression::CompoundAssignmentExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralInfinityExpression") => Ok(VariableDeclarationOrExpression::LiteralInfinityExpression(Box::new(FromJSON::import(value)?))),
           Some("IdentifierExpression") => Ok(VariableDeclarationOrExpression::IdentifierExpression(Box::new(FromJSON::import(value)?))),
           Some("VariableDeclaration") => Ok(VariableDeclarationOrExpression::VariableDeclaration(Box::new(FromJSON::import(value)?))),
           Some("AwaitExpression") => Ok(VariableDeclarationOrExpression::AwaitExpression(Box::new(FromJSON::import(value)?))),
           Some("ComputedMemberExpression") => Ok(VariableDeclarationOrExpression::ComputedMemberExpression(Box::new(FromJSON::import(value)?))),
           Some("YieldExpression") => Ok(VariableDeclarationOrExpression::YieldExpression(Box::new(FromJSON::import(value)?))),
           Some("UpdateExpression") => Ok(VariableDeclarationOrExpression::UpdateExpression(Box::new(FromJSON::import(value)?))),
           Some("ThisExpression") => Ok(VariableDeclarationOrExpression::ThisExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralNullExpression") => Ok(VariableDeclarationOrExpression::LiteralNullExpression(Box::new(FromJSON::import(value)?))),
           Some("ObjectExpression") => Ok(VariableDeclarationOrExpression::ObjectExpression(Box::new(FromJSON::import(value)?))),
           Some("CallExpression") => Ok(VariableDeclarationOrExpression::CallExpression(Box::new(FromJSON::import(value)?))),
           Some("BinaryExpression") => Ok(VariableDeclarationOrExpression::BinaryExpression(Box::new(FromJSON::import(value)?))),
           Some("TemplateExpression") => Ok(VariableDeclarationOrExpression::TemplateExpression(Box::new(FromJSON::import(value)?))),
           Some("StaticMemberExpression") => Ok(VariableDeclarationOrExpression::StaticMemberExpression(Box::new(FromJSON::import(value)?))),
           Some("ConditionalExpression") => Ok(VariableDeclarationOrExpression::ConditionalExpression(Box::new(FromJSON::import(value)?))),
           Some("ArrayExpression") => Ok(VariableDeclarationOrExpression::ArrayExpression(Box::new(FromJSON::import(value)?))),
           Some("AssignmentExpression") => Ok(VariableDeclarationOrExpression::AssignmentExpression(Box::new(FromJSON::import(value)?))),
           Some("ArrowExpression") => Ok(VariableDeclarationOrExpression::ArrowExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralStringExpression") => Ok(VariableDeclarationOrExpression::LiteralStringExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralRegExpExpression") => Ok(VariableDeclarationOrExpression::LiteralRegExpExpression(Box::new(FromJSON::import(value)?))),
           Some("FunctionExpression") => Ok(VariableDeclarationOrExpression::FunctionExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralBooleanExpression") => Ok(VariableDeclarationOrExpression::LiteralBooleanExpression(Box::new(FromJSON::import(value)?))),
           Some("LiteralNumericExpression") => Ok(VariableDeclarationOrExpression::LiteralNumericExpression(Box::new(FromJSON::import(value)?))),
            _ => Err(FromJSONError {
                expected: "Instance of VariableDeclarationOrExpression".to_string(),
                got: value.dump()
            })
        }
    }
}


impl ToJSON for VariableDeclarationOrExpression {
    fn export(&self) -> JSON {
        match *self {
           VariableDeclarationOrExpression::YieldStarExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::ClassExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::NewExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::NewTargetExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::UnaryExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::CompoundAssignmentExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::LiteralInfinityExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::IdentifierExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::VariableDeclaration(box ref value) => value.export(),
           VariableDeclarationOrExpression::AwaitExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::ComputedMemberExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::YieldExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::UpdateExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::ThisExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::LiteralNullExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::ObjectExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::CallExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::BinaryExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::TemplateExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::StaticMemberExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::ConditionalExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::ArrayExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::AssignmentExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::ArrowExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::LiteralStringExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::LiteralRegExpExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::FunctionExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::LiteralBooleanExpression(box ref value) => value.export(),
           VariableDeclarationOrExpression::LiteralNumericExpression(box ref value) => value.export()
        }
    }
}


impl Walker for VariableDeclarationOrExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        match *self {
          VariableDeclarationOrExpression::YieldStarExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::ClassExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::NewExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::NewTargetExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::UnaryExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::CompoundAssignmentExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::LiteralInfinityExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::IdentifierExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::VariableDeclaration(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::AwaitExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::ComputedMemberExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::YieldExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::UpdateExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::ThisExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::LiteralNullExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::ObjectExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::CallExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::BinaryExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::TemplateExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::StaticMemberExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::ConditionalExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::ArrayExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::AssignmentExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::ArrowExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::LiteralStringExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::LiteralRegExpExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::FunctionExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::LiteralBooleanExpression(box ref mut value) => value.walk(path, visitor),
          VariableDeclarationOrExpression::LiteralNumericExpression(box ref mut value) => value.walk(path, visitor)
        }
    }
}




// Aliases to primitive types (by lexicographical order)
pub type Identifier = std::string::String;
pub type IdentifierName = std::string::String;
pub type Label = std::string::String;
pub type String = std::string::String;


// Aliases to list types (by lexicographical order)
pub type Arguments = Vec<SpreadElementOrExpression>;
pub type ListOfAssignmentTargetOrAssignmentTargetWithInitializer = Vec<AssignmentTargetOrAssignmentTargetWithInitializer>;
pub type ListOfAssignmentTargetProperty = Vec<AssignmentTargetProperty>;
pub type ListOfBindingProperty = Vec<BindingProperty>;
pub type ListOfClassElement = Vec<ClassElement>;
pub type ListOfDirective = Vec<Directive>;
pub type ListOfExportFromSpecifier = Vec<ExportFromSpecifier>;
pub type ListOfExportLocalSpecifier = Vec<ExportLocalSpecifier>;
pub type ListOfExpressionOrTemplateElement = Vec<ExpressionOrTemplateElement>;
pub type ListOfIdentifierName = Vec<IdentifierName>;
pub type ListOfImportDeclarationOrExportDeclarationOrStatement = Vec<ImportDeclarationOrExportDeclarationOrStatement>;
pub type ListOfImportSpecifier = Vec<ImportSpecifier>;
pub type ListOfObjectProperty = Vec<ObjectProperty>;
pub type ListOfOptionalBindingOrBindingWithInitializer = Vec<OptionalBindingOrBindingWithInitializer>;
pub type ListOfOptionalSpreadElementOrExpression = Vec<OptionalSpreadElementOrExpression>;
pub type ListOfParameter = Vec<Parameter>;
pub type ListOfStatement = Vec<Statement>;
pub type ListOfSwitchCase = Vec<SwitchCase>;
pub type ListOfVariableDeclarator = Vec<VariableDeclarator>;


// Aliases to optional types (by lexicographical order)
pub type OptionalAssertedBlockScope = Option<AssertedBlockScope>;
pub type OptionalAssertedParameterScope = Option<AssertedParameterScope>;
pub type OptionalAssertedVarScope = Option<AssertedVarScope>;
pub type OptionalAssignmentTarget = Option<AssignmentTarget>;
pub type OptionalBinding = Option<Binding>;
pub type OptionalBindingIdentifier = Option<BindingIdentifier>;
pub type OptionalBindingOrBindingWithInitializer = Option<BindingOrBindingWithInitializer>;
pub type OptionalCatchClause = Option<CatchClause>;
pub type OptionalExpression = Option<Expression>;
pub type OptionalIdentifierName = Option<IdentifierName>;
pub type OptionalLabel = Option<Label>;
pub type OptionalSpreadElementOrExpression = Option<SpreadElementOrExpression>;
pub type OptionalStatement = Option<Statement>;
pub type OptionalVariableDeclarationOrExpression = Option<VariableDeclarationOrExpression>;


// Interfaces and interface names (by lexicographical order)
#[derive(PartialEq, Debug, Clone)]
pub struct ArrayAssignmentTarget {
    pub elements: ListOfAssignmentTargetOrAssignmentTargetWithInitializer,
    pub rest: OptionalAssignmentTarget
}

impl FromJSON for ArrayAssignmentTarget {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ArrayAssignmentTarget") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ArrayAssignmentTarget".to_string(),
                got: value.dump()
            })
        }
        Ok(ArrayAssignmentTarget { elements: FromJSON::import(&value["elements"])?, rest: FromJSON::import(&value["rest"])? })
    }
}


impl ToJSON for ArrayAssignmentTarget {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ArrayAssignmentTarget"),
             "elements" => self.elements.export(),
             "rest" => self.rest.export()
        }
    }
}


impl Walker for ArrayAssignmentTarget {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ArrayAssignmentTarget);
        visitor.enter_array_assignment_target(path, self)?;
        path.enter_field(ASTField::Elements);
        self.elements.walk(path, visitor)?;
        path.exit_field(ASTField::Elements);
        path.enter_field(ASTField::Rest);
        self.rest.walk(path, visitor)?;
        path.exit_field(ASTField::Rest);
        visitor.exit_array_assignment_target(path, self)?;
        path.exit_interface(ASTNode::ArrayAssignmentTarget);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ArrayBinding {
    pub elements: ListOfOptionalBindingOrBindingWithInitializer,
    pub rest: OptionalBinding
}

impl FromJSON for ArrayBinding {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ArrayBinding") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ArrayBinding".to_string(),
                got: value.dump()
            })
        }
        Ok(ArrayBinding { elements: FromJSON::import(&value["elements"])?, rest: FromJSON::import(&value["rest"])? })
    }
}


impl ToJSON for ArrayBinding {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ArrayBinding"),
             "elements" => self.elements.export(),
             "rest" => self.rest.export()
        }
    }
}


impl Walker for ArrayBinding {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ArrayBinding);
        visitor.enter_array_binding(path, self)?;
        path.enter_field(ASTField::Elements);
        self.elements.walk(path, visitor)?;
        path.exit_field(ASTField::Elements);
        path.enter_field(ASTField::Rest);
        self.rest.walk(path, visitor)?;
        path.exit_field(ASTField::Rest);
        visitor.exit_array_binding(path, self)?;
        path.exit_interface(ASTNode::ArrayBinding);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ArrayExpression {
    pub elements: ListOfOptionalSpreadElementOrExpression
}

impl FromJSON for ArrayExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ArrayExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ArrayExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(ArrayExpression { elements: FromJSON::import(&value["elements"])? })
    }
}


impl ToJSON for ArrayExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ArrayExpression"),
             "elements" => self.elements.export()
        }
    }
}


impl Walker for ArrayExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ArrayExpression);
        visitor.enter_array_expression(path, self)?;
        path.enter_field(ASTField::Elements);
        self.elements.walk(path, visitor)?;
        path.exit_field(ASTField::Elements);
        visitor.exit_array_expression(path, self)?;
        path.exit_interface(ASTNode::ArrayExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ArrowExpression {
    pub is_async: bool,
    pub parameter_scope: OptionalAssertedParameterScope,
    pub body_scope: OptionalAssertedVarScope,
    pub params: FormalParameters,
    pub body: FunctionBodyOrExpression
}

impl FromJSON for ArrowExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ArrowExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ArrowExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(ArrowExpression { is_async: FromJSON::import(&value["isAsync"])?, parameter_scope: FromJSON::import(&value["parameterScope"])?, body_scope: FromJSON::import(&value["bodyScope"])?, params: FromJSON::import(&value["params"])?, body: FromJSON::import(&value["body"])? })
    }
}


impl ToJSON for ArrowExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ArrowExpression"),
             "isAsync" => self.is_async.export(),
             "parameterScope" => self.parameter_scope.export(),
             "bodyScope" => self.body_scope.export(),
             "params" => self.params.export(),
             "body" => self.body.export()
        }
    }
}


impl Walker for ArrowExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ArrowExpression);
        visitor.enter_arrow_expression(path, self)?;
        path.enter_field(ASTField::IsAsync);
        self.is_async.walk(path, visitor)?;
        path.exit_field(ASTField::IsAsync);
        path.enter_field(ASTField::ParameterScope);
        self.parameter_scope.walk(path, visitor)?;
        path.exit_field(ASTField::ParameterScope);
        path.enter_field(ASTField::BodyScope);
        self.body_scope.walk(path, visitor)?;
        path.exit_field(ASTField::BodyScope);
        path.enter_field(ASTField::Params);
        self.params.walk(path, visitor)?;
        path.exit_field(ASTField::Params);
        path.enter_field(ASTField::Body);
        self.body.walk(path, visitor)?;
        path.exit_field(ASTField::Body);
        visitor.exit_arrow_expression(path, self)?;
        path.exit_interface(ASTNode::ArrowExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct AssertedBlockScope {
    pub lexically_declared_names: ListOfIdentifierName,
    pub captured_names: ListOfIdentifierName,
    pub has_direct_eval: bool
}

impl FromJSON for AssertedBlockScope {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("AssertedBlockScope") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of AssertedBlockScope".to_string(),
                got: value.dump()
            })
        }
        Ok(AssertedBlockScope { lexically_declared_names: FromJSON::import(&value["lexicallyDeclaredNames"])?, captured_names: FromJSON::import(&value["capturedNames"])?, has_direct_eval: FromJSON::import(&value["hasDirectEval"])? })
    }
}


impl ToJSON for AssertedBlockScope {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("AssertedBlockScope"),
             "lexicallyDeclaredNames" => self.lexically_declared_names.export(),
             "capturedNames" => self.captured_names.export(),
             "hasDirectEval" => self.has_direct_eval.export()
        }
    }
}


impl Walker for AssertedBlockScope {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::AssertedBlockScope);
        visitor.enter_asserted_block_scope(path, self)?;
        path.enter_field(ASTField::LexicallyDeclaredNames);
        self.lexically_declared_names.walk(path, visitor)?;
        path.exit_field(ASTField::LexicallyDeclaredNames);
        path.enter_field(ASTField::CapturedNames);
        self.captured_names.walk(path, visitor)?;
        path.exit_field(ASTField::CapturedNames);
        path.enter_field(ASTField::HasDirectEval);
        self.has_direct_eval.walk(path, visitor)?;
        path.exit_field(ASTField::HasDirectEval);
        visitor.exit_asserted_block_scope(path, self)?;
        path.exit_interface(ASTNode::AssertedBlockScope);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct AssertedParameterScope {
    pub parameter_names: ListOfIdentifierName,
    pub captured_names: ListOfIdentifierName,
    pub has_direct_eval: bool
}

impl FromJSON for AssertedParameterScope {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("AssertedParameterScope") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of AssertedParameterScope".to_string(),
                got: value.dump()
            })
        }
        Ok(AssertedParameterScope { parameter_names: FromJSON::import(&value["parameterNames"])?, captured_names: FromJSON::import(&value["capturedNames"])?, has_direct_eval: FromJSON::import(&value["hasDirectEval"])? })
    }
}


impl ToJSON for AssertedParameterScope {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("AssertedParameterScope"),
             "parameterNames" => self.parameter_names.export(),
             "capturedNames" => self.captured_names.export(),
             "hasDirectEval" => self.has_direct_eval.export()
        }
    }
}


impl Walker for AssertedParameterScope {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::AssertedParameterScope);
        visitor.enter_asserted_parameter_scope(path, self)?;
        path.enter_field(ASTField::ParameterNames);
        self.parameter_names.walk(path, visitor)?;
        path.exit_field(ASTField::ParameterNames);
        path.enter_field(ASTField::CapturedNames);
        self.captured_names.walk(path, visitor)?;
        path.exit_field(ASTField::CapturedNames);
        path.enter_field(ASTField::HasDirectEval);
        self.has_direct_eval.walk(path, visitor)?;
        path.exit_field(ASTField::HasDirectEval);
        visitor.exit_asserted_parameter_scope(path, self)?;
        path.exit_interface(ASTNode::AssertedParameterScope);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct AssertedVarScope {
    pub lexically_declared_names: ListOfIdentifierName,
    pub var_declared_names: ListOfIdentifierName,
    pub captured_names: ListOfIdentifierName,
    pub has_direct_eval: bool
}

impl FromJSON for AssertedVarScope {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("AssertedVarScope") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of AssertedVarScope".to_string(),
                got: value.dump()
            })
        }
        Ok(AssertedVarScope { lexically_declared_names: FromJSON::import(&value["lexicallyDeclaredNames"])?, var_declared_names: FromJSON::import(&value["varDeclaredNames"])?, captured_names: FromJSON::import(&value["capturedNames"])?, has_direct_eval: FromJSON::import(&value["hasDirectEval"])? })
    }
}


impl ToJSON for AssertedVarScope {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("AssertedVarScope"),
             "lexicallyDeclaredNames" => self.lexically_declared_names.export(),
             "varDeclaredNames" => self.var_declared_names.export(),
             "capturedNames" => self.captured_names.export(),
             "hasDirectEval" => self.has_direct_eval.export()
        }
    }
}


impl Walker for AssertedVarScope {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::AssertedVarScope);
        visitor.enter_asserted_var_scope(path, self)?;
        path.enter_field(ASTField::LexicallyDeclaredNames);
        self.lexically_declared_names.walk(path, visitor)?;
        path.exit_field(ASTField::LexicallyDeclaredNames);
        path.enter_field(ASTField::VarDeclaredNames);
        self.var_declared_names.walk(path, visitor)?;
        path.exit_field(ASTField::VarDeclaredNames);
        path.enter_field(ASTField::CapturedNames);
        self.captured_names.walk(path, visitor)?;
        path.exit_field(ASTField::CapturedNames);
        path.enter_field(ASTField::HasDirectEval);
        self.has_direct_eval.walk(path, visitor)?;
        path.exit_field(ASTField::HasDirectEval);
        visitor.exit_asserted_var_scope(path, self)?;
        path.exit_interface(ASTNode::AssertedVarScope);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct AssignmentExpression {
    pub binding: AssignmentTarget,
    pub expression: Expression
}

impl FromJSON for AssignmentExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("AssignmentExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of AssignmentExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(AssignmentExpression { binding: FromJSON::import(&value["binding"])?, expression: FromJSON::import(&value["expression"])? })
    }
}


impl ToJSON for AssignmentExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("AssignmentExpression"),
             "binding" => self.binding.export(),
             "expression" => self.expression.export()
        }
    }
}


impl Walker for AssignmentExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::AssignmentExpression);
        visitor.enter_assignment_expression(path, self)?;
        path.enter_field(ASTField::Binding);
        self.binding.walk(path, visitor)?;
        path.exit_field(ASTField::Binding);
        path.enter_field(ASTField::Expression);
        self.expression.walk(path, visitor)?;
        path.exit_field(ASTField::Expression);
        visitor.exit_assignment_expression(path, self)?;
        path.exit_interface(ASTNode::AssignmentExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct AssignmentTargetIdentifier {
    pub name: Identifier
}

impl FromJSON for AssignmentTargetIdentifier {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("AssignmentTargetIdentifier") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of AssignmentTargetIdentifier".to_string(),
                got: value.dump()
            })
        }
        Ok(AssignmentTargetIdentifier { name: FromJSON::import(&value["name"])? })
    }
}


impl ToJSON for AssignmentTargetIdentifier {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("AssignmentTargetIdentifier"),
             "name" => self.name.export()
        }
    }
}


impl Walker for AssignmentTargetIdentifier {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::AssignmentTargetIdentifier);
        visitor.enter_assignment_target_identifier(path, self)?;
        path.enter_field(ASTField::Name);
        self.name.walk(path, visitor)?;
        path.exit_field(ASTField::Name);
        visitor.exit_assignment_target_identifier(path, self)?;
        path.exit_interface(ASTNode::AssignmentTargetIdentifier);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct AssignmentTargetPropertyIdentifier {
    pub binding: AssignmentTargetIdentifier,
    pub init: OptionalExpression
}

impl FromJSON for AssignmentTargetPropertyIdentifier {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("AssignmentTargetPropertyIdentifier") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of AssignmentTargetPropertyIdentifier".to_string(),
                got: value.dump()
            })
        }
        Ok(AssignmentTargetPropertyIdentifier { binding: FromJSON::import(&value["binding"])?, init: FromJSON::import(&value["init"])? })
    }
}


impl ToJSON for AssignmentTargetPropertyIdentifier {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("AssignmentTargetPropertyIdentifier"),
             "binding" => self.binding.export(),
             "init" => self.init.export()
        }
    }
}


impl Walker for AssignmentTargetPropertyIdentifier {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::AssignmentTargetPropertyIdentifier);
        visitor.enter_assignment_target_property_identifier(path, self)?;
        path.enter_field(ASTField::Binding);
        self.binding.walk(path, visitor)?;
        path.exit_field(ASTField::Binding);
        path.enter_field(ASTField::Init);
        self.init.walk(path, visitor)?;
        path.exit_field(ASTField::Init);
        visitor.exit_assignment_target_property_identifier(path, self)?;
        path.exit_interface(ASTNode::AssignmentTargetPropertyIdentifier);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct AssignmentTargetPropertyProperty {
    pub name: PropertyName,
    pub binding: AssignmentTargetOrAssignmentTargetWithInitializer
}

impl FromJSON for AssignmentTargetPropertyProperty {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("AssignmentTargetPropertyProperty") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of AssignmentTargetPropertyProperty".to_string(),
                got: value.dump()
            })
        }
        Ok(AssignmentTargetPropertyProperty { name: FromJSON::import(&value["name"])?, binding: FromJSON::import(&value["binding"])? })
    }
}


impl ToJSON for AssignmentTargetPropertyProperty {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("AssignmentTargetPropertyProperty"),
             "name" => self.name.export(),
             "binding" => self.binding.export()
        }
    }
}


impl Walker for AssignmentTargetPropertyProperty {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::AssignmentTargetPropertyProperty);
        visitor.enter_assignment_target_property_property(path, self)?;
        path.enter_field(ASTField::Name);
        self.name.walk(path, visitor)?;
        path.exit_field(ASTField::Name);
        path.enter_field(ASTField::Binding);
        self.binding.walk(path, visitor)?;
        path.exit_field(ASTField::Binding);
        visitor.exit_assignment_target_property_property(path, self)?;
        path.exit_interface(ASTNode::AssignmentTargetPropertyProperty);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct AssignmentTargetWithInitializer {
    pub binding: AssignmentTarget,
    pub init: Expression
}

impl FromJSON for AssignmentTargetWithInitializer {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("AssignmentTargetWithInitializer") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of AssignmentTargetWithInitializer".to_string(),
                got: value.dump()
            })
        }
        Ok(AssignmentTargetWithInitializer { binding: FromJSON::import(&value["binding"])?, init: FromJSON::import(&value["init"])? })
    }
}


impl ToJSON for AssignmentTargetWithInitializer {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("AssignmentTargetWithInitializer"),
             "binding" => self.binding.export(),
             "init" => self.init.export()
        }
    }
}


impl Walker for AssignmentTargetWithInitializer {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::AssignmentTargetWithInitializer);
        visitor.enter_assignment_target_with_initializer(path, self)?;
        path.enter_field(ASTField::Binding);
        self.binding.walk(path, visitor)?;
        path.exit_field(ASTField::Binding);
        path.enter_field(ASTField::Init);
        self.init.walk(path, visitor)?;
        path.exit_field(ASTField::Init);
        visitor.exit_assignment_target_with_initializer(path, self)?;
        path.exit_interface(ASTNode::AssignmentTargetWithInitializer);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct AwaitExpression {
    pub expression: Expression
}

impl FromJSON for AwaitExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("AwaitExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of AwaitExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(AwaitExpression { expression: FromJSON::import(&value["expression"])? })
    }
}


impl ToJSON for AwaitExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("AwaitExpression"),
             "expression" => self.expression.export()
        }
    }
}


impl Walker for AwaitExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::AwaitExpression);
        visitor.enter_await_expression(path, self)?;
        path.enter_field(ASTField::Expression);
        self.expression.walk(path, visitor)?;
        path.exit_field(ASTField::Expression);
        visitor.exit_await_expression(path, self)?;
        path.exit_interface(ASTNode::AwaitExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct BinaryExpression {
    pub operator: BinaryOperator,
    pub left: Expression,
    pub right: Expression
}

impl FromJSON for BinaryExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("BinaryExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of BinaryExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(BinaryExpression { operator: FromJSON::import(&value["operator"])?, left: FromJSON::import(&value["left"])?, right: FromJSON::import(&value["right"])? })
    }
}


impl ToJSON for BinaryExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("BinaryExpression"),
             "operator" => self.operator.export(),
             "left" => self.left.export(),
             "right" => self.right.export()
        }
    }
}


impl Walker for BinaryExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::BinaryExpression);
        visitor.enter_binary_expression(path, self)?;
        path.enter_field(ASTField::Operator);
        self.operator.walk(path, visitor)?;
        path.exit_field(ASTField::Operator);
        path.enter_field(ASTField::Left);
        self.left.walk(path, visitor)?;
        path.exit_field(ASTField::Left);
        path.enter_field(ASTField::Right);
        self.right.walk(path, visitor)?;
        path.exit_field(ASTField::Right);
        visitor.exit_binary_expression(path, self)?;
        path.exit_interface(ASTNode::BinaryExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct BindingIdentifier {
    pub name: Identifier
}

impl FromJSON for BindingIdentifier {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("BindingIdentifier") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of BindingIdentifier".to_string(),
                got: value.dump()
            })
        }
        Ok(BindingIdentifier { name: FromJSON::import(&value["name"])? })
    }
}


impl ToJSON for BindingIdentifier {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("BindingIdentifier"),
             "name" => self.name.export()
        }
    }
}


impl Walker for BindingIdentifier {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::BindingIdentifier);
        visitor.enter_binding_identifier(path, self)?;
        path.enter_field(ASTField::Name);
        self.name.walk(path, visitor)?;
        path.exit_field(ASTField::Name);
        visitor.exit_binding_identifier(path, self)?;
        path.exit_interface(ASTNode::BindingIdentifier);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct BindingPropertyIdentifier {
    pub binding: BindingIdentifier,
    pub init: OptionalExpression
}

impl FromJSON for BindingPropertyIdentifier {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("BindingPropertyIdentifier") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of BindingPropertyIdentifier".to_string(),
                got: value.dump()
            })
        }
        Ok(BindingPropertyIdentifier { binding: FromJSON::import(&value["binding"])?, init: FromJSON::import(&value["init"])? })
    }
}


impl ToJSON for BindingPropertyIdentifier {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("BindingPropertyIdentifier"),
             "binding" => self.binding.export(),
             "init" => self.init.export()
        }
    }
}


impl Walker for BindingPropertyIdentifier {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::BindingPropertyIdentifier);
        visitor.enter_binding_property_identifier(path, self)?;
        path.enter_field(ASTField::Binding);
        self.binding.walk(path, visitor)?;
        path.exit_field(ASTField::Binding);
        path.enter_field(ASTField::Init);
        self.init.walk(path, visitor)?;
        path.exit_field(ASTField::Init);
        visitor.exit_binding_property_identifier(path, self)?;
        path.exit_interface(ASTNode::BindingPropertyIdentifier);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct BindingPropertyProperty {
    pub name: PropertyName,
    pub binding: BindingOrBindingWithInitializer
}

impl FromJSON for BindingPropertyProperty {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("BindingPropertyProperty") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of BindingPropertyProperty".to_string(),
                got: value.dump()
            })
        }
        Ok(BindingPropertyProperty { name: FromJSON::import(&value["name"])?, binding: FromJSON::import(&value["binding"])? })
    }
}


impl ToJSON for BindingPropertyProperty {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("BindingPropertyProperty"),
             "name" => self.name.export(),
             "binding" => self.binding.export()
        }
    }
}


impl Walker for BindingPropertyProperty {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::BindingPropertyProperty);
        visitor.enter_binding_property_property(path, self)?;
        path.enter_field(ASTField::Name);
        self.name.walk(path, visitor)?;
        path.exit_field(ASTField::Name);
        path.enter_field(ASTField::Binding);
        self.binding.walk(path, visitor)?;
        path.exit_field(ASTField::Binding);
        visitor.exit_binding_property_property(path, self)?;
        path.exit_interface(ASTNode::BindingPropertyProperty);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct BindingWithInitializer {
    pub binding: Binding,
    pub init: Expression
}

impl FromJSON for BindingWithInitializer {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("BindingWithInitializer") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of BindingWithInitializer".to_string(),
                got: value.dump()
            })
        }
        Ok(BindingWithInitializer { binding: FromJSON::import(&value["binding"])?, init: FromJSON::import(&value["init"])? })
    }
}


impl ToJSON for BindingWithInitializer {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("BindingWithInitializer"),
             "binding" => self.binding.export(),
             "init" => self.init.export()
        }
    }
}


impl Walker for BindingWithInitializer {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::BindingWithInitializer);
        visitor.enter_binding_with_initializer(path, self)?;
        path.enter_field(ASTField::Binding);
        self.binding.walk(path, visitor)?;
        path.exit_field(ASTField::Binding);
        path.enter_field(ASTField::Init);
        self.init.walk(path, visitor)?;
        path.exit_field(ASTField::Init);
        visitor.exit_binding_with_initializer(path, self)?;
        path.exit_interface(ASTNode::BindingWithInitializer);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct Block {
    pub scope: OptionalAssertedBlockScope,
    pub statements: ListOfStatement
}

impl FromJSON for Block {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("Block") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of Block".to_string(),
                got: value.dump()
            })
        }
        Ok(Block { scope: FromJSON::import(&value["scope"])?, statements: FromJSON::import(&value["statements"])? })
    }
}


impl ToJSON for Block {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("Block"),
             "scope" => self.scope.export(),
             "statements" => self.statements.export()
        }
    }
}


impl Walker for Block {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::Block);
        visitor.enter_block(path, self)?;
        path.enter_field(ASTField::Scope);
        self.scope.walk(path, visitor)?;
        path.exit_field(ASTField::Scope);
        path.enter_field(ASTField::Statements);
        self.statements.walk(path, visitor)?;
        path.exit_field(ASTField::Statements);
        visitor.exit_block(path, self)?;
        path.exit_interface(ASTNode::Block);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct BreakStatement {
    pub label: OptionalLabel
}

impl FromJSON for BreakStatement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("BreakStatement") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of BreakStatement".to_string(),
                got: value.dump()
            })
        }
        Ok(BreakStatement { label: FromJSON::import(&value["label"])? })
    }
}


impl ToJSON for BreakStatement {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("BreakStatement"),
             "label" => self.label.export()
        }
    }
}


impl Walker for BreakStatement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::BreakStatement);
        visitor.enter_break_statement(path, self)?;
        path.enter_field(ASTField::Label);
        self.label.walk(path, visitor)?;
        path.exit_field(ASTField::Label);
        visitor.exit_break_statement(path, self)?;
        path.exit_interface(ASTNode::BreakStatement);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct CallExpression {
    pub callee: ExpressionOrSuper,
    pub arguments: Arguments
}

impl FromJSON for CallExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("CallExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of CallExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(CallExpression { callee: FromJSON::import(&value["callee"])?, arguments: FromJSON::import(&value["arguments"])? })
    }
}


impl ToJSON for CallExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("CallExpression"),
             "callee" => self.callee.export(),
             "arguments" => self.arguments.export()
        }
    }
}


impl Walker for CallExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::CallExpression);
        visitor.enter_call_expression(path, self)?;
        path.enter_field(ASTField::Callee);
        self.callee.walk(path, visitor)?;
        path.exit_field(ASTField::Callee);
        path.enter_field(ASTField::Arguments);
        self.arguments.walk(path, visitor)?;
        path.exit_field(ASTField::Arguments);
        visitor.exit_call_expression(path, self)?;
        path.exit_interface(ASTNode::CallExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct CatchClause {
    pub binding: Binding,
    pub body: Block
}

impl FromJSON for CatchClause {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("CatchClause") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of CatchClause".to_string(),
                got: value.dump()
            })
        }
        Ok(CatchClause { binding: FromJSON::import(&value["binding"])?, body: FromJSON::import(&value["body"])? })
    }
}


impl ToJSON for CatchClause {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("CatchClause"),
             "binding" => self.binding.export(),
             "body" => self.body.export()
        }
    }
}


impl Walker for CatchClause {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::CatchClause);
        visitor.enter_catch_clause(path, self)?;
        path.enter_field(ASTField::Binding);
        self.binding.walk(path, visitor)?;
        path.exit_field(ASTField::Binding);
        path.enter_field(ASTField::Body);
        self.body.walk(path, visitor)?;
        path.exit_field(ASTField::Body);
        visitor.exit_catch_clause(path, self)?;
        path.exit_interface(ASTNode::CatchClause);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ClassDeclaration {
    pub name: BindingIdentifier,
    pub super_: OptionalExpression,
    pub elements: ListOfClassElement
}

impl FromJSON for ClassDeclaration {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ClassDeclaration") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ClassDeclaration".to_string(),
                got: value.dump()
            })
        }
        Ok(ClassDeclaration { name: FromJSON::import(&value["name"])?, super_: FromJSON::import(&value["super"])?, elements: FromJSON::import(&value["elements"])? })
    }
}


impl ToJSON for ClassDeclaration {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ClassDeclaration"),
             "name" => self.name.export(),
             "super" => self.super_.export(),
             "elements" => self.elements.export()
        }
    }
}


impl Walker for ClassDeclaration {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ClassDeclaration);
        visitor.enter_class_declaration(path, self)?;
        path.enter_field(ASTField::Name);
        self.name.walk(path, visitor)?;
        path.exit_field(ASTField::Name);
        path.enter_field(ASTField::Super);
        self.super_.walk(path, visitor)?;
        path.exit_field(ASTField::Super);
        path.enter_field(ASTField::Elements);
        self.elements.walk(path, visitor)?;
        path.exit_field(ASTField::Elements);
        visitor.exit_class_declaration(path, self)?;
        path.exit_interface(ASTNode::ClassDeclaration);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ClassElement {
    pub is_static: bool,
    pub method: MethodDefinition
}

impl FromJSON for ClassElement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ClassElement") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ClassElement".to_string(),
                got: value.dump()
            })
        }
        Ok(ClassElement { is_static: FromJSON::import(&value["isStatic"])?, method: FromJSON::import(&value["method"])? })
    }
}


impl ToJSON for ClassElement {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ClassElement"),
             "isStatic" => self.is_static.export(),
             "method" => self.method.export()
        }
    }
}


impl Walker for ClassElement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ClassElement);
        visitor.enter_class_element(path, self)?;
        path.enter_field(ASTField::IsStatic);
        self.is_static.walk(path, visitor)?;
        path.exit_field(ASTField::IsStatic);
        path.enter_field(ASTField::Method);
        self.method.walk(path, visitor)?;
        path.exit_field(ASTField::Method);
        visitor.exit_class_element(path, self)?;
        path.exit_interface(ASTNode::ClassElement);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ClassExpression {
    pub name: OptionalBindingIdentifier,
    pub super_: OptionalExpression,
    pub elements: ListOfClassElement
}

impl FromJSON for ClassExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ClassExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ClassExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(ClassExpression { name: FromJSON::import(&value["name"])?, super_: FromJSON::import(&value["super"])?, elements: FromJSON::import(&value["elements"])? })
    }
}


impl ToJSON for ClassExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ClassExpression"),
             "name" => self.name.export(),
             "super" => self.super_.export(),
             "elements" => self.elements.export()
        }
    }
}


impl Walker for ClassExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ClassExpression);
        visitor.enter_class_expression(path, self)?;
        path.enter_field(ASTField::Name);
        self.name.walk(path, visitor)?;
        path.exit_field(ASTField::Name);
        path.enter_field(ASTField::Super);
        self.super_.walk(path, visitor)?;
        path.exit_field(ASTField::Super);
        path.enter_field(ASTField::Elements);
        self.elements.walk(path, visitor)?;
        path.exit_field(ASTField::Elements);
        visitor.exit_class_expression(path, self)?;
        path.exit_interface(ASTNode::ClassExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct CompoundAssignmentExpression {
    pub operator: CompoundAssignmentOperator,
    pub binding: SimpleAssignmentTarget,
    pub expression: Expression
}

impl FromJSON for CompoundAssignmentExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("CompoundAssignmentExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of CompoundAssignmentExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(CompoundAssignmentExpression { operator: FromJSON::import(&value["operator"])?, binding: FromJSON::import(&value["binding"])?, expression: FromJSON::import(&value["expression"])? })
    }
}


impl ToJSON for CompoundAssignmentExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("CompoundAssignmentExpression"),
             "operator" => self.operator.export(),
             "binding" => self.binding.export(),
             "expression" => self.expression.export()
        }
    }
}


impl Walker for CompoundAssignmentExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::CompoundAssignmentExpression);
        visitor.enter_compound_assignment_expression(path, self)?;
        path.enter_field(ASTField::Operator);
        self.operator.walk(path, visitor)?;
        path.exit_field(ASTField::Operator);
        path.enter_field(ASTField::Binding);
        self.binding.walk(path, visitor)?;
        path.exit_field(ASTField::Binding);
        path.enter_field(ASTField::Expression);
        self.expression.walk(path, visitor)?;
        path.exit_field(ASTField::Expression);
        visitor.exit_compound_assignment_expression(path, self)?;
        path.exit_interface(ASTNode::CompoundAssignmentExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ComputedMemberAssignmentTarget {
    pub object: ExpressionOrSuper,
    pub expression: Expression
}

impl FromJSON for ComputedMemberAssignmentTarget {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ComputedMemberAssignmentTarget") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ComputedMemberAssignmentTarget".to_string(),
                got: value.dump()
            })
        }
        Ok(ComputedMemberAssignmentTarget { object: FromJSON::import(&value["object"])?, expression: FromJSON::import(&value["expression"])? })
    }
}


impl ToJSON for ComputedMemberAssignmentTarget {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ComputedMemberAssignmentTarget"),
             "object" => self.object.export(),
             "expression" => self.expression.export()
        }
    }
}


impl Walker for ComputedMemberAssignmentTarget {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ComputedMemberAssignmentTarget);
        visitor.enter_computed_member_assignment_target(path, self)?;
        path.enter_field(ASTField::Object);
        self.object.walk(path, visitor)?;
        path.exit_field(ASTField::Object);
        path.enter_field(ASTField::Expression);
        self.expression.walk(path, visitor)?;
        path.exit_field(ASTField::Expression);
        visitor.exit_computed_member_assignment_target(path, self)?;
        path.exit_interface(ASTNode::ComputedMemberAssignmentTarget);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ComputedMemberExpression {
    pub object: ExpressionOrSuper,
    pub expression: Expression
}

impl FromJSON for ComputedMemberExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ComputedMemberExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ComputedMemberExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(ComputedMemberExpression { object: FromJSON::import(&value["object"])?, expression: FromJSON::import(&value["expression"])? })
    }
}


impl ToJSON for ComputedMemberExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ComputedMemberExpression"),
             "object" => self.object.export(),
             "expression" => self.expression.export()
        }
    }
}


impl Walker for ComputedMemberExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ComputedMemberExpression);
        visitor.enter_computed_member_expression(path, self)?;
        path.enter_field(ASTField::Object);
        self.object.walk(path, visitor)?;
        path.exit_field(ASTField::Object);
        path.enter_field(ASTField::Expression);
        self.expression.walk(path, visitor)?;
        path.exit_field(ASTField::Expression);
        visitor.exit_computed_member_expression(path, self)?;
        path.exit_interface(ASTNode::ComputedMemberExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ComputedPropertyName {
    pub expression: Expression
}

impl FromJSON for ComputedPropertyName {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ComputedPropertyName") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ComputedPropertyName".to_string(),
                got: value.dump()
            })
        }
        Ok(ComputedPropertyName { expression: FromJSON::import(&value["expression"])? })
    }
}


impl ToJSON for ComputedPropertyName {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ComputedPropertyName"),
             "expression" => self.expression.export()
        }
    }
}


impl Walker for ComputedPropertyName {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ComputedPropertyName);
        visitor.enter_computed_property_name(path, self)?;
        path.enter_field(ASTField::Expression);
        self.expression.walk(path, visitor)?;
        path.exit_field(ASTField::Expression);
        visitor.exit_computed_property_name(path, self)?;
        path.exit_interface(ASTNode::ComputedPropertyName);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ConditionalExpression {
    pub test: Expression,
    pub consequent: Expression,
    pub alternate: Expression
}

impl FromJSON for ConditionalExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ConditionalExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ConditionalExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(ConditionalExpression { test: FromJSON::import(&value["test"])?, consequent: FromJSON::import(&value["consequent"])?, alternate: FromJSON::import(&value["alternate"])? })
    }
}


impl ToJSON for ConditionalExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ConditionalExpression"),
             "test" => self.test.export(),
             "consequent" => self.consequent.export(),
             "alternate" => self.alternate.export()
        }
    }
}


impl Walker for ConditionalExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ConditionalExpression);
        visitor.enter_conditional_expression(path, self)?;
        path.enter_field(ASTField::Test);
        self.test.walk(path, visitor)?;
        path.exit_field(ASTField::Test);
        path.enter_field(ASTField::Consequent);
        self.consequent.walk(path, visitor)?;
        path.exit_field(ASTField::Consequent);
        path.enter_field(ASTField::Alternate);
        self.alternate.walk(path, visitor)?;
        path.exit_field(ASTField::Alternate);
        visitor.exit_conditional_expression(path, self)?;
        path.exit_interface(ASTNode::ConditionalExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ContinueStatement {
    pub label: OptionalLabel
}

impl FromJSON for ContinueStatement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ContinueStatement") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ContinueStatement".to_string(),
                got: value.dump()
            })
        }
        Ok(ContinueStatement { label: FromJSON::import(&value["label"])? })
    }
}


impl ToJSON for ContinueStatement {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ContinueStatement"),
             "label" => self.label.export()
        }
    }
}


impl Walker for ContinueStatement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ContinueStatement);
        visitor.enter_continue_statement(path, self)?;
        path.enter_field(ASTField::Label);
        self.label.walk(path, visitor)?;
        path.exit_field(ASTField::Label);
        visitor.exit_continue_statement(path, self)?;
        path.exit_interface(ASTNode::ContinueStatement);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct DataProperty {
    pub name: PropertyName,
    pub expression: Expression
}

impl FromJSON for DataProperty {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("DataProperty") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of DataProperty".to_string(),
                got: value.dump()
            })
        }
        Ok(DataProperty { name: FromJSON::import(&value["name"])?, expression: FromJSON::import(&value["expression"])? })
    }
}


impl ToJSON for DataProperty {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("DataProperty"),
             "name" => self.name.export(),
             "expression" => self.expression.export()
        }
    }
}


impl Walker for DataProperty {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::DataProperty);
        visitor.enter_data_property(path, self)?;
        path.enter_field(ASTField::Name);
        self.name.walk(path, visitor)?;
        path.exit_field(ASTField::Name);
        path.enter_field(ASTField::Expression);
        self.expression.walk(path, visitor)?;
        path.exit_field(ASTField::Expression);
        visitor.exit_data_property(path, self)?;
        path.exit_interface(ASTNode::DataProperty);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct DebuggerStatement {

}

impl FromJSON for DebuggerStatement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("DebuggerStatement") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of DebuggerStatement".to_string(),
                got: value.dump()
            })
        }
        Ok(DebuggerStatement {  })
    }
}


impl ToJSON for DebuggerStatement {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("DebuggerStatement"),

        }
    }
}


impl Walker for DebuggerStatement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::DebuggerStatement);
        visitor.enter_debugger_statement(path, self)?;

        visitor.exit_debugger_statement(path, self)?;
        path.exit_interface(ASTNode::DebuggerStatement);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct Directive {
    pub raw_value: String
}

impl FromJSON for Directive {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("Directive") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of Directive".to_string(),
                got: value.dump()
            })
        }
        Ok(Directive { raw_value: FromJSON::import(&value["rawValue"])? })
    }
}


impl ToJSON for Directive {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("Directive"),
             "rawValue" => self.raw_value.export()
        }
    }
}


impl Walker for Directive {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::Directive);
        visitor.enter_directive(path, self)?;
        path.enter_field(ASTField::RawValue);
        self.raw_value.walk(path, visitor)?;
        path.exit_field(ASTField::RawValue);
        visitor.exit_directive(path, self)?;
        path.exit_interface(ASTNode::Directive);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct DoWhileStatement {
    pub test: Expression,
    pub body: Statement
}

impl FromJSON for DoWhileStatement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("DoWhileStatement") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of DoWhileStatement".to_string(),
                got: value.dump()
            })
        }
        Ok(DoWhileStatement { test: FromJSON::import(&value["test"])?, body: FromJSON::import(&value["body"])? })
    }
}


impl ToJSON for DoWhileStatement {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("DoWhileStatement"),
             "test" => self.test.export(),
             "body" => self.body.export()
        }
    }
}


impl Walker for DoWhileStatement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::DoWhileStatement);
        visitor.enter_do_while_statement(path, self)?;
        path.enter_field(ASTField::Test);
        self.test.walk(path, visitor)?;
        path.exit_field(ASTField::Test);
        path.enter_field(ASTField::Body);
        self.body.walk(path, visitor)?;
        path.exit_field(ASTField::Body);
        visitor.exit_do_while_statement(path, self)?;
        path.exit_interface(ASTNode::DoWhileStatement);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct EmptyStatement {

}

impl FromJSON for EmptyStatement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("EmptyStatement") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of EmptyStatement".to_string(),
                got: value.dump()
            })
        }
        Ok(EmptyStatement {  })
    }
}


impl ToJSON for EmptyStatement {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("EmptyStatement"),

        }
    }
}


impl Walker for EmptyStatement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::EmptyStatement);
        visitor.enter_empty_statement(path, self)?;

        visitor.exit_empty_statement(path, self)?;
        path.exit_interface(ASTNode::EmptyStatement);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct Export {
    pub declaration: FunctionDeclarationOrClassDeclarationOrVariableDeclaration
}

impl FromJSON for Export {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("Export") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of Export".to_string(),
                got: value.dump()
            })
        }
        Ok(Export { declaration: FromJSON::import(&value["declaration"])? })
    }
}


impl ToJSON for Export {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("Export"),
             "declaration" => self.declaration.export()
        }
    }
}


impl Walker for Export {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::Export);
        visitor.enter_export(path, self)?;
        path.enter_field(ASTField::Declaration);
        self.declaration.walk(path, visitor)?;
        path.exit_field(ASTField::Declaration);
        visitor.exit_export(path, self)?;
        path.exit_interface(ASTNode::Export);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ExportAllFrom {
    pub module_specifier: String
}

impl FromJSON for ExportAllFrom {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ExportAllFrom") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ExportAllFrom".to_string(),
                got: value.dump()
            })
        }
        Ok(ExportAllFrom { module_specifier: FromJSON::import(&value["moduleSpecifier"])? })
    }
}


impl ToJSON for ExportAllFrom {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ExportAllFrom"),
             "moduleSpecifier" => self.module_specifier.export()
        }
    }
}


impl Walker for ExportAllFrom {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ExportAllFrom);
        visitor.enter_export_all_from(path, self)?;
        path.enter_field(ASTField::ModuleSpecifier);
        self.module_specifier.walk(path, visitor)?;
        path.exit_field(ASTField::ModuleSpecifier);
        visitor.exit_export_all_from(path, self)?;
        path.exit_interface(ASTNode::ExportAllFrom);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ExportDefault {
    pub body: FunctionDeclarationOrClassDeclarationOrExpression
}

impl FromJSON for ExportDefault {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ExportDefault") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ExportDefault".to_string(),
                got: value.dump()
            })
        }
        Ok(ExportDefault { body: FromJSON::import(&value["body"])? })
    }
}


impl ToJSON for ExportDefault {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ExportDefault"),
             "body" => self.body.export()
        }
    }
}


impl Walker for ExportDefault {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ExportDefault);
        visitor.enter_export_default(path, self)?;
        path.enter_field(ASTField::Body);
        self.body.walk(path, visitor)?;
        path.exit_field(ASTField::Body);
        visitor.exit_export_default(path, self)?;
        path.exit_interface(ASTNode::ExportDefault);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ExportFrom {
    pub named_exports: ListOfExportFromSpecifier,
    pub module_specifier: String
}

impl FromJSON for ExportFrom {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ExportFrom") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ExportFrom".to_string(),
                got: value.dump()
            })
        }
        Ok(ExportFrom { named_exports: FromJSON::import(&value["namedExports"])?, module_specifier: FromJSON::import(&value["moduleSpecifier"])? })
    }
}


impl ToJSON for ExportFrom {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ExportFrom"),
             "namedExports" => self.named_exports.export(),
             "moduleSpecifier" => self.module_specifier.export()
        }
    }
}


impl Walker for ExportFrom {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ExportFrom);
        visitor.enter_export_from(path, self)?;
        path.enter_field(ASTField::NamedExports);
        self.named_exports.walk(path, visitor)?;
        path.exit_field(ASTField::NamedExports);
        path.enter_field(ASTField::ModuleSpecifier);
        self.module_specifier.walk(path, visitor)?;
        path.exit_field(ASTField::ModuleSpecifier);
        visitor.exit_export_from(path, self)?;
        path.exit_interface(ASTNode::ExportFrom);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ExportFromSpecifier {
    pub name: IdentifierName,
    pub exported_name: OptionalIdentifierName
}

impl FromJSON for ExportFromSpecifier {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ExportFromSpecifier") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ExportFromSpecifier".to_string(),
                got: value.dump()
            })
        }
        Ok(ExportFromSpecifier { name: FromJSON::import(&value["name"])?, exported_name: FromJSON::import(&value["exportedName"])? })
    }
}


impl ToJSON for ExportFromSpecifier {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ExportFromSpecifier"),
             "name" => self.name.export(),
             "exportedName" => self.exported_name.export()
        }
    }
}


impl Walker for ExportFromSpecifier {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ExportFromSpecifier);
        visitor.enter_export_from_specifier(path, self)?;
        path.enter_field(ASTField::Name);
        self.name.walk(path, visitor)?;
        path.exit_field(ASTField::Name);
        path.enter_field(ASTField::ExportedName);
        self.exported_name.walk(path, visitor)?;
        path.exit_field(ASTField::ExportedName);
        visitor.exit_export_from_specifier(path, self)?;
        path.exit_interface(ASTNode::ExportFromSpecifier);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ExportLocalSpecifier {
    pub name: IdentifierExpression,
    pub exported_name: OptionalIdentifierName
}

impl FromJSON for ExportLocalSpecifier {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ExportLocalSpecifier") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ExportLocalSpecifier".to_string(),
                got: value.dump()
            })
        }
        Ok(ExportLocalSpecifier { name: FromJSON::import(&value["name"])?, exported_name: FromJSON::import(&value["exportedName"])? })
    }
}


impl ToJSON for ExportLocalSpecifier {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ExportLocalSpecifier"),
             "name" => self.name.export(),
             "exportedName" => self.exported_name.export()
        }
    }
}


impl Walker for ExportLocalSpecifier {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ExportLocalSpecifier);
        visitor.enter_export_local_specifier(path, self)?;
        path.enter_field(ASTField::Name);
        self.name.walk(path, visitor)?;
        path.exit_field(ASTField::Name);
        path.enter_field(ASTField::ExportedName);
        self.exported_name.walk(path, visitor)?;
        path.exit_field(ASTField::ExportedName);
        visitor.exit_export_local_specifier(path, self)?;
        path.exit_interface(ASTNode::ExportLocalSpecifier);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ExportLocals {
    pub named_exports: ListOfExportLocalSpecifier
}

impl FromJSON for ExportLocals {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ExportLocals") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ExportLocals".to_string(),
                got: value.dump()
            })
        }
        Ok(ExportLocals { named_exports: FromJSON::import(&value["namedExports"])? })
    }
}


impl ToJSON for ExportLocals {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ExportLocals"),
             "namedExports" => self.named_exports.export()
        }
    }
}


impl Walker for ExportLocals {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ExportLocals);
        visitor.enter_export_locals(path, self)?;
        path.enter_field(ASTField::NamedExports);
        self.named_exports.walk(path, visitor)?;
        path.exit_field(ASTField::NamedExports);
        visitor.exit_export_locals(path, self)?;
        path.exit_interface(ASTNode::ExportLocals);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ExpressionStatement {
    pub expression: Expression
}

impl FromJSON for ExpressionStatement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ExpressionStatement") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ExpressionStatement".to_string(),
                got: value.dump()
            })
        }
        Ok(ExpressionStatement { expression: FromJSON::import(&value["expression"])? })
    }
}


impl ToJSON for ExpressionStatement {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ExpressionStatement"),
             "expression" => self.expression.export()
        }
    }
}


impl Walker for ExpressionStatement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ExpressionStatement);
        visitor.enter_expression_statement(path, self)?;
        path.enter_field(ASTField::Expression);
        self.expression.walk(path, visitor)?;
        path.exit_field(ASTField::Expression);
        visitor.exit_expression_statement(path, self)?;
        path.exit_interface(ASTNode::ExpressionStatement);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ForInOfBinding {
    pub kind: VariableDeclarationKind,
    pub binding: Binding
}

impl FromJSON for ForInOfBinding {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ForInOfBinding") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ForInOfBinding".to_string(),
                got: value.dump()
            })
        }
        Ok(ForInOfBinding { kind: FromJSON::import(&value["kind"])?, binding: FromJSON::import(&value["binding"])? })
    }
}


impl ToJSON for ForInOfBinding {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ForInOfBinding"),
             "kind" => self.kind.export(),
             "binding" => self.binding.export()
        }
    }
}


impl Walker for ForInOfBinding {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ForInOfBinding);
        visitor.enter_for_in_of_binding(path, self)?;
        path.enter_field(ASTField::Kind);
        self.kind.walk(path, visitor)?;
        path.exit_field(ASTField::Kind);
        path.enter_field(ASTField::Binding);
        self.binding.walk(path, visitor)?;
        path.exit_field(ASTField::Binding);
        visitor.exit_for_in_of_binding(path, self)?;
        path.exit_interface(ASTNode::ForInOfBinding);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ForInStatement {
    pub left: ForInOfBindingOrAssignmentTarget,
    pub right: Expression,
    pub body: Statement
}

impl FromJSON for ForInStatement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ForInStatement") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ForInStatement".to_string(),
                got: value.dump()
            })
        }
        Ok(ForInStatement { left: FromJSON::import(&value["left"])?, right: FromJSON::import(&value["right"])?, body: FromJSON::import(&value["body"])? })
    }
}


impl ToJSON for ForInStatement {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ForInStatement"),
             "left" => self.left.export(),
             "right" => self.right.export(),
             "body" => self.body.export()
        }
    }
}


impl Walker for ForInStatement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ForInStatement);
        visitor.enter_for_in_statement(path, self)?;
        path.enter_field(ASTField::Left);
        self.left.walk(path, visitor)?;
        path.exit_field(ASTField::Left);
        path.enter_field(ASTField::Right);
        self.right.walk(path, visitor)?;
        path.exit_field(ASTField::Right);
        path.enter_field(ASTField::Body);
        self.body.walk(path, visitor)?;
        path.exit_field(ASTField::Body);
        visitor.exit_for_in_statement(path, self)?;
        path.exit_interface(ASTNode::ForInStatement);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ForOfStatement {
    pub left: ForInOfBindingOrAssignmentTarget,
    pub right: Expression,
    pub body: Statement
}

impl FromJSON for ForOfStatement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ForOfStatement") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ForOfStatement".to_string(),
                got: value.dump()
            })
        }
        Ok(ForOfStatement { left: FromJSON::import(&value["left"])?, right: FromJSON::import(&value["right"])?, body: FromJSON::import(&value["body"])? })
    }
}


impl ToJSON for ForOfStatement {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ForOfStatement"),
             "left" => self.left.export(),
             "right" => self.right.export(),
             "body" => self.body.export()
        }
    }
}


impl Walker for ForOfStatement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ForOfStatement);
        visitor.enter_for_of_statement(path, self)?;
        path.enter_field(ASTField::Left);
        self.left.walk(path, visitor)?;
        path.exit_field(ASTField::Left);
        path.enter_field(ASTField::Right);
        self.right.walk(path, visitor)?;
        path.exit_field(ASTField::Right);
        path.enter_field(ASTField::Body);
        self.body.walk(path, visitor)?;
        path.exit_field(ASTField::Body);
        visitor.exit_for_of_statement(path, self)?;
        path.exit_interface(ASTNode::ForOfStatement);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ForStatement {
    pub init: OptionalVariableDeclarationOrExpression,
    pub test: OptionalExpression,
    pub update: OptionalExpression,
    pub body: Statement
}

impl FromJSON for ForStatement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ForStatement") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ForStatement".to_string(),
                got: value.dump()
            })
        }
        Ok(ForStatement { init: FromJSON::import(&value["init"])?, test: FromJSON::import(&value["test"])?, update: FromJSON::import(&value["update"])?, body: FromJSON::import(&value["body"])? })
    }
}


impl ToJSON for ForStatement {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ForStatement"),
             "init" => self.init.export(),
             "test" => self.test.export(),
             "update" => self.update.export(),
             "body" => self.body.export()
        }
    }
}


impl Walker for ForStatement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ForStatement);
        visitor.enter_for_statement(path, self)?;
        path.enter_field(ASTField::Init);
        self.init.walk(path, visitor)?;
        path.exit_field(ASTField::Init);
        path.enter_field(ASTField::Test);
        self.test.walk(path, visitor)?;
        path.exit_field(ASTField::Test);
        path.enter_field(ASTField::Update);
        self.update.walk(path, visitor)?;
        path.exit_field(ASTField::Update);
        path.enter_field(ASTField::Body);
        self.body.walk(path, visitor)?;
        path.exit_field(ASTField::Body);
        visitor.exit_for_statement(path, self)?;
        path.exit_interface(ASTNode::ForStatement);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct FormalParameters {
    pub items: ListOfParameter,
    pub rest: OptionalBinding
}

impl FromJSON for FormalParameters {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("FormalParameters") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of FormalParameters".to_string(),
                got: value.dump()
            })
        }
        Ok(FormalParameters { items: FromJSON::import(&value["items"])?, rest: FromJSON::import(&value["rest"])? })
    }
}


impl ToJSON for FormalParameters {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("FormalParameters"),
             "items" => self.items.export(),
             "rest" => self.rest.export()
        }
    }
}


impl Walker for FormalParameters {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::FormalParameters);
        visitor.enter_formal_parameters(path, self)?;
        path.enter_field(ASTField::Items);
        self.items.walk(path, visitor)?;
        path.exit_field(ASTField::Items);
        path.enter_field(ASTField::Rest);
        self.rest.walk(path, visitor)?;
        path.exit_field(ASTField::Rest);
        visitor.exit_formal_parameters(path, self)?;
        path.exit_interface(ASTNode::FormalParameters);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct FunctionBody {
    pub directives: ListOfDirective,
    pub statements: ListOfStatement
}

impl FromJSON for FunctionBody {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("FunctionBody") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of FunctionBody".to_string(),
                got: value.dump()
            })
        }
        Ok(FunctionBody { directives: FromJSON::import(&value["directives"])?, statements: FromJSON::import(&value["statements"])? })
    }
}


impl ToJSON for FunctionBody {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("FunctionBody"),
             "directives" => self.directives.export(),
             "statements" => self.statements.export()
        }
    }
}


impl Walker for FunctionBody {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::FunctionBody);
        visitor.enter_function_body(path, self)?;
        path.enter_field(ASTField::Directives);
        self.directives.walk(path, visitor)?;
        path.exit_field(ASTField::Directives);
        path.enter_field(ASTField::Statements);
        self.statements.walk(path, visitor)?;
        path.exit_field(ASTField::Statements);
        visitor.exit_function_body(path, self)?;
        path.exit_interface(ASTNode::FunctionBody);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct FunctionDeclaration {
    pub is_async: bool,
    pub is_generator: bool,
    pub parameter_scope: OptionalAssertedParameterScope,
    pub body_scope: OptionalAssertedVarScope,
    pub name: BindingIdentifier,
    pub params: FormalParameters,
    pub body: FunctionBody
}

impl FromJSON for FunctionDeclaration {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("FunctionDeclaration") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of FunctionDeclaration".to_string(),
                got: value.dump()
            })
        }
        Ok(FunctionDeclaration { is_async: FromJSON::import(&value["isAsync"])?, is_generator: FromJSON::import(&value["isGenerator"])?, parameter_scope: FromJSON::import(&value["parameterScope"])?, body_scope: FromJSON::import(&value["bodyScope"])?, name: FromJSON::import(&value["name"])?, params: FromJSON::import(&value["params"])?, body: FromJSON::import(&value["body"])? })
    }
}


impl ToJSON for FunctionDeclaration {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("FunctionDeclaration"),
             "isAsync" => self.is_async.export(),
             "isGenerator" => self.is_generator.export(),
             "parameterScope" => self.parameter_scope.export(),
             "bodyScope" => self.body_scope.export(),
             "name" => self.name.export(),
             "params" => self.params.export(),
             "body" => self.body.export()
        }
    }
}


impl Walker for FunctionDeclaration {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::FunctionDeclaration);
        visitor.enter_function_declaration(path, self)?;
        path.enter_field(ASTField::IsAsync);
        self.is_async.walk(path, visitor)?;
        path.exit_field(ASTField::IsAsync);
        path.enter_field(ASTField::IsGenerator);
        self.is_generator.walk(path, visitor)?;
        path.exit_field(ASTField::IsGenerator);
        path.enter_field(ASTField::ParameterScope);
        self.parameter_scope.walk(path, visitor)?;
        path.exit_field(ASTField::ParameterScope);
        path.enter_field(ASTField::BodyScope);
        self.body_scope.walk(path, visitor)?;
        path.exit_field(ASTField::BodyScope);
        path.enter_field(ASTField::Name);
        self.name.walk(path, visitor)?;
        path.exit_field(ASTField::Name);
        path.enter_field(ASTField::Params);
        self.params.walk(path, visitor)?;
        path.exit_field(ASTField::Params);
        path.enter_field(ASTField::Body);
        self.body.walk(path, visitor)?;
        path.exit_field(ASTField::Body);
        visitor.exit_function_declaration(path, self)?;
        path.exit_interface(ASTNode::FunctionDeclaration);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct FunctionExpression {
    pub is_async: bool,
    pub is_generator: bool,
    pub parameter_scope: OptionalAssertedParameterScope,
    pub body_scope: OptionalAssertedVarScope,
    pub name: OptionalBindingIdentifier,
    pub params: FormalParameters,
    pub body: FunctionBody
}

impl FromJSON for FunctionExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("FunctionExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of FunctionExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(FunctionExpression { is_async: FromJSON::import(&value["isAsync"])?, is_generator: FromJSON::import(&value["isGenerator"])?, parameter_scope: FromJSON::import(&value["parameterScope"])?, body_scope: FromJSON::import(&value["bodyScope"])?, name: FromJSON::import(&value["name"])?, params: FromJSON::import(&value["params"])?, body: FromJSON::import(&value["body"])? })
    }
}


impl ToJSON for FunctionExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("FunctionExpression"),
             "isAsync" => self.is_async.export(),
             "isGenerator" => self.is_generator.export(),
             "parameterScope" => self.parameter_scope.export(),
             "bodyScope" => self.body_scope.export(),
             "name" => self.name.export(),
             "params" => self.params.export(),
             "body" => self.body.export()
        }
    }
}


impl Walker for FunctionExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::FunctionExpression);
        visitor.enter_function_expression(path, self)?;
        path.enter_field(ASTField::IsAsync);
        self.is_async.walk(path, visitor)?;
        path.exit_field(ASTField::IsAsync);
        path.enter_field(ASTField::IsGenerator);
        self.is_generator.walk(path, visitor)?;
        path.exit_field(ASTField::IsGenerator);
        path.enter_field(ASTField::ParameterScope);
        self.parameter_scope.walk(path, visitor)?;
        path.exit_field(ASTField::ParameterScope);
        path.enter_field(ASTField::BodyScope);
        self.body_scope.walk(path, visitor)?;
        path.exit_field(ASTField::BodyScope);
        path.enter_field(ASTField::Name);
        self.name.walk(path, visitor)?;
        path.exit_field(ASTField::Name);
        path.enter_field(ASTField::Params);
        self.params.walk(path, visitor)?;
        path.exit_field(ASTField::Params);
        path.enter_field(ASTField::Body);
        self.body.walk(path, visitor)?;
        path.exit_field(ASTField::Body);
        visitor.exit_function_expression(path, self)?;
        path.exit_interface(ASTNode::FunctionExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct Getter {
    pub body_scope: OptionalAssertedVarScope,
    pub name: PropertyName,
    pub body: FunctionBody
}

impl FromJSON for Getter {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("Getter") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of Getter".to_string(),
                got: value.dump()
            })
        }
        Ok(Getter { body_scope: FromJSON::import(&value["bodyScope"])?, name: FromJSON::import(&value["name"])?, body: FromJSON::import(&value["body"])? })
    }
}


impl ToJSON for Getter {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("Getter"),
             "bodyScope" => self.body_scope.export(),
             "name" => self.name.export(),
             "body" => self.body.export()
        }
    }
}


impl Walker for Getter {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::Getter);
        visitor.enter_getter(path, self)?;
        path.enter_field(ASTField::BodyScope);
        self.body_scope.walk(path, visitor)?;
        path.exit_field(ASTField::BodyScope);
        path.enter_field(ASTField::Name);
        self.name.walk(path, visitor)?;
        path.exit_field(ASTField::Name);
        path.enter_field(ASTField::Body);
        self.body.walk(path, visitor)?;
        path.exit_field(ASTField::Body);
        visitor.exit_getter(path, self)?;
        path.exit_interface(ASTNode::Getter);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct IdentifierExpression {
    pub name: Identifier
}

impl FromJSON for IdentifierExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("IdentifierExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of IdentifierExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(IdentifierExpression { name: FromJSON::import(&value["name"])? })
    }
}


impl ToJSON for IdentifierExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("IdentifierExpression"),
             "name" => self.name.export()
        }
    }
}


impl Walker for IdentifierExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::IdentifierExpression);
        visitor.enter_identifier_expression(path, self)?;
        path.enter_field(ASTField::Name);
        self.name.walk(path, visitor)?;
        path.exit_field(ASTField::Name);
        visitor.exit_identifier_expression(path, self)?;
        path.exit_interface(ASTNode::IdentifierExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct IfStatement {
    pub test: Expression,
    pub consequent: Statement,
    pub alternate: OptionalStatement
}

impl FromJSON for IfStatement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("IfStatement") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of IfStatement".to_string(),
                got: value.dump()
            })
        }
        Ok(IfStatement { test: FromJSON::import(&value["test"])?, consequent: FromJSON::import(&value["consequent"])?, alternate: FromJSON::import(&value["alternate"])? })
    }
}


impl ToJSON for IfStatement {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("IfStatement"),
             "test" => self.test.export(),
             "consequent" => self.consequent.export(),
             "alternate" => self.alternate.export()
        }
    }
}


impl Walker for IfStatement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::IfStatement);
        visitor.enter_if_statement(path, self)?;
        path.enter_field(ASTField::Test);
        self.test.walk(path, visitor)?;
        path.exit_field(ASTField::Test);
        path.enter_field(ASTField::Consequent);
        self.consequent.walk(path, visitor)?;
        path.exit_field(ASTField::Consequent);
        path.enter_field(ASTField::Alternate);
        self.alternate.walk(path, visitor)?;
        path.exit_field(ASTField::Alternate);
        visitor.exit_if_statement(path, self)?;
        path.exit_interface(ASTNode::IfStatement);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct Import {
    pub module_specifier: String,
    pub default_binding: OptionalBindingIdentifier,
    pub named_imports: ListOfImportSpecifier
}

impl FromJSON for Import {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("Import") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of Import".to_string(),
                got: value.dump()
            })
        }
        Ok(Import { module_specifier: FromJSON::import(&value["moduleSpecifier"])?, default_binding: FromJSON::import(&value["defaultBinding"])?, named_imports: FromJSON::import(&value["namedImports"])? })
    }
}


impl ToJSON for Import {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("Import"),
             "moduleSpecifier" => self.module_specifier.export(),
             "defaultBinding" => self.default_binding.export(),
             "namedImports" => self.named_imports.export()
        }
    }
}


impl Walker for Import {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::Import);
        visitor.enter_import(path, self)?;
        path.enter_field(ASTField::ModuleSpecifier);
        self.module_specifier.walk(path, visitor)?;
        path.exit_field(ASTField::ModuleSpecifier);
        path.enter_field(ASTField::DefaultBinding);
        self.default_binding.walk(path, visitor)?;
        path.exit_field(ASTField::DefaultBinding);
        path.enter_field(ASTField::NamedImports);
        self.named_imports.walk(path, visitor)?;
        path.exit_field(ASTField::NamedImports);
        visitor.exit_import(path, self)?;
        path.exit_interface(ASTNode::Import);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ImportNamespace {
    pub module_specifier: String,
    pub default_binding: OptionalBindingIdentifier,
    pub namespace_binding: BindingIdentifier
}

impl FromJSON for ImportNamespace {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ImportNamespace") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ImportNamespace".to_string(),
                got: value.dump()
            })
        }
        Ok(ImportNamespace { module_specifier: FromJSON::import(&value["moduleSpecifier"])?, default_binding: FromJSON::import(&value["defaultBinding"])?, namespace_binding: FromJSON::import(&value["namespaceBinding"])? })
    }
}


impl ToJSON for ImportNamespace {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ImportNamespace"),
             "moduleSpecifier" => self.module_specifier.export(),
             "defaultBinding" => self.default_binding.export(),
             "namespaceBinding" => self.namespace_binding.export()
        }
    }
}


impl Walker for ImportNamespace {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ImportNamespace);
        visitor.enter_import_namespace(path, self)?;
        path.enter_field(ASTField::ModuleSpecifier);
        self.module_specifier.walk(path, visitor)?;
        path.exit_field(ASTField::ModuleSpecifier);
        path.enter_field(ASTField::DefaultBinding);
        self.default_binding.walk(path, visitor)?;
        path.exit_field(ASTField::DefaultBinding);
        path.enter_field(ASTField::NamespaceBinding);
        self.namespace_binding.walk(path, visitor)?;
        path.exit_field(ASTField::NamespaceBinding);
        visitor.exit_import_namespace(path, self)?;
        path.exit_interface(ASTNode::ImportNamespace);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ImportSpecifier {
    pub name: OptionalIdentifierName,
    pub binding: BindingIdentifier
}

impl FromJSON for ImportSpecifier {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ImportSpecifier") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ImportSpecifier".to_string(),
                got: value.dump()
            })
        }
        Ok(ImportSpecifier { name: FromJSON::import(&value["name"])?, binding: FromJSON::import(&value["binding"])? })
    }
}


impl ToJSON for ImportSpecifier {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ImportSpecifier"),
             "name" => self.name.export(),
             "binding" => self.binding.export()
        }
    }
}


impl Walker for ImportSpecifier {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ImportSpecifier);
        visitor.enter_import_specifier(path, self)?;
        path.enter_field(ASTField::Name);
        self.name.walk(path, visitor)?;
        path.exit_field(ASTField::Name);
        path.enter_field(ASTField::Binding);
        self.binding.walk(path, visitor)?;
        path.exit_field(ASTField::Binding);
        visitor.exit_import_specifier(path, self)?;
        path.exit_interface(ASTNode::ImportSpecifier);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct LabelledStatement {
    pub label: Label,
    pub body: Statement
}

impl FromJSON for LabelledStatement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("LabelledStatement") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of LabelledStatement".to_string(),
                got: value.dump()
            })
        }
        Ok(LabelledStatement { label: FromJSON::import(&value["label"])?, body: FromJSON::import(&value["body"])? })
    }
}


impl ToJSON for LabelledStatement {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("LabelledStatement"),
             "label" => self.label.export(),
             "body" => self.body.export()
        }
    }
}


impl Walker for LabelledStatement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::LabelledStatement);
        visitor.enter_labelled_statement(path, self)?;
        path.enter_field(ASTField::Label);
        self.label.walk(path, visitor)?;
        path.exit_field(ASTField::Label);
        path.enter_field(ASTField::Body);
        self.body.walk(path, visitor)?;
        path.exit_field(ASTField::Body);
        visitor.exit_labelled_statement(path, self)?;
        path.exit_interface(ASTNode::LabelledStatement);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct LiteralBooleanExpression {
    pub value: bool
}

impl FromJSON for LiteralBooleanExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("LiteralBooleanExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of LiteralBooleanExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(LiteralBooleanExpression { value: FromJSON::import(&value["value"])? })
    }
}


impl ToJSON for LiteralBooleanExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("LiteralBooleanExpression"),
             "value" => self.value.export()
        }
    }
}


impl Walker for LiteralBooleanExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::LiteralBooleanExpression);
        visitor.enter_literal_boolean_expression(path, self)?;
        path.enter_field(ASTField::Value);
        self.value.walk(path, visitor)?;
        path.exit_field(ASTField::Value);
        visitor.exit_literal_boolean_expression(path, self)?;
        path.exit_interface(ASTNode::LiteralBooleanExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct LiteralInfinityExpression {

}

impl FromJSON for LiteralInfinityExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("LiteralInfinityExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of LiteralInfinityExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(LiteralInfinityExpression {  })
    }
}


impl ToJSON for LiteralInfinityExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("LiteralInfinityExpression"),

        }
    }
}


impl Walker for LiteralInfinityExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::LiteralInfinityExpression);
        visitor.enter_literal_infinity_expression(path, self)?;

        visitor.exit_literal_infinity_expression(path, self)?;
        path.exit_interface(ASTNode::LiteralInfinityExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct LiteralNullExpression {

}

impl FromJSON for LiteralNullExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("LiteralNullExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of LiteralNullExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(LiteralNullExpression {  })
    }
}


impl ToJSON for LiteralNullExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("LiteralNullExpression"),

        }
    }
}


impl Walker for LiteralNullExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::LiteralNullExpression);
        visitor.enter_literal_null_expression(path, self)?;

        visitor.exit_literal_null_expression(path, self)?;
        path.exit_interface(ASTNode::LiteralNullExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct LiteralNumericExpression {
    pub value: f64
}

impl FromJSON for LiteralNumericExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("LiteralNumericExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of LiteralNumericExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(LiteralNumericExpression { value: FromJSON::import(&value["value"])? })
    }
}


impl ToJSON for LiteralNumericExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("LiteralNumericExpression"),
             "value" => self.value.export()
        }
    }
}


impl Walker for LiteralNumericExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::LiteralNumericExpression);
        visitor.enter_literal_numeric_expression(path, self)?;
        path.enter_field(ASTField::Value);
        self.value.walk(path, visitor)?;
        path.exit_field(ASTField::Value);
        visitor.exit_literal_numeric_expression(path, self)?;
        path.exit_interface(ASTNode::LiteralNumericExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct LiteralPropertyName {
    pub value: String
}

impl FromJSON for LiteralPropertyName {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("LiteralPropertyName") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of LiteralPropertyName".to_string(),
                got: value.dump()
            })
        }
        Ok(LiteralPropertyName { value: FromJSON::import(&value["value"])? })
    }
}


impl ToJSON for LiteralPropertyName {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("LiteralPropertyName"),
             "value" => self.value.export()
        }
    }
}


impl Walker for LiteralPropertyName {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::LiteralPropertyName);
        visitor.enter_literal_property_name(path, self)?;
        path.enter_field(ASTField::Value);
        self.value.walk(path, visitor)?;
        path.exit_field(ASTField::Value);
        visitor.exit_literal_property_name(path, self)?;
        path.exit_interface(ASTNode::LiteralPropertyName);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct LiteralRegExpExpression {
    pub pattern: String,
    pub flags: String
}

impl FromJSON for LiteralRegExpExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("LiteralRegExpExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of LiteralRegExpExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(LiteralRegExpExpression { pattern: FromJSON::import(&value["pattern"])?, flags: FromJSON::import(&value["flags"])? })
    }
}


impl ToJSON for LiteralRegExpExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("LiteralRegExpExpression"),
             "pattern" => self.pattern.export(),
             "flags" => self.flags.export()
        }
    }
}


impl Walker for LiteralRegExpExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::LiteralRegExpExpression);
        visitor.enter_literal_reg_exp_expression(path, self)?;
        path.enter_field(ASTField::Pattern);
        self.pattern.walk(path, visitor)?;
        path.exit_field(ASTField::Pattern);
        path.enter_field(ASTField::Flags);
        self.flags.walk(path, visitor)?;
        path.exit_field(ASTField::Flags);
        visitor.exit_literal_reg_exp_expression(path, self)?;
        path.exit_interface(ASTNode::LiteralRegExpExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct LiteralStringExpression {
    pub value: String
}

impl FromJSON for LiteralStringExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("LiteralStringExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of LiteralStringExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(LiteralStringExpression { value: FromJSON::import(&value["value"])? })
    }
}


impl ToJSON for LiteralStringExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("LiteralStringExpression"),
             "value" => self.value.export()
        }
    }
}


impl Walker for LiteralStringExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::LiteralStringExpression);
        visitor.enter_literal_string_expression(path, self)?;
        path.enter_field(ASTField::Value);
        self.value.walk(path, visitor)?;
        path.exit_field(ASTField::Value);
        visitor.exit_literal_string_expression(path, self)?;
        path.exit_interface(ASTNode::LiteralStringExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct Method {
    pub is_async: bool,
    pub is_generator: bool,
    pub parameter_scope: OptionalAssertedParameterScope,
    pub body_scope: OptionalAssertedVarScope,
    pub name: PropertyName,
    pub params: FormalParameters,
    pub body: FunctionBody
}

impl FromJSON for Method {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("Method") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of Method".to_string(),
                got: value.dump()
            })
        }
        Ok(Method { is_async: FromJSON::import(&value["isAsync"])?, is_generator: FromJSON::import(&value["isGenerator"])?, parameter_scope: FromJSON::import(&value["parameterScope"])?, body_scope: FromJSON::import(&value["bodyScope"])?, name: FromJSON::import(&value["name"])?, params: FromJSON::import(&value["params"])?, body: FromJSON::import(&value["body"])? })
    }
}


impl ToJSON for Method {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("Method"),
             "isAsync" => self.is_async.export(),
             "isGenerator" => self.is_generator.export(),
             "parameterScope" => self.parameter_scope.export(),
             "bodyScope" => self.body_scope.export(),
             "name" => self.name.export(),
             "params" => self.params.export(),
             "body" => self.body.export()
        }
    }
}


impl Walker for Method {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::Method);
        visitor.enter_method(path, self)?;
        path.enter_field(ASTField::IsAsync);
        self.is_async.walk(path, visitor)?;
        path.exit_field(ASTField::IsAsync);
        path.enter_field(ASTField::IsGenerator);
        self.is_generator.walk(path, visitor)?;
        path.exit_field(ASTField::IsGenerator);
        path.enter_field(ASTField::ParameterScope);
        self.parameter_scope.walk(path, visitor)?;
        path.exit_field(ASTField::ParameterScope);
        path.enter_field(ASTField::BodyScope);
        self.body_scope.walk(path, visitor)?;
        path.exit_field(ASTField::BodyScope);
        path.enter_field(ASTField::Name);
        self.name.walk(path, visitor)?;
        path.exit_field(ASTField::Name);
        path.enter_field(ASTField::Params);
        self.params.walk(path, visitor)?;
        path.exit_field(ASTField::Params);
        path.enter_field(ASTField::Body);
        self.body.walk(path, visitor)?;
        path.exit_field(ASTField::Body);
        visitor.exit_method(path, self)?;
        path.exit_interface(ASTNode::Method);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct Module {
    pub scope: OptionalAssertedVarScope,
    pub directives: ListOfDirective,
    pub items: ListOfImportDeclarationOrExportDeclarationOrStatement
}

impl FromJSON for Module {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("Module") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of Module".to_string(),
                got: value.dump()
            })
        }
        Ok(Module { scope: FromJSON::import(&value["scope"])?, directives: FromJSON::import(&value["directives"])?, items: FromJSON::import(&value["items"])? })
    }
}


impl ToJSON for Module {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("Module"),
             "scope" => self.scope.export(),
             "directives" => self.directives.export(),
             "items" => self.items.export()
        }
    }
}


impl Walker for Module {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::Module);
        visitor.enter_module(path, self)?;
        path.enter_field(ASTField::Scope);
        self.scope.walk(path, visitor)?;
        path.exit_field(ASTField::Scope);
        path.enter_field(ASTField::Directives);
        self.directives.walk(path, visitor)?;
        path.exit_field(ASTField::Directives);
        path.enter_field(ASTField::Items);
        self.items.walk(path, visitor)?;
        path.exit_field(ASTField::Items);
        visitor.exit_module(path, self)?;
        path.exit_interface(ASTNode::Module);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct NewExpression {
    pub callee: Expression,
    pub arguments: Arguments
}

impl FromJSON for NewExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("NewExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of NewExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(NewExpression { callee: FromJSON::import(&value["callee"])?, arguments: FromJSON::import(&value["arguments"])? })
    }
}


impl ToJSON for NewExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("NewExpression"),
             "callee" => self.callee.export(),
             "arguments" => self.arguments.export()
        }
    }
}


impl Walker for NewExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::NewExpression);
        visitor.enter_new_expression(path, self)?;
        path.enter_field(ASTField::Callee);
        self.callee.walk(path, visitor)?;
        path.exit_field(ASTField::Callee);
        path.enter_field(ASTField::Arguments);
        self.arguments.walk(path, visitor)?;
        path.exit_field(ASTField::Arguments);
        visitor.exit_new_expression(path, self)?;
        path.exit_interface(ASTNode::NewExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct NewTargetExpression {

}

impl FromJSON for NewTargetExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("NewTargetExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of NewTargetExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(NewTargetExpression {  })
    }
}


impl ToJSON for NewTargetExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("NewTargetExpression"),

        }
    }
}


impl Walker for NewTargetExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::NewTargetExpression);
        visitor.enter_new_target_expression(path, self)?;

        visitor.exit_new_target_expression(path, self)?;
        path.exit_interface(ASTNode::NewTargetExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ObjectAssignmentTarget {
    pub properties: ListOfAssignmentTargetProperty
}

impl FromJSON for ObjectAssignmentTarget {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ObjectAssignmentTarget") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ObjectAssignmentTarget".to_string(),
                got: value.dump()
            })
        }
        Ok(ObjectAssignmentTarget { properties: FromJSON::import(&value["properties"])? })
    }
}


impl ToJSON for ObjectAssignmentTarget {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ObjectAssignmentTarget"),
             "properties" => self.properties.export()
        }
    }
}


impl Walker for ObjectAssignmentTarget {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ObjectAssignmentTarget);
        visitor.enter_object_assignment_target(path, self)?;
        path.enter_field(ASTField::Properties);
        self.properties.walk(path, visitor)?;
        path.exit_field(ASTField::Properties);
        visitor.exit_object_assignment_target(path, self)?;
        path.exit_interface(ASTNode::ObjectAssignmentTarget);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ObjectBinding {
    pub properties: ListOfBindingProperty
}

impl FromJSON for ObjectBinding {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ObjectBinding") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ObjectBinding".to_string(),
                got: value.dump()
            })
        }
        Ok(ObjectBinding { properties: FromJSON::import(&value["properties"])? })
    }
}


impl ToJSON for ObjectBinding {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ObjectBinding"),
             "properties" => self.properties.export()
        }
    }
}


impl Walker for ObjectBinding {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ObjectBinding);
        visitor.enter_object_binding(path, self)?;
        path.enter_field(ASTField::Properties);
        self.properties.walk(path, visitor)?;
        path.exit_field(ASTField::Properties);
        visitor.exit_object_binding(path, self)?;
        path.exit_interface(ASTNode::ObjectBinding);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ObjectExpression {
    pub properties: ListOfObjectProperty
}

impl FromJSON for ObjectExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ObjectExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ObjectExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(ObjectExpression { properties: FromJSON::import(&value["properties"])? })
    }
}


impl ToJSON for ObjectExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ObjectExpression"),
             "properties" => self.properties.export()
        }
    }
}


impl Walker for ObjectExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ObjectExpression);
        visitor.enter_object_expression(path, self)?;
        path.enter_field(ASTField::Properties);
        self.properties.walk(path, visitor)?;
        path.exit_field(ASTField::Properties);
        visitor.exit_object_expression(path, self)?;
        path.exit_interface(ASTNode::ObjectExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ReturnStatement {
    pub expression: OptionalExpression
}

impl FromJSON for ReturnStatement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ReturnStatement") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ReturnStatement".to_string(),
                got: value.dump()
            })
        }
        Ok(ReturnStatement { expression: FromJSON::import(&value["expression"])? })
    }
}


impl ToJSON for ReturnStatement {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ReturnStatement"),
             "expression" => self.expression.export()
        }
    }
}


impl Walker for ReturnStatement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ReturnStatement);
        visitor.enter_return_statement(path, self)?;
        path.enter_field(ASTField::Expression);
        self.expression.walk(path, visitor)?;
        path.exit_field(ASTField::Expression);
        visitor.exit_return_statement(path, self)?;
        path.exit_interface(ASTNode::ReturnStatement);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct Script {
    pub scope: OptionalAssertedVarScope,
    pub directives: ListOfDirective,
    pub statements: ListOfStatement
}

impl FromJSON for Script {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("Script") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of Script".to_string(),
                got: value.dump()
            })
        }
        Ok(Script { scope: FromJSON::import(&value["scope"])?, directives: FromJSON::import(&value["directives"])?, statements: FromJSON::import(&value["statements"])? })
    }
}


impl ToJSON for Script {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("Script"),
             "scope" => self.scope.export(),
             "directives" => self.directives.export(),
             "statements" => self.statements.export()
        }
    }
}


impl Walker for Script {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::Script);
        visitor.enter_script(path, self)?;
        path.enter_field(ASTField::Scope);
        self.scope.walk(path, visitor)?;
        path.exit_field(ASTField::Scope);
        path.enter_field(ASTField::Directives);
        self.directives.walk(path, visitor)?;
        path.exit_field(ASTField::Directives);
        path.enter_field(ASTField::Statements);
        self.statements.walk(path, visitor)?;
        path.exit_field(ASTField::Statements);
        visitor.exit_script(path, self)?;
        path.exit_interface(ASTNode::Script);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct Setter {
    pub parameter_scope: OptionalAssertedParameterScope,
    pub body_scope: OptionalAssertedVarScope,
    pub name: PropertyName,
    pub param: Parameter,
    pub body: FunctionBody
}

impl FromJSON for Setter {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("Setter") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of Setter".to_string(),
                got: value.dump()
            })
        }
        Ok(Setter { parameter_scope: FromJSON::import(&value["parameterScope"])?, body_scope: FromJSON::import(&value["bodyScope"])?, name: FromJSON::import(&value["name"])?, param: FromJSON::import(&value["param"])?, body: FromJSON::import(&value["body"])? })
    }
}


impl ToJSON for Setter {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("Setter"),
             "parameterScope" => self.parameter_scope.export(),
             "bodyScope" => self.body_scope.export(),
             "name" => self.name.export(),
             "param" => self.param.export(),
             "body" => self.body.export()
        }
    }
}


impl Walker for Setter {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::Setter);
        visitor.enter_setter(path, self)?;
        path.enter_field(ASTField::ParameterScope);
        self.parameter_scope.walk(path, visitor)?;
        path.exit_field(ASTField::ParameterScope);
        path.enter_field(ASTField::BodyScope);
        self.body_scope.walk(path, visitor)?;
        path.exit_field(ASTField::BodyScope);
        path.enter_field(ASTField::Name);
        self.name.walk(path, visitor)?;
        path.exit_field(ASTField::Name);
        path.enter_field(ASTField::Param);
        self.param.walk(path, visitor)?;
        path.exit_field(ASTField::Param);
        path.enter_field(ASTField::Body);
        self.body.walk(path, visitor)?;
        path.exit_field(ASTField::Body);
        visitor.exit_setter(path, self)?;
        path.exit_interface(ASTNode::Setter);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ShorthandProperty {
    pub name: IdentifierExpression
}

impl FromJSON for ShorthandProperty {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ShorthandProperty") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ShorthandProperty".to_string(),
                got: value.dump()
            })
        }
        Ok(ShorthandProperty { name: FromJSON::import(&value["name"])? })
    }
}


impl ToJSON for ShorthandProperty {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ShorthandProperty"),
             "name" => self.name.export()
        }
    }
}


impl Walker for ShorthandProperty {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ShorthandProperty);
        visitor.enter_shorthand_property(path, self)?;
        path.enter_field(ASTField::Name);
        self.name.walk(path, visitor)?;
        path.exit_field(ASTField::Name);
        visitor.exit_shorthand_property(path, self)?;
        path.exit_interface(ASTNode::ShorthandProperty);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct SpreadElement {
    pub expression: Expression
}

impl FromJSON for SpreadElement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("SpreadElement") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of SpreadElement".to_string(),
                got: value.dump()
            })
        }
        Ok(SpreadElement { expression: FromJSON::import(&value["expression"])? })
    }
}


impl ToJSON for SpreadElement {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("SpreadElement"),
             "expression" => self.expression.export()
        }
    }
}


impl Walker for SpreadElement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::SpreadElement);
        visitor.enter_spread_element(path, self)?;
        path.enter_field(ASTField::Expression);
        self.expression.walk(path, visitor)?;
        path.exit_field(ASTField::Expression);
        visitor.exit_spread_element(path, self)?;
        path.exit_interface(ASTNode::SpreadElement);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct StaticMemberAssignmentTarget {
    pub object: ExpressionOrSuper,
    pub property: IdentifierName
}

impl FromJSON for StaticMemberAssignmentTarget {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("StaticMemberAssignmentTarget") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of StaticMemberAssignmentTarget".to_string(),
                got: value.dump()
            })
        }
        Ok(StaticMemberAssignmentTarget { object: FromJSON::import(&value["object"])?, property: FromJSON::import(&value["property"])? })
    }
}


impl ToJSON for StaticMemberAssignmentTarget {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("StaticMemberAssignmentTarget"),
             "object" => self.object.export(),
             "property" => self.property.export()
        }
    }
}


impl Walker for StaticMemberAssignmentTarget {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::StaticMemberAssignmentTarget);
        visitor.enter_static_member_assignment_target(path, self)?;
        path.enter_field(ASTField::Object);
        self.object.walk(path, visitor)?;
        path.exit_field(ASTField::Object);
        path.enter_field(ASTField::Property);
        self.property.walk(path, visitor)?;
        path.exit_field(ASTField::Property);
        visitor.exit_static_member_assignment_target(path, self)?;
        path.exit_interface(ASTNode::StaticMemberAssignmentTarget);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct StaticMemberExpression {
    pub object: ExpressionOrSuper,
    pub property: IdentifierName
}

impl FromJSON for StaticMemberExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("StaticMemberExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of StaticMemberExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(StaticMemberExpression { object: FromJSON::import(&value["object"])?, property: FromJSON::import(&value["property"])? })
    }
}


impl ToJSON for StaticMemberExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("StaticMemberExpression"),
             "object" => self.object.export(),
             "property" => self.property.export()
        }
    }
}


impl Walker for StaticMemberExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::StaticMemberExpression);
        visitor.enter_static_member_expression(path, self)?;
        path.enter_field(ASTField::Object);
        self.object.walk(path, visitor)?;
        path.exit_field(ASTField::Object);
        path.enter_field(ASTField::Property);
        self.property.walk(path, visitor)?;
        path.exit_field(ASTField::Property);
        visitor.exit_static_member_expression(path, self)?;
        path.exit_interface(ASTNode::StaticMemberExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct Super {

}

impl FromJSON for Super {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("Super") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of Super".to_string(),
                got: value.dump()
            })
        }
        Ok(Super {  })
    }
}


impl ToJSON for Super {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("Super"),

        }
    }
}


impl Walker for Super {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::Super);
        visitor.enter_super_(path, self)?;

        visitor.exit_super_(path, self)?;
        path.exit_interface(ASTNode::Super);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct SwitchCase {
    pub test: Expression,
    pub consequent: ListOfStatement
}

impl FromJSON for SwitchCase {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("SwitchCase") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of SwitchCase".to_string(),
                got: value.dump()
            })
        }
        Ok(SwitchCase { test: FromJSON::import(&value["test"])?, consequent: FromJSON::import(&value["consequent"])? })
    }
}


impl ToJSON for SwitchCase {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("SwitchCase"),
             "test" => self.test.export(),
             "consequent" => self.consequent.export()
        }
    }
}


impl Walker for SwitchCase {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::SwitchCase);
        visitor.enter_switch_case(path, self)?;
        path.enter_field(ASTField::Test);
        self.test.walk(path, visitor)?;
        path.exit_field(ASTField::Test);
        path.enter_field(ASTField::Consequent);
        self.consequent.walk(path, visitor)?;
        path.exit_field(ASTField::Consequent);
        visitor.exit_switch_case(path, self)?;
        path.exit_interface(ASTNode::SwitchCase);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct SwitchDefault {
    pub consequent: ListOfStatement
}

impl FromJSON for SwitchDefault {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("SwitchDefault") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of SwitchDefault".to_string(),
                got: value.dump()
            })
        }
        Ok(SwitchDefault { consequent: FromJSON::import(&value["consequent"])? })
    }
}


impl ToJSON for SwitchDefault {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("SwitchDefault"),
             "consequent" => self.consequent.export()
        }
    }
}


impl Walker for SwitchDefault {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::SwitchDefault);
        visitor.enter_switch_default(path, self)?;
        path.enter_field(ASTField::Consequent);
        self.consequent.walk(path, visitor)?;
        path.exit_field(ASTField::Consequent);
        visitor.exit_switch_default(path, self)?;
        path.exit_interface(ASTNode::SwitchDefault);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct SwitchStatement {
    pub discriminant: Expression,
    pub cases: ListOfSwitchCase
}

impl FromJSON for SwitchStatement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("SwitchStatement") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of SwitchStatement".to_string(),
                got: value.dump()
            })
        }
        Ok(SwitchStatement { discriminant: FromJSON::import(&value["discriminant"])?, cases: FromJSON::import(&value["cases"])? })
    }
}


impl ToJSON for SwitchStatement {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("SwitchStatement"),
             "discriminant" => self.discriminant.export(),
             "cases" => self.cases.export()
        }
    }
}


impl Walker for SwitchStatement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::SwitchStatement);
        visitor.enter_switch_statement(path, self)?;
        path.enter_field(ASTField::Discriminant);
        self.discriminant.walk(path, visitor)?;
        path.exit_field(ASTField::Discriminant);
        path.enter_field(ASTField::Cases);
        self.cases.walk(path, visitor)?;
        path.exit_field(ASTField::Cases);
        visitor.exit_switch_statement(path, self)?;
        path.exit_interface(ASTNode::SwitchStatement);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct SwitchStatementWithDefault {
    pub discriminant: Expression,
    pub pre_default_cases: ListOfSwitchCase,
    pub default_case: SwitchDefault,
    pub post_default_cases: ListOfSwitchCase
}

impl FromJSON for SwitchStatementWithDefault {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("SwitchStatementWithDefault") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of SwitchStatementWithDefault".to_string(),
                got: value.dump()
            })
        }
        Ok(SwitchStatementWithDefault { discriminant: FromJSON::import(&value["discriminant"])?, pre_default_cases: FromJSON::import(&value["preDefaultCases"])?, default_case: FromJSON::import(&value["defaultCase"])?, post_default_cases: FromJSON::import(&value["postDefaultCases"])? })
    }
}


impl ToJSON for SwitchStatementWithDefault {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("SwitchStatementWithDefault"),
             "discriminant" => self.discriminant.export(),
             "preDefaultCases" => self.pre_default_cases.export(),
             "defaultCase" => self.default_case.export(),
             "postDefaultCases" => self.post_default_cases.export()
        }
    }
}


impl Walker for SwitchStatementWithDefault {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::SwitchStatementWithDefault);
        visitor.enter_switch_statement_with_default(path, self)?;
        path.enter_field(ASTField::Discriminant);
        self.discriminant.walk(path, visitor)?;
        path.exit_field(ASTField::Discriminant);
        path.enter_field(ASTField::PreDefaultCases);
        self.pre_default_cases.walk(path, visitor)?;
        path.exit_field(ASTField::PreDefaultCases);
        path.enter_field(ASTField::DefaultCase);
        self.default_case.walk(path, visitor)?;
        path.exit_field(ASTField::DefaultCase);
        path.enter_field(ASTField::PostDefaultCases);
        self.post_default_cases.walk(path, visitor)?;
        path.exit_field(ASTField::PostDefaultCases);
        visitor.exit_switch_statement_with_default(path, self)?;
        path.exit_interface(ASTNode::SwitchStatementWithDefault);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct TemplateElement {
    pub raw_value: String
}

impl FromJSON for TemplateElement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("TemplateElement") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of TemplateElement".to_string(),
                got: value.dump()
            })
        }
        Ok(TemplateElement { raw_value: FromJSON::import(&value["rawValue"])? })
    }
}


impl ToJSON for TemplateElement {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("TemplateElement"),
             "rawValue" => self.raw_value.export()
        }
    }
}


impl Walker for TemplateElement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::TemplateElement);
        visitor.enter_template_element(path, self)?;
        path.enter_field(ASTField::RawValue);
        self.raw_value.walk(path, visitor)?;
        path.exit_field(ASTField::RawValue);
        visitor.exit_template_element(path, self)?;
        path.exit_interface(ASTNode::TemplateElement);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct TemplateExpression {
    pub tag: OptionalExpression,
    pub elements: ListOfExpressionOrTemplateElement
}

impl FromJSON for TemplateExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("TemplateExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of TemplateExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(TemplateExpression { tag: FromJSON::import(&value["tag"])?, elements: FromJSON::import(&value["elements"])? })
    }
}


impl ToJSON for TemplateExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("TemplateExpression"),
             "tag" => self.tag.export(),
             "elements" => self.elements.export()
        }
    }
}


impl Walker for TemplateExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::TemplateExpression);
        visitor.enter_template_expression(path, self)?;
        path.enter_field(ASTField::Tag);
        self.tag.walk(path, visitor)?;
        path.exit_field(ASTField::Tag);
        path.enter_field(ASTField::Elements);
        self.elements.walk(path, visitor)?;
        path.exit_field(ASTField::Elements);
        visitor.exit_template_expression(path, self)?;
        path.exit_interface(ASTNode::TemplateExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ThisExpression {

}

impl FromJSON for ThisExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ThisExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ThisExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(ThisExpression {  })
    }
}


impl ToJSON for ThisExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ThisExpression"),

        }
    }
}


impl Walker for ThisExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ThisExpression);
        visitor.enter_this_expression(path, self)?;

        visitor.exit_this_expression(path, self)?;
        path.exit_interface(ASTNode::ThisExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct ThrowStatement {
    pub expression: Expression
}

impl FromJSON for ThrowStatement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("ThrowStatement") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of ThrowStatement".to_string(),
                got: value.dump()
            })
        }
        Ok(ThrowStatement { expression: FromJSON::import(&value["expression"])? })
    }
}


impl ToJSON for ThrowStatement {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("ThrowStatement"),
             "expression" => self.expression.export()
        }
    }
}


impl Walker for ThrowStatement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::ThrowStatement);
        visitor.enter_throw_statement(path, self)?;
        path.enter_field(ASTField::Expression);
        self.expression.walk(path, visitor)?;
        path.exit_field(ASTField::Expression);
        visitor.exit_throw_statement(path, self)?;
        path.exit_interface(ASTNode::ThrowStatement);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct TryCatchStatement {
    pub body: Block,
    pub catch_clause: CatchClause
}

impl FromJSON for TryCatchStatement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("TryCatchStatement") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of TryCatchStatement".to_string(),
                got: value.dump()
            })
        }
        Ok(TryCatchStatement { body: FromJSON::import(&value["body"])?, catch_clause: FromJSON::import(&value["catchClause"])? })
    }
}


impl ToJSON for TryCatchStatement {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("TryCatchStatement"),
             "body" => self.body.export(),
             "catchClause" => self.catch_clause.export()
        }
    }
}


impl Walker for TryCatchStatement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::TryCatchStatement);
        visitor.enter_try_catch_statement(path, self)?;
        path.enter_field(ASTField::Body);
        self.body.walk(path, visitor)?;
        path.exit_field(ASTField::Body);
        path.enter_field(ASTField::CatchClause);
        self.catch_clause.walk(path, visitor)?;
        path.exit_field(ASTField::CatchClause);
        visitor.exit_try_catch_statement(path, self)?;
        path.exit_interface(ASTNode::TryCatchStatement);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct TryFinallyStatement {
    pub body: Block,
    pub catch_clause: OptionalCatchClause,
    pub finalizer: Block
}

impl FromJSON for TryFinallyStatement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("TryFinallyStatement") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of TryFinallyStatement".to_string(),
                got: value.dump()
            })
        }
        Ok(TryFinallyStatement { body: FromJSON::import(&value["body"])?, catch_clause: FromJSON::import(&value["catchClause"])?, finalizer: FromJSON::import(&value["finalizer"])? })
    }
}


impl ToJSON for TryFinallyStatement {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("TryFinallyStatement"),
             "body" => self.body.export(),
             "catchClause" => self.catch_clause.export(),
             "finalizer" => self.finalizer.export()
        }
    }
}


impl Walker for TryFinallyStatement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::TryFinallyStatement);
        visitor.enter_try_finally_statement(path, self)?;
        path.enter_field(ASTField::Body);
        self.body.walk(path, visitor)?;
        path.exit_field(ASTField::Body);
        path.enter_field(ASTField::CatchClause);
        self.catch_clause.walk(path, visitor)?;
        path.exit_field(ASTField::CatchClause);
        path.enter_field(ASTField::Finalizer);
        self.finalizer.walk(path, visitor)?;
        path.exit_field(ASTField::Finalizer);
        visitor.exit_try_finally_statement(path, self)?;
        path.exit_interface(ASTNode::TryFinallyStatement);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct UnaryExpression {
    pub operator: UnaryOperator,
    pub operand: Expression
}

impl FromJSON for UnaryExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("UnaryExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of UnaryExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(UnaryExpression { operator: FromJSON::import(&value["operator"])?, operand: FromJSON::import(&value["operand"])? })
    }
}


impl ToJSON for UnaryExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("UnaryExpression"),
             "operator" => self.operator.export(),
             "operand" => self.operand.export()
        }
    }
}


impl Walker for UnaryExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::UnaryExpression);
        visitor.enter_unary_expression(path, self)?;
        path.enter_field(ASTField::Operator);
        self.operator.walk(path, visitor)?;
        path.exit_field(ASTField::Operator);
        path.enter_field(ASTField::Operand);
        self.operand.walk(path, visitor)?;
        path.exit_field(ASTField::Operand);
        visitor.exit_unary_expression(path, self)?;
        path.exit_interface(ASTNode::UnaryExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct UpdateExpression {
    pub is_prefix: bool,
    pub operator: UpdateOperator,
    pub operand: SimpleAssignmentTarget
}

impl FromJSON for UpdateExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("UpdateExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of UpdateExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(UpdateExpression { is_prefix: FromJSON::import(&value["isPrefix"])?, operator: FromJSON::import(&value["operator"])?, operand: FromJSON::import(&value["operand"])? })
    }
}


impl ToJSON for UpdateExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("UpdateExpression"),
             "isPrefix" => self.is_prefix.export(),
             "operator" => self.operator.export(),
             "operand" => self.operand.export()
        }
    }
}


impl Walker for UpdateExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::UpdateExpression);
        visitor.enter_update_expression(path, self)?;
        path.enter_field(ASTField::IsPrefix);
        self.is_prefix.walk(path, visitor)?;
        path.exit_field(ASTField::IsPrefix);
        path.enter_field(ASTField::Operator);
        self.operator.walk(path, visitor)?;
        path.exit_field(ASTField::Operator);
        path.enter_field(ASTField::Operand);
        self.operand.walk(path, visitor)?;
        path.exit_field(ASTField::Operand);
        visitor.exit_update_expression(path, self)?;
        path.exit_interface(ASTNode::UpdateExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct VariableDeclaration {
    pub kind: VariableDeclarationKind,
    pub declarators: ListOfVariableDeclarator
}

impl FromJSON for VariableDeclaration {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("VariableDeclaration") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of VariableDeclaration".to_string(),
                got: value.dump()
            })
        }
        Ok(VariableDeclaration { kind: FromJSON::import(&value["kind"])?, declarators: FromJSON::import(&value["declarators"])? })
    }
}


impl ToJSON for VariableDeclaration {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("VariableDeclaration"),
             "kind" => self.kind.export(),
             "declarators" => self.declarators.export()
        }
    }
}


impl Walker for VariableDeclaration {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::VariableDeclaration);
        visitor.enter_variable_declaration(path, self)?;
        path.enter_field(ASTField::Kind);
        self.kind.walk(path, visitor)?;
        path.exit_field(ASTField::Kind);
        path.enter_field(ASTField::Declarators);
        self.declarators.walk(path, visitor)?;
        path.exit_field(ASTField::Declarators);
        visitor.exit_variable_declaration(path, self)?;
        path.exit_interface(ASTNode::VariableDeclaration);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct VariableDeclarator {
    pub binding: Binding,
    pub init: OptionalExpression
}

impl FromJSON for VariableDeclarator {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("VariableDeclarator") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of VariableDeclarator".to_string(),
                got: value.dump()
            })
        }
        Ok(VariableDeclarator { binding: FromJSON::import(&value["binding"])?, init: FromJSON::import(&value["init"])? })
    }
}


impl ToJSON for VariableDeclarator {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("VariableDeclarator"),
             "binding" => self.binding.export(),
             "init" => self.init.export()
        }
    }
}


impl Walker for VariableDeclarator {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::VariableDeclarator);
        visitor.enter_variable_declarator(path, self)?;
        path.enter_field(ASTField::Binding);
        self.binding.walk(path, visitor)?;
        path.exit_field(ASTField::Binding);
        path.enter_field(ASTField::Init);
        self.init.walk(path, visitor)?;
        path.exit_field(ASTField::Init);
        visitor.exit_variable_declarator(path, self)?;
        path.exit_interface(ASTNode::VariableDeclarator);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct WhileStatement {
    pub test: Expression,
    pub body: Statement
}

impl FromJSON for WhileStatement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("WhileStatement") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of WhileStatement".to_string(),
                got: value.dump()
            })
        }
        Ok(WhileStatement { test: FromJSON::import(&value["test"])?, body: FromJSON::import(&value["body"])? })
    }
}


impl ToJSON for WhileStatement {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("WhileStatement"),
             "test" => self.test.export(),
             "body" => self.body.export()
        }
    }
}


impl Walker for WhileStatement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::WhileStatement);
        visitor.enter_while_statement(path, self)?;
        path.enter_field(ASTField::Test);
        self.test.walk(path, visitor)?;
        path.exit_field(ASTField::Test);
        path.enter_field(ASTField::Body);
        self.body.walk(path, visitor)?;
        path.exit_field(ASTField::Body);
        visitor.exit_while_statement(path, self)?;
        path.exit_interface(ASTNode::WhileStatement);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct WithStatement {
    pub object: Expression,
    pub body: Statement
}

impl FromJSON for WithStatement {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("WithStatement") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of WithStatement".to_string(),
                got: value.dump()
            })
        }
        Ok(WithStatement { object: FromJSON::import(&value["object"])?, body: FromJSON::import(&value["body"])? })
    }
}


impl ToJSON for WithStatement {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("WithStatement"),
             "object" => self.object.export(),
             "body" => self.body.export()
        }
    }
}


impl Walker for WithStatement {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::WithStatement);
        visitor.enter_with_statement(path, self)?;
        path.enter_field(ASTField::Object);
        self.object.walk(path, visitor)?;
        path.exit_field(ASTField::Object);
        path.enter_field(ASTField::Body);
        self.body.walk(path, visitor)?;
        path.exit_field(ASTField::Body);
        visitor.exit_with_statement(path, self)?;
        path.exit_interface(ASTNode::WithStatement);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct YieldExpression {
    pub expression: OptionalExpression
}

impl FromJSON for YieldExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("YieldExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of YieldExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(YieldExpression { expression: FromJSON::import(&value["expression"])? })
    }
}


impl ToJSON for YieldExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("YieldExpression"),
             "expression" => self.expression.export()
        }
    }
}


impl Walker for YieldExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::YieldExpression);
        visitor.enter_yield_expression(path, self)?;
        path.enter_field(ASTField::Expression);
        self.expression.walk(path, visitor)?;
        path.exit_field(ASTField::Expression);
        visitor.exit_yield_expression(path, self)?;
        path.exit_interface(ASTNode::YieldExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct YieldStarExpression {
    pub expression: Expression
}

impl FromJSON for YieldStarExpression {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("YieldStarExpression") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of YieldStarExpression".to_string(),
                got: value.dump()
            })
        }
        Ok(YieldStarExpression { expression: FromJSON::import(&value["expression"])? })
    }
}


impl ToJSON for YieldStarExpression {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("YieldStarExpression"),
             "expression" => self.expression.export()
        }
    }
}


impl Walker for YieldStarExpression {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::YieldStarExpression);
        visitor.enter_yield_star_expression(path, self)?;
        path.enter_field(ASTField::Expression);
        self.expression.walk(path, visitor)?;
        path.exit_field(ASTField::Expression);
        visitor.exit_yield_star_expression(path, self)?;
        path.exit_interface(ASTNode::YieldStarExpression);
        Ok(())
    }
}



#[derive(PartialEq, Debug, Clone)]
pub struct Null {

}

impl FromJSON for Null {
    fn import(value: &JSON) -> Result<Self, FromJSONError> {
        match value["type"].as_str() {
            Some("Null") => { /* Good */ },
            _ => return Err(FromJSONError {
                expected: "Instance of Null".to_string(),
                got: value.dump()
            })
        }
        Ok(Null {  })
    }
}


impl ToJSON for Null {
    fn export(&self) -> JSON {
        object!{
            "type" => json::from("Null"),

        }
    }
}


impl Walker for Null {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        path.enter_interface(ASTNode::Null);
        visitor.enter_null(path, self)?;

        visitor.exit_null(path, self)?;
        path.exit_interface(ASTNode::Null);
        Ok(())
    }
}



#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum ASTNode {
    ArrayAssignmentTarget,
    ArrayBinding,
    ArrayExpression,
    ArrowExpression,
    AssertedBlockScope,
    AssertedParameterScope,
    AssertedVarScope,
    AssignmentExpression,
    AssignmentTargetIdentifier,
    AssignmentTargetPropertyIdentifier,
    AssignmentTargetPropertyProperty,
    AssignmentTargetWithInitializer,
    AwaitExpression,
    BinaryExpression,
    BindingIdentifier,
    BindingPropertyIdentifier,
    BindingPropertyProperty,
    BindingWithInitializer,
    Block,
    BreakStatement,
    CallExpression,
    CatchClause,
    ClassDeclaration,
    ClassElement,
    ClassExpression,
    CompoundAssignmentExpression,
    ComputedMemberAssignmentTarget,
    ComputedMemberExpression,
    ComputedPropertyName,
    ConditionalExpression,
    ContinueStatement,
    DataProperty,
    DebuggerStatement,
    Directive,
    DoWhileStatement,
    EmptyStatement,
    Export,
    ExportAllFrom,
    ExportDefault,
    ExportFrom,
    ExportFromSpecifier,
    ExportLocalSpecifier,
    ExportLocals,
    ExpressionStatement,
    ForInOfBinding,
    ForInStatement,
    ForOfStatement,
    ForStatement,
    FormalParameters,
    FunctionBody,
    FunctionDeclaration,
    FunctionExpression,
    Getter,
    IdentifierExpression,
    IfStatement,
    Import,
    ImportNamespace,
    ImportSpecifier,
    LabelledStatement,
    LiteralBooleanExpression,
    LiteralInfinityExpression,
    LiteralNullExpression,
    LiteralNumericExpression,
    LiteralPropertyName,
    LiteralRegExpExpression,
    LiteralStringExpression,
    Method,
    Module,
    NewExpression,
    NewTargetExpression,
    ObjectAssignmentTarget,
    ObjectBinding,
    ObjectExpression,
    ReturnStatement,
    Script,
    Setter,
    ShorthandProperty,
    SpreadElement,
    StaticMemberAssignmentTarget,
    StaticMemberExpression,
    Super,
    SwitchCase,
    SwitchDefault,
    SwitchStatement,
    SwitchStatementWithDefault,
    TemplateElement,
    TemplateExpression,
    ThisExpression,
    ThrowStatement,
    TryCatchStatement,
    TryFinallyStatement,
    UnaryExpression,
    UpdateExpression,
    VariableDeclaration,
    VariableDeclarator,
    WhileStatement,
    WithStatement,
    YieldExpression,
    YieldStarExpression,
    Null
}



/// A set of callbacks used to inspect the contents of an AST in a strongly-typed
/// manner. For each node `Foo`, `enter_foo()` will be called before visiting the
/// children, giving the opportunity to alter the node, and `enter_foo()` will be
/// called after visiting the children, giving the opportunity to alter it further.
///
/// Each of the nodes of this AST implements `Walker` and may be visited recursively
/// using `Visitor`.
pub trait Visitor<E> {

    fn enter_array_assignment_target(&mut self, _path: &Path, _node: &mut ArrayAssignmentTarget) -> Result<(), E> {
        Ok(())
    }
    fn exit_array_assignment_target(&mut self, _path: &Path, _node: &mut ArrayAssignmentTarget) -> Result<(), E> {
        Ok(())
    }


    fn enter_array_binding(&mut self, _path: &Path, _node: &mut ArrayBinding) -> Result<(), E> {
        Ok(())
    }
    fn exit_array_binding(&mut self, _path: &Path, _node: &mut ArrayBinding) -> Result<(), E> {
        Ok(())
    }


    fn enter_array_expression(&mut self, _path: &Path, _node: &mut ArrayExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_array_expression(&mut self, _path: &Path, _node: &mut ArrayExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_arrow_expression(&mut self, _path: &Path, _node: &mut ArrowExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_arrow_expression(&mut self, _path: &Path, _node: &mut ArrowExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_asserted_block_scope(&mut self, _path: &Path, _node: &mut AssertedBlockScope) -> Result<(), E> {
        Ok(())
    }
    fn exit_asserted_block_scope(&mut self, _path: &Path, _node: &mut AssertedBlockScope) -> Result<(), E> {
        Ok(())
    }


    fn enter_asserted_parameter_scope(&mut self, _path: &Path, _node: &mut AssertedParameterScope) -> Result<(), E> {
        Ok(())
    }
    fn exit_asserted_parameter_scope(&mut self, _path: &Path, _node: &mut AssertedParameterScope) -> Result<(), E> {
        Ok(())
    }


    fn enter_asserted_var_scope(&mut self, _path: &Path, _node: &mut AssertedVarScope) -> Result<(), E> {
        Ok(())
    }
    fn exit_asserted_var_scope(&mut self, _path: &Path, _node: &mut AssertedVarScope) -> Result<(), E> {
        Ok(())
    }


    fn enter_assignment_expression(&mut self, _path: &Path, _node: &mut AssignmentExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_assignment_expression(&mut self, _path: &Path, _node: &mut AssignmentExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_assignment_target_identifier(&mut self, _path: &Path, _node: &mut AssignmentTargetIdentifier) -> Result<(), E> {
        Ok(())
    }
    fn exit_assignment_target_identifier(&mut self, _path: &Path, _node: &mut AssignmentTargetIdentifier) -> Result<(), E> {
        Ok(())
    }


    fn enter_assignment_target_property_identifier(&mut self, _path: &Path, _node: &mut AssignmentTargetPropertyIdentifier) -> Result<(), E> {
        Ok(())
    }
    fn exit_assignment_target_property_identifier(&mut self, _path: &Path, _node: &mut AssignmentTargetPropertyIdentifier) -> Result<(), E> {
        Ok(())
    }


    fn enter_assignment_target_property_property(&mut self, _path: &Path, _node: &mut AssignmentTargetPropertyProperty) -> Result<(), E> {
        Ok(())
    }
    fn exit_assignment_target_property_property(&mut self, _path: &Path, _node: &mut AssignmentTargetPropertyProperty) -> Result<(), E> {
        Ok(())
    }


    fn enter_assignment_target_with_initializer(&mut self, _path: &Path, _node: &mut AssignmentTargetWithInitializer) -> Result<(), E> {
        Ok(())
    }
    fn exit_assignment_target_with_initializer(&mut self, _path: &Path, _node: &mut AssignmentTargetWithInitializer) -> Result<(), E> {
        Ok(())
    }


    fn enter_await_expression(&mut self, _path: &Path, _node: &mut AwaitExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_await_expression(&mut self, _path: &Path, _node: &mut AwaitExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_binary_expression(&mut self, _path: &Path, _node: &mut BinaryExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_binary_expression(&mut self, _path: &Path, _node: &mut BinaryExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_binding_identifier(&mut self, _path: &Path, _node: &mut BindingIdentifier) -> Result<(), E> {
        Ok(())
    }
    fn exit_binding_identifier(&mut self, _path: &Path, _node: &mut BindingIdentifier) -> Result<(), E> {
        Ok(())
    }


    fn enter_binding_property_identifier(&mut self, _path: &Path, _node: &mut BindingPropertyIdentifier) -> Result<(), E> {
        Ok(())
    }
    fn exit_binding_property_identifier(&mut self, _path: &Path, _node: &mut BindingPropertyIdentifier) -> Result<(), E> {
        Ok(())
    }


    fn enter_binding_property_property(&mut self, _path: &Path, _node: &mut BindingPropertyProperty) -> Result<(), E> {
        Ok(())
    }
    fn exit_binding_property_property(&mut self, _path: &Path, _node: &mut BindingPropertyProperty) -> Result<(), E> {
        Ok(())
    }


    fn enter_binding_with_initializer(&mut self, _path: &Path, _node: &mut BindingWithInitializer) -> Result<(), E> {
        Ok(())
    }
    fn exit_binding_with_initializer(&mut self, _path: &Path, _node: &mut BindingWithInitializer) -> Result<(), E> {
        Ok(())
    }


    fn enter_block(&mut self, _path: &Path, _node: &mut Block) -> Result<(), E> {
        Ok(())
    }
    fn exit_block(&mut self, _path: &Path, _node: &mut Block) -> Result<(), E> {
        Ok(())
    }


    fn enter_break_statement(&mut self, _path: &Path, _node: &mut BreakStatement) -> Result<(), E> {
        Ok(())
    }
    fn exit_break_statement(&mut self, _path: &Path, _node: &mut BreakStatement) -> Result<(), E> {
        Ok(())
    }


    fn enter_call_expression(&mut self, _path: &Path, _node: &mut CallExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_call_expression(&mut self, _path: &Path, _node: &mut CallExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_catch_clause(&mut self, _path: &Path, _node: &mut CatchClause) -> Result<(), E> {
        Ok(())
    }
    fn exit_catch_clause(&mut self, _path: &Path, _node: &mut CatchClause) -> Result<(), E> {
        Ok(())
    }


    fn enter_class_declaration(&mut self, _path: &Path, _node: &mut ClassDeclaration) -> Result<(), E> {
        Ok(())
    }
    fn exit_class_declaration(&mut self, _path: &Path, _node: &mut ClassDeclaration) -> Result<(), E> {
        Ok(())
    }


    fn enter_class_element(&mut self, _path: &Path, _node: &mut ClassElement) -> Result<(), E> {
        Ok(())
    }
    fn exit_class_element(&mut self, _path: &Path, _node: &mut ClassElement) -> Result<(), E> {
        Ok(())
    }


    fn enter_class_expression(&mut self, _path: &Path, _node: &mut ClassExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_class_expression(&mut self, _path: &Path, _node: &mut ClassExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_compound_assignment_expression(&mut self, _path: &Path, _node: &mut CompoundAssignmentExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_compound_assignment_expression(&mut self, _path: &Path, _node: &mut CompoundAssignmentExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_computed_member_assignment_target(&mut self, _path: &Path, _node: &mut ComputedMemberAssignmentTarget) -> Result<(), E> {
        Ok(())
    }
    fn exit_computed_member_assignment_target(&mut self, _path: &Path, _node: &mut ComputedMemberAssignmentTarget) -> Result<(), E> {
        Ok(())
    }


    fn enter_computed_member_expression(&mut self, _path: &Path, _node: &mut ComputedMemberExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_computed_member_expression(&mut self, _path: &Path, _node: &mut ComputedMemberExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_computed_property_name(&mut self, _path: &Path, _node: &mut ComputedPropertyName) -> Result<(), E> {
        Ok(())
    }
    fn exit_computed_property_name(&mut self, _path: &Path, _node: &mut ComputedPropertyName) -> Result<(), E> {
        Ok(())
    }


    fn enter_conditional_expression(&mut self, _path: &Path, _node: &mut ConditionalExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_conditional_expression(&mut self, _path: &Path, _node: &mut ConditionalExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_continue_statement(&mut self, _path: &Path, _node: &mut ContinueStatement) -> Result<(), E> {
        Ok(())
    }
    fn exit_continue_statement(&mut self, _path: &Path, _node: &mut ContinueStatement) -> Result<(), E> {
        Ok(())
    }


    fn enter_data_property(&mut self, _path: &Path, _node: &mut DataProperty) -> Result<(), E> {
        Ok(())
    }
    fn exit_data_property(&mut self, _path: &Path, _node: &mut DataProperty) -> Result<(), E> {
        Ok(())
    }


    fn enter_debugger_statement(&mut self, _path: &Path, _node: &mut DebuggerStatement) -> Result<(), E> {
        Ok(())
    }
    fn exit_debugger_statement(&mut self, _path: &Path, _node: &mut DebuggerStatement) -> Result<(), E> {
        Ok(())
    }


    fn enter_directive(&mut self, _path: &Path, _node: &mut Directive) -> Result<(), E> {
        Ok(())
    }
    fn exit_directive(&mut self, _path: &Path, _node: &mut Directive) -> Result<(), E> {
        Ok(())
    }


    fn enter_do_while_statement(&mut self, _path: &Path, _node: &mut DoWhileStatement) -> Result<(), E> {
        Ok(())
    }
    fn exit_do_while_statement(&mut self, _path: &Path, _node: &mut DoWhileStatement) -> Result<(), E> {
        Ok(())
    }


    fn enter_empty_statement(&mut self, _path: &Path, _node: &mut EmptyStatement) -> Result<(), E> {
        Ok(())
    }
    fn exit_empty_statement(&mut self, _path: &Path, _node: &mut EmptyStatement) -> Result<(), E> {
        Ok(())
    }


    fn enter_export(&mut self, _path: &Path, _node: &mut Export) -> Result<(), E> {
        Ok(())
    }
    fn exit_export(&mut self, _path: &Path, _node: &mut Export) -> Result<(), E> {
        Ok(())
    }


    fn enter_export_all_from(&mut self, _path: &Path, _node: &mut ExportAllFrom) -> Result<(), E> {
        Ok(())
    }
    fn exit_export_all_from(&mut self, _path: &Path, _node: &mut ExportAllFrom) -> Result<(), E> {
        Ok(())
    }


    fn enter_export_default(&mut self, _path: &Path, _node: &mut ExportDefault) -> Result<(), E> {
        Ok(())
    }
    fn exit_export_default(&mut self, _path: &Path, _node: &mut ExportDefault) -> Result<(), E> {
        Ok(())
    }


    fn enter_export_from(&mut self, _path: &Path, _node: &mut ExportFrom) -> Result<(), E> {
        Ok(())
    }
    fn exit_export_from(&mut self, _path: &Path, _node: &mut ExportFrom) -> Result<(), E> {
        Ok(())
    }


    fn enter_export_from_specifier(&mut self, _path: &Path, _node: &mut ExportFromSpecifier) -> Result<(), E> {
        Ok(())
    }
    fn exit_export_from_specifier(&mut self, _path: &Path, _node: &mut ExportFromSpecifier) -> Result<(), E> {
        Ok(())
    }


    fn enter_export_local_specifier(&mut self, _path: &Path, _node: &mut ExportLocalSpecifier) -> Result<(), E> {
        Ok(())
    }
    fn exit_export_local_specifier(&mut self, _path: &Path, _node: &mut ExportLocalSpecifier) -> Result<(), E> {
        Ok(())
    }


    fn enter_export_locals(&mut self, _path: &Path, _node: &mut ExportLocals) -> Result<(), E> {
        Ok(())
    }
    fn exit_export_locals(&mut self, _path: &Path, _node: &mut ExportLocals) -> Result<(), E> {
        Ok(())
    }


    fn enter_expression_statement(&mut self, _path: &Path, _node: &mut ExpressionStatement) -> Result<(), E> {
        Ok(())
    }
    fn exit_expression_statement(&mut self, _path: &Path, _node: &mut ExpressionStatement) -> Result<(), E> {
        Ok(())
    }


    fn enter_for_in_of_binding(&mut self, _path: &Path, _node: &mut ForInOfBinding) -> Result<(), E> {
        Ok(())
    }
    fn exit_for_in_of_binding(&mut self, _path: &Path, _node: &mut ForInOfBinding) -> Result<(), E> {
        Ok(())
    }


    fn enter_for_in_statement(&mut self, _path: &Path, _node: &mut ForInStatement) -> Result<(), E> {
        Ok(())
    }
    fn exit_for_in_statement(&mut self, _path: &Path, _node: &mut ForInStatement) -> Result<(), E> {
        Ok(())
    }


    fn enter_for_of_statement(&mut self, _path: &Path, _node: &mut ForOfStatement) -> Result<(), E> {
        Ok(())
    }
    fn exit_for_of_statement(&mut self, _path: &Path, _node: &mut ForOfStatement) -> Result<(), E> {
        Ok(())
    }


    fn enter_for_statement(&mut self, _path: &Path, _node: &mut ForStatement) -> Result<(), E> {
        Ok(())
    }
    fn exit_for_statement(&mut self, _path: &Path, _node: &mut ForStatement) -> Result<(), E> {
        Ok(())
    }


    fn enter_formal_parameters(&mut self, _path: &Path, _node: &mut FormalParameters) -> Result<(), E> {
        Ok(())
    }
    fn exit_formal_parameters(&mut self, _path: &Path, _node: &mut FormalParameters) -> Result<(), E> {
        Ok(())
    }


    fn enter_function_body(&mut self, _path: &Path, _node: &mut FunctionBody) -> Result<(), E> {
        Ok(())
    }
    fn exit_function_body(&mut self, _path: &Path, _node: &mut FunctionBody) -> Result<(), E> {
        Ok(())
    }


    fn enter_function_declaration(&mut self, _path: &Path, _node: &mut FunctionDeclaration) -> Result<(), E> {
        Ok(())
    }
    fn exit_function_declaration(&mut self, _path: &Path, _node: &mut FunctionDeclaration) -> Result<(), E> {
        Ok(())
    }


    fn enter_function_expression(&mut self, _path: &Path, _node: &mut FunctionExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_function_expression(&mut self, _path: &Path, _node: &mut FunctionExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_getter(&mut self, _path: &Path, _node: &mut Getter) -> Result<(), E> {
        Ok(())
    }
    fn exit_getter(&mut self, _path: &Path, _node: &mut Getter) -> Result<(), E> {
        Ok(())
    }


    fn enter_identifier_expression(&mut self, _path: &Path, _node: &mut IdentifierExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_identifier_expression(&mut self, _path: &Path, _node: &mut IdentifierExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_if_statement(&mut self, _path: &Path, _node: &mut IfStatement) -> Result<(), E> {
        Ok(())
    }
    fn exit_if_statement(&mut self, _path: &Path, _node: &mut IfStatement) -> Result<(), E> {
        Ok(())
    }


    fn enter_import(&mut self, _path: &Path, _node: &mut Import) -> Result<(), E> {
        Ok(())
    }
    fn exit_import(&mut self, _path: &Path, _node: &mut Import) -> Result<(), E> {
        Ok(())
    }


    fn enter_import_namespace(&mut self, _path: &Path, _node: &mut ImportNamespace) -> Result<(), E> {
        Ok(())
    }
    fn exit_import_namespace(&mut self, _path: &Path, _node: &mut ImportNamespace) -> Result<(), E> {
        Ok(())
    }


    fn enter_import_specifier(&mut self, _path: &Path, _node: &mut ImportSpecifier) -> Result<(), E> {
        Ok(())
    }
    fn exit_import_specifier(&mut self, _path: &Path, _node: &mut ImportSpecifier) -> Result<(), E> {
        Ok(())
    }


    fn enter_labelled_statement(&mut self, _path: &Path, _node: &mut LabelledStatement) -> Result<(), E> {
        Ok(())
    }
    fn exit_labelled_statement(&mut self, _path: &Path, _node: &mut LabelledStatement) -> Result<(), E> {
        Ok(())
    }


    fn enter_literal_boolean_expression(&mut self, _path: &Path, _node: &mut LiteralBooleanExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_literal_boolean_expression(&mut self, _path: &Path, _node: &mut LiteralBooleanExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_literal_infinity_expression(&mut self, _path: &Path, _node: &mut LiteralInfinityExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_literal_infinity_expression(&mut self, _path: &Path, _node: &mut LiteralInfinityExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_literal_null_expression(&mut self, _path: &Path, _node: &mut LiteralNullExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_literal_null_expression(&mut self, _path: &Path, _node: &mut LiteralNullExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_literal_numeric_expression(&mut self, _path: &Path, _node: &mut LiteralNumericExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_literal_numeric_expression(&mut self, _path: &Path, _node: &mut LiteralNumericExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_literal_property_name(&mut self, _path: &Path, _node: &mut LiteralPropertyName) -> Result<(), E> {
        Ok(())
    }
    fn exit_literal_property_name(&mut self, _path: &Path, _node: &mut LiteralPropertyName) -> Result<(), E> {
        Ok(())
    }


    fn enter_literal_reg_exp_expression(&mut self, _path: &Path, _node: &mut LiteralRegExpExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_literal_reg_exp_expression(&mut self, _path: &Path, _node: &mut LiteralRegExpExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_literal_string_expression(&mut self, _path: &Path, _node: &mut LiteralStringExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_literal_string_expression(&mut self, _path: &Path, _node: &mut LiteralStringExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_method(&mut self, _path: &Path, _node: &mut Method) -> Result<(), E> {
        Ok(())
    }
    fn exit_method(&mut self, _path: &Path, _node: &mut Method) -> Result<(), E> {
        Ok(())
    }


    fn enter_module(&mut self, _path: &Path, _node: &mut Module) -> Result<(), E> {
        Ok(())
    }
    fn exit_module(&mut self, _path: &Path, _node: &mut Module) -> Result<(), E> {
        Ok(())
    }


    fn enter_new_expression(&mut self, _path: &Path, _node: &mut NewExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_new_expression(&mut self, _path: &Path, _node: &mut NewExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_new_target_expression(&mut self, _path: &Path, _node: &mut NewTargetExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_new_target_expression(&mut self, _path: &Path, _node: &mut NewTargetExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_object_assignment_target(&mut self, _path: &Path, _node: &mut ObjectAssignmentTarget) -> Result<(), E> {
        Ok(())
    }
    fn exit_object_assignment_target(&mut self, _path: &Path, _node: &mut ObjectAssignmentTarget) -> Result<(), E> {
        Ok(())
    }


    fn enter_object_binding(&mut self, _path: &Path, _node: &mut ObjectBinding) -> Result<(), E> {
        Ok(())
    }
    fn exit_object_binding(&mut self, _path: &Path, _node: &mut ObjectBinding) -> Result<(), E> {
        Ok(())
    }


    fn enter_object_expression(&mut self, _path: &Path, _node: &mut ObjectExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_object_expression(&mut self, _path: &Path, _node: &mut ObjectExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_return_statement(&mut self, _path: &Path, _node: &mut ReturnStatement) -> Result<(), E> {
        Ok(())
    }
    fn exit_return_statement(&mut self, _path: &Path, _node: &mut ReturnStatement) -> Result<(), E> {
        Ok(())
    }


    fn enter_script(&mut self, _path: &Path, _node: &mut Script) -> Result<(), E> {
        Ok(())
    }
    fn exit_script(&mut self, _path: &Path, _node: &mut Script) -> Result<(), E> {
        Ok(())
    }


    fn enter_setter(&mut self, _path: &Path, _node: &mut Setter) -> Result<(), E> {
        Ok(())
    }
    fn exit_setter(&mut self, _path: &Path, _node: &mut Setter) -> Result<(), E> {
        Ok(())
    }


    fn enter_shorthand_property(&mut self, _path: &Path, _node: &mut ShorthandProperty) -> Result<(), E> {
        Ok(())
    }
    fn exit_shorthand_property(&mut self, _path: &Path, _node: &mut ShorthandProperty) -> Result<(), E> {
        Ok(())
    }


    fn enter_spread_element(&mut self, _path: &Path, _node: &mut SpreadElement) -> Result<(), E> {
        Ok(())
    }
    fn exit_spread_element(&mut self, _path: &Path, _node: &mut SpreadElement) -> Result<(), E> {
        Ok(())
    }


    fn enter_static_member_assignment_target(&mut self, _path: &Path, _node: &mut StaticMemberAssignmentTarget) -> Result<(), E> {
        Ok(())
    }
    fn exit_static_member_assignment_target(&mut self, _path: &Path, _node: &mut StaticMemberAssignmentTarget) -> Result<(), E> {
        Ok(())
    }


    fn enter_static_member_expression(&mut self, _path: &Path, _node: &mut StaticMemberExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_static_member_expression(&mut self, _path: &Path, _node: &mut StaticMemberExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_super_(&mut self, _path: &Path, _node: &mut Super) -> Result<(), E> {
        Ok(())
    }
    fn exit_super_(&mut self, _path: &Path, _node: &mut Super) -> Result<(), E> {
        Ok(())
    }


    fn enter_switch_case(&mut self, _path: &Path, _node: &mut SwitchCase) -> Result<(), E> {
        Ok(())
    }
    fn exit_switch_case(&mut self, _path: &Path, _node: &mut SwitchCase) -> Result<(), E> {
        Ok(())
    }


    fn enter_switch_default(&mut self, _path: &Path, _node: &mut SwitchDefault) -> Result<(), E> {
        Ok(())
    }
    fn exit_switch_default(&mut self, _path: &Path, _node: &mut SwitchDefault) -> Result<(), E> {
        Ok(())
    }


    fn enter_switch_statement(&mut self, _path: &Path, _node: &mut SwitchStatement) -> Result<(), E> {
        Ok(())
    }
    fn exit_switch_statement(&mut self, _path: &Path, _node: &mut SwitchStatement) -> Result<(), E> {
        Ok(())
    }


    fn enter_switch_statement_with_default(&mut self, _path: &Path, _node: &mut SwitchStatementWithDefault) -> Result<(), E> {
        Ok(())
    }
    fn exit_switch_statement_with_default(&mut self, _path: &Path, _node: &mut SwitchStatementWithDefault) -> Result<(), E> {
        Ok(())
    }


    fn enter_template_element(&mut self, _path: &Path, _node: &mut TemplateElement) -> Result<(), E> {
        Ok(())
    }
    fn exit_template_element(&mut self, _path: &Path, _node: &mut TemplateElement) -> Result<(), E> {
        Ok(())
    }


    fn enter_template_expression(&mut self, _path: &Path, _node: &mut TemplateExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_template_expression(&mut self, _path: &Path, _node: &mut TemplateExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_this_expression(&mut self, _path: &Path, _node: &mut ThisExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_this_expression(&mut self, _path: &Path, _node: &mut ThisExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_throw_statement(&mut self, _path: &Path, _node: &mut ThrowStatement) -> Result<(), E> {
        Ok(())
    }
    fn exit_throw_statement(&mut self, _path: &Path, _node: &mut ThrowStatement) -> Result<(), E> {
        Ok(())
    }


    fn enter_try_catch_statement(&mut self, _path: &Path, _node: &mut TryCatchStatement) -> Result<(), E> {
        Ok(())
    }
    fn exit_try_catch_statement(&mut self, _path: &Path, _node: &mut TryCatchStatement) -> Result<(), E> {
        Ok(())
    }


    fn enter_try_finally_statement(&mut self, _path: &Path, _node: &mut TryFinallyStatement) -> Result<(), E> {
        Ok(())
    }
    fn exit_try_finally_statement(&mut self, _path: &Path, _node: &mut TryFinallyStatement) -> Result<(), E> {
        Ok(())
    }


    fn enter_unary_expression(&mut self, _path: &Path, _node: &mut UnaryExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_unary_expression(&mut self, _path: &Path, _node: &mut UnaryExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_update_expression(&mut self, _path: &Path, _node: &mut UpdateExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_update_expression(&mut self, _path: &Path, _node: &mut UpdateExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_variable_declaration(&mut self, _path: &Path, _node: &mut VariableDeclaration) -> Result<(), E> {
        Ok(())
    }
    fn exit_variable_declaration(&mut self, _path: &Path, _node: &mut VariableDeclaration) -> Result<(), E> {
        Ok(())
    }


    fn enter_variable_declarator(&mut self, _path: &Path, _node: &mut VariableDeclarator) -> Result<(), E> {
        Ok(())
    }
    fn exit_variable_declarator(&mut self, _path: &Path, _node: &mut VariableDeclarator) -> Result<(), E> {
        Ok(())
    }


    fn enter_while_statement(&mut self, _path: &Path, _node: &mut WhileStatement) -> Result<(), E> {
        Ok(())
    }
    fn exit_while_statement(&mut self, _path: &Path, _node: &mut WhileStatement) -> Result<(), E> {
        Ok(())
    }


    fn enter_with_statement(&mut self, _path: &Path, _node: &mut WithStatement) -> Result<(), E> {
        Ok(())
    }
    fn exit_with_statement(&mut self, _path: &Path, _node: &mut WithStatement) -> Result<(), E> {
        Ok(())
    }


    fn enter_yield_expression(&mut self, _path: &Path, _node: &mut YieldExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_yield_expression(&mut self, _path: &Path, _node: &mut YieldExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_yield_star_expression(&mut self, _path: &Path, _node: &mut YieldStarExpression) -> Result<(), E> {
        Ok(())
    }
    fn exit_yield_star_expression(&mut self, _path: &Path, _node: &mut YieldStarExpression) -> Result<(), E> {
        Ok(())
    }


    fn enter_null(&mut self, _path: &Path, _node: &mut Null) -> Result<(), E> {
        Ok(())
    }
    fn exit_null(&mut self, _path: &Path, _node: &mut Null) -> Result<(), E> {
        Ok(())
    }

}

pub trait Walker {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E>;
}

impl Walker for String {
    fn walk<V, E>(&mut self, _: &mut Path, _: &mut V) -> Result<(), E> where V: Visitor<E> {
        Ok(())
    }
}
impl Walker for bool {
    fn walk<V, E>(&mut self, _: &mut Path, _: &mut V) -> Result<(), E> where V: Visitor<E> {
        // Do not inspect the contents of a bool.
        Ok(())
    }
}
impl Walker for f64 {
    fn walk<V, E>(&mut self, _: &mut Path, _: &mut V) -> Result<(), E> where V: Visitor<E> {
        // Do not inspect the contents of a f64.
        Ok(())
    }
}
impl<T> Walker for Option<T> where T: Walker {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        // Do not callback on the `Option<>` itself, just on its contents.
        if let Some(ref mut contents) = *self {
            contents.walk(path, visitor)?;
        }
        Ok(())
    }        
}
impl<T> Walker for Vec<T> where T: Walker {
    fn walk<V, E>(&mut self, path: &mut Path, visitor: &mut V) -> Result<(), E> where V: Visitor<E> {
        // Do not callback on the `Vec<>` itself, just on its contents.
        for iter in self.iter_mut() {
            iter.walk(path, visitor)?;
        }
        Ok(())
    }
}




pub type PathItem = binjs_shared::ast::PathItem<ASTNode, ASTField>;
pub type Path = binjs_shared::ast::Path<ASTNode, ASTField>;



// Field names (by lexicographical order)
#[derive(Clone, Copy, PartialEq, Eq, Debug)]
pub enum ASTField {
    Alternate,
    Arguments,
    Binding,
    Body,
    BodyScope,
    Callee,
    CapturedNames,
    Cases,
    CatchClause,
    Consequent,
    Declaration,
    Declarators,
    DefaultBinding,
    DefaultCase,
    Directives,
    Discriminant,
    Elements,
    ExportedName,
    Expression,
    Finalizer,
    Flags,
    HasDirectEval,
    Init,
    IsAsync,
    IsGenerator,
    IsPrefix,
    IsStatic,
    Items,
    Kind,
    Label,
    Left,
    LexicallyDeclaredNames,
    Method,
    ModuleSpecifier,
    Name,
    NamedExports,
    NamedImports,
    NamespaceBinding,
    Object,
    Operand,
    Operator,
    Param,
    ParameterNames,
    ParameterScope,
    Params,
    Pattern,
    PostDefaultCases,
    PreDefaultCases,
    Properties,
    Property,
    RawValue,
    Rest,
    Right,
    Scope,
    Statements,
    Super,
    Tag,
    Test,
    Update,
    Value,
    VarDeclaredNames,
}

