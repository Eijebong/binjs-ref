//! Mid-level API used to write individual components of an AST tree to a
//! stream of tokens.
//!
//! Simple implementations may write bytes as they come, while complex
//! ones may decide to provide sophisticated compression.
//!
//! In practice, this API is kept as a trait to simplify unit testing and
//! experimentation of sophisticated compression schemes.

use binjs_shared;

use std::collections::{ HashMap, HashSet };
use std::fmt::{ Debug, Display };
use std::hash::Hash;
use std::marker::PhantomData;
use std::ops::Add;
use std::rc::Rc;

use itertools::Itertools;

/// An API for reading tokens.
///
/// Note that a `TokenReader` by itself *cannot* determine the nature of the
/// following token. Rather, the driver of the `TokenReader` must be able to
/// deduce the nature of the following token from what it has previously
/// read.
pub trait TokenReader where Self::Error: Debug + From<::TokenReaderError>,
                            Self::ListGuard: Guard<Error = Self::Error>,
                            Self::TaggedGuard: Guard<Error = Self::Error>,
                            Self::UntaggedGuard: Guard<Error = Self::Error>,
                            Self: Sized
{
    /// An error returned by the extractor.
    ///
    /// Errors are *not* recoverable within a `TokenReader`.
    ///
    /// For instance, if attempting to read with `string()`
    /// fails, any further attempt to use the `TokenReader`
    /// or any of its parents will also raise an error.
    type Error;

    /// A guard, used to make sure that the consumer has properly read a list.
    ///
    /// See the documentation of `self.list`.
    type ListGuard;

    /// A guard, used to make sure that the consumer has properly read a tagged tuple.
    ///
    /// See the documentation of `self.tagged_tuple`.
    type TaggedGuard;

    /// A guard, used to make sure that the consumer has properly read an untagged tuple.
    ///
    /// See the documentation of `self.untagged_tuple`.
    type UntaggedGuard;

    /// Poison the reader, ensuring that it will never be used for reading again.
    fn poison(&mut self);

    /// Read a single UTF-8 string.
    ///
    /// The returned string MUST be valid UTF-8.
    fn string(&mut self) -> Result<Option<String>, Self::Error>;

    /// Read a single `f64`. Note that all numbers are `f64`.
    fn float(&mut self) -> Result<Option<f64>, Self::Error>;

    /// Read a single `bool`.
    fn bool(&mut self) -> Result<Option<bool>, Self::Error>;

    /// Read a single number of bytes.
    fn offset(&mut self) -> Result<u32, Self::Error>;

    /// Start reading a list.
    ///
    /// Returns a guard for that list and the number of elements
    /// in the list. Once the list is read entirely, callers MUST
    /// call `guard.done()` to ensure that the list was properly
    /// read (in particular that all bytes were consumed). In most
    /// implementations, failure to do so will raise an assertion.
    fn list(&mut self) -> Result<(u32, Self::ListGuard), Self::Error>;

    /// Start reading a tagged tuple. If the stream was encoded
    /// properly, the tag is attached to an **ordered** tuple of
    /// fields that may be extracted **in order**.
    ///
    /// Returns the tag name, the ordered array of fields in which
    /// the contents must be read, and a guard for that tuple.
    /// Once the tuple is read entirely, callers MUST
    /// call `guard.done()` to ensure that the tuple was properly
    /// read (in particular that all bytes were consumed). In most
    /// implementations, failure to do so will raise an assertion.
    fn tagged_tuple(&mut self) -> Result<(String, Option<Rc<Box<[String]>>>, Self::TaggedGuard), Self::Error>;

    /// Start reading an untagged tuple.
    ///
    /// Once the tuple is read entirely, callers MUST
    /// call `guard.done()` to ensure that the tuple was properly
    /// read (in particular that all bytes were consumed). In most
    /// implementations, failure to do so will raise an assertion.
    fn untagged_tuple(&mut self) -> Result<Self::UntaggedGuard, Self::Error>;
}

/// Build an in-memory representation of a BinTree.
///
/// Implementations may for instance introduce atoms,
/// maximal sharing, etc.
pub trait TokenWriter where Self::Error: Debug, Self::Statistics: Display + Sized + Add + Default {
    /// The type of trees manipulated by this writer.
    type Tree;

    /// Statistics produced by this writer.
    type Statistics;

    /// The type of data generated by this writer.
    /// Typically some variant of `Vec<u8>`.
    type Data: AsRef<[u8]>;

    /// An error returned by this writer.
    ///
    /// Note that errors are *not* recoverable within the life
    /// of this `TokenWriter`.
    type Error;

    /// Finish writing, produce data.
    fn done(self) -> Result<(Self::Data, Self::Statistics), Self::Error>;

    /// Write a tagged tuple.
    ///
    /// The number of items is specified by the grammar, so it MAY not be
    /// recorded by the `TokenWriter`.
    ///
    /// The interface MUST have a Tag.
    fn tagged_tuple(&mut self, tag: &str, &[(&str, Self::Tree)]) -> Result<Self::Tree, Self::Error>;

    /// Write an untagged tuple.
    ///
    /// The number of items is specified by the grammar, so it MAY not be
    /// recorded by the `TokenWriter`.
    fn untagged_tuple(&mut self, &[Self::Tree]) -> Result<Self::Tree, Self::Error>;

    /// Write a list.
    ///
    /// By opposition to a tuple, the number of items is variable and MUST
    /// be somehow recorded by the `TokenWriter`.
    fn list(&mut self, Vec<Self::Tree>) -> Result<Self::Tree, Self::Error>;

    /// Write a single UTF-8 string.
    ///
    /// If specified, the string MUST be UTF-8.
    fn string(&mut self, Option<&str>) -> Result<Self::Tree, Self::Error>;

    /// Write a single number.
    fn float(&mut self, Option<f64>) -> Result<Self::Tree, Self::Error>;

    /// Write single bool.
    fn bool(&mut self, Option<bool>) -> Result<Self::Tree, Self::Error>;

    /// Write the number of bytes left in this tuple.
    fn offset(&mut self) -> Result<Self::Tree, Self::Error>;
}


/// A guard used to ensure that some subset of the input stream was read properly.
pub trait Guard {
    /// The type of errors returned by the guard. This is typically
    /// `TokenReader::Error`.
    type Error;

    /// Ensure that the subset of the input stream was read properly.
    fn done(self) -> Result<(), Self::Error>;
}

/// Trivial implementation of a guard.
///
/// This implementation serves as a placeholder or as a building block for
/// more sophisticated implementations: it does not check anything
/// meaningful in `done()` but ensures that `done()` is eventually called.
pub struct TrivialGuard<Error> {
    phantom: PhantomData<Error>,

    /// `true` once `done()` has been called, `false` otherwise.
    pub finalized: bool,
}
impl<E> TrivialGuard<E> {
    /// Create a `TrivialGuard`.
    ///
    /// If the `TrivialGuard` is dropped before `done()` is called
    /// or `self.finalized` is set to `true`, the drop will cause
    /// an assertion failure.
    pub fn new() -> Self {
        TrivialGuard {
            phantom: PhantomData,
            finalized: false
        }
    }
}

impl<Error> Guard for TrivialGuard<Error> {
    type Error = Error;

    /// Mark the guard as safe to be dropped.
    fn done(mut self) -> Result<(), Self::Error> {
        self.finalized = true;
        Ok(())
    }
}

impl<Error> Drop for TrivialGuard<Error> {
    /// # Failures
    ///
    /// If the `TrivialGuard` is dropped before `done()` is called
    /// or `self.finalized` is set to `true`, the drop will cause
    /// an assertion failure.
    fn drop(&mut self) {
        assert!(self.finalized)
    }
}

pub trait Serialization<W, T> where W: TokenWriter, T: Sized {
    fn serialize(&mut self, data: T) -> Result<W::Tree, W::Error>;
}
pub trait TokenSerializer<W> where W: TokenWriter {
    fn done(self) -> Result<(W::Data, W::Statistics), W::Error>;
}


pub trait Deserialization<R, T> where R: TokenReader, T: Sized {
    fn deserialize(&mut self) -> Result<T, R::Error>;
}
pub trait InnerDeserialization<R, T> where R: TokenReader, T: Sized {
    fn deserialize_inner(&mut self) -> Result<T, R::Error>;
}

trait Label {
    fn serialize_definition<W: Write>(&self, out: &mut W) -> Result<(), std::io::Error>;
}

pub struct Labeling<T> {
    label: T,
    is_first: bool,
}
impl<T> Labeling<T> where T: Clone {
    pub fn label(&self) -> T {
        self.label.clone()
    }
}
impl<T> Labeling<T> {
    pub fn is_first(&self) -> bool {
        self.is_first
    }
}
pub trait LabelingStrategy<T, U> {
    fn mark_as_seen(&mut self, label: &T);

    fn write_label<W>(&mut self, label: &T, parent: Option<&T>, out: &mut T) -> Result<bool, std::io::Error>;
}

/// Most recently used.
///
/// This strategy ensures that the most recently used name has a value of 0,
/// the second-most recently used has a value of 1, etc.
///
/// ```
/// use binjs_io::io::{ MRULabeler, LabelingStrategy };
///
/// let mut strategy = MRULabeler::mru();
///
/// let abc = strategy.get_index(&"abc");
/// assert_eq!(abc.is_first(), true);
/// assert_eq!(abc.index(), 0);
///
/// let abc = strategy.get_index(&"abc");
/// assert_eq!(abc.is_first(), false);
/// assert_eq!(abc.index(), 0);
///
/// let def = strategy.get_index(&"def");
/// assert_eq!(abc.is_first(), true);
/// assert_eq!(abc.index(), 1);
///
/// let abc = strategy.get_index(&"abc");
/// assert_eq!(abc.is_first(), false);
/// assert_eq!(abc.index(), 1);
///
/// let def = strategy.get_index(&"def");
/// assert_eq!(abc.is_first(), false);
/// assert_eq!(abc.index(), 1);
/// ```
pub struct MRULabeler<T> where T: Eq + Clone {
    mru: binjs_shared::mru::MRU<T>
}
impl<T> MRULabeler<T> where T: Eq + Clone {
    pub fn new() -> Self {
        Self {
            mru: binjs_shared::mru::MRU::new()
        }
    }
}
impl<T> LabelingStrategy<T, usize> for MRULabeler<T> where T: Eq + Clone {
    fn mark_as_seen(&mut self, label: &T) {
        self.mru.access(label);
    }
    fn get_label(&mut self, label: &T, _: Option<&T>) -> Labeling<usize> {
        use binjs_shared::mru::Seen::*;
        match self.mru.access(label) {
            Age(index) => Labeling {
                label: index,
                is_first: false,
            },
            Never(index) => Labeling {
                label: index,
                is_first: true
            }
        }
    }
}

/// Label entries with a dictionary.
///
/// Typically used for labeling with global frequencies.
pub struct DictionaryLabeler<T, U> where T: Eq + Hash, U: Clone {
    dictionary: HashMap<T, Labeling<U>>
}
impl<T, U> DictionaryLabeler<T, U> where T: Eq + Hash, U: Clone {
    pub fn new(mut dictionary: HashMap<T, U>) -> Self {
        Self {
            dictionary: dictionary.drain()
                .map(|(k, v)| (k, Labeling {
                    is_first: true,
                    label: v
                }))
                .collect()
        }
    }
}
impl<T, U> LabelingStrategy<T, U> for DictionaryLabeler<T, U> where T: Debug + Eq + Hash, U: Clone {
    fn mark_as_seen(&mut self, label: &T) {
        self.dictionary.get_mut(label)
            .unwrap_or_else(|| panic!("Could not find label {:?} in DictionaryLabeler"))
            .is_first = false;
    }
    fn get_label(&mut self, label: &T, _: Option<&T>) -> Labeling<U> {
        let found = self.dictionary.get_mut(label)
            .unwrap_or_else(|| panic!("Could not find label {:?} in DictionaryLabeler"));
        let result = Labeling {
            is_first: found.is_first,
            label: found.label.clone(),
        };
        found.is_first = false;
        result
    }
}

pub struct ParentPredictionLabeler<T, U, V> where T: Eq + Hash, U: Clone {
    /// A mapping from label to an index in the table.
    dictionary_labeler: DictionaryLabeler<T, U>,
    per_parent: HashMap<T, HashMap<T, usize>>,
}
impl<T, U> ParentPredictionLabeler<T, U> where T: Eq + Hash + Clone, U: Clone {
    pub fn new(dictionary: HashMap<T, U>) -> Self {
        Self {
            per_parent: HashMap::new(),
            dictionary_labeler: DictionaryLabeler::new(dictionary),
        }
    }
}
impl<T, U> LabelingStrategy<T, U> for ParentPredictionLabeler<T, U> where T: Debug + Eq + Hash + Clone, U: Clone + Default + From<usize> {
    fn mark_as_seen(&mut self, label: &T) {
        self.dictionary_labeler.mark_as_seen(label)
    }
    fn get_label(&mut self, label: &T, parent: Option<&T>) -> Labeling<U> {
        use std::collections::hash_map::Entry::*;
        if let Some(parent) = parent {
            let this_parent = self.per_parent.entry(parent.clone())
                .or_insert_with(|| HashMap::new());
            let number_of_children = this_parent.len();
            let (index, found) = match this_parent.entry(label.clone()) {
                Occupied(entry) => {
                    // Thils parent/child pair has already been seen, nothing to do.
                    (*entry.get(), true)
                }
                Vacant(entry) => {
                    entry.insert(number_of_children);
                    (number_of_children, false)
                }
            };
            if found {
                Labeling {
                    is_first: false,
                    label: index.into()
                }
            } else {
                unimplemented!()
                // Fall back to the dictionary.
                // FIXME: We need `number_of_children` to fill this custom inline dictionary.
                // FIXME: We need `self.dictionary` afterwards with the index back into the header (or the inline definition).
                // FIXME: In other words, we need to ignore the fact that `self.dictionary` may count the data as already seen.
            }
        } else {
            // FIXME: This is a root. It always needs its definition.
            // FIXME: It's always the first, right?
            unimplemented!()
            // Always use the Default as a label

        }
    }
}

/*
pub struct MRUStrategy {

}




pub enum Definition<'a, T, U> where T: 'a, U: 'a {
    Label(&'a T),
    Definition(&'a U),
    AlreadySeen,
}

/// A number associated with a label in an AST.
///
/// The actual strategy to generate these numbers
/// is specified by the instance of `NumberingStrategy`.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Numbering<'a, T, U> where T: 'a, U: 'a {
    /// The actual number to use.
    index: usize,
    definition: Definition<'a, T, U>,
}
impl<'a, T, U> Numbering<'a, T, U> where T: 'a, U: 'a {
    /// The actual number to use. If this is the first instance
    /// of this label, it may have never been seen.
    pub fn index(&self) -> usize {
        self.index
    }

    pub fn definition(&self) -> &Definition {
        &self.definition
    }
}

enum NumberingTactics<T> where T: Eq + Hash + Clone {
    /// Most recently used.
    ///
    /// This strategy ensures that the most recently used name has a value of 0,
    /// the second-most recently used has a value of 1, etc.
    MRU(binjs_shared::mru::MRU<T>),

    Frequency(HashMap<T, (bool /* has been seen */, usize )>),

    ParentNamespacing(HashMap<T, HashMap<T, usize>>),
}

/// A strategy for associating an integer value to a label when generating an AST.
pub struct NumberingStrategy<T, U> where T: Eq + Hash + Clone {
    tactics: NumberingTactics<T>,
    dictionary: Option<HashMap<T, U>>,
}

impl<T, U> NumberingStrategy<T, U> where T: Eq + Hash + Clone {

    pub fn mru(dictionary: Option<HashMap<T, U>>) -> Self {
        let mru = binjs_shared::mru::MRU::new();
        Self {
            tactics: NumberingTactics::MRU(mru),
            dictionary,
        }
    }

    /// Global frequency.
    ///
    /// This strategy ensures that the most common name has a value of 0,
    /// the second-most common name has a value of 1, etc.
    pub fn frequency(dictionary: Option<HashMap<T, U>>, occurrences: HashMap<T, usize>) -> Self {
        let sorted = occurrences.into_iter()
            .sorted_by(|(_, v), (_, v2)| usize::cmp(v2, v)); // Sort from largest to smallest
        let numbered = sorted.into_iter()
            .enumerate()
            .map(|(position, (label, _))| (label, Numbering { is_first: true, index: position }))
            .collect();
        Self {
            tactics: NumberingTactics::Frequency(numbered),
            dictionary,
        }
    }

    pub fn get_index<'a>(&'a mut self, label: &'a T, parent: &'a T) -> Numbering<'a, T, U> {
        match self.tactics {
            NumberingTactics::MRU(ref mut mru) => {
                use binjs_shared::mru::Seen::*;
                let result = match mru.access(label).clone() {
                    Age(index) => Numbering {
                        index,
                        definition: Definition::AlreadySeen
                    },
                    Never(index) => {
                        match self.dictionary.get(label) {
                            None => Numbering {
                                index,
                                definition: Definition::Label(label)
                            },
                            Some(def) => Numbering {
                                index,
                                definition: Definition::Definition(def)
                            }
                        }
                    }
                };
                result
            }
            NumberingTactics::Frequency(ref mut frequency) => {
                let mut found = frequency.get_mut(label).unwrap();
                let result = found.clone();
                found.is_first = false;
                result
            }
            NumberingTactics::ParentNamespacing(ref mut namespacing) => {
                use std::collections::hash_map::Entry::*;
                let mut per_parent = namespacing.entry(parent.clone())
                    .or_insert_with(|| HashMap::new());
                let children = per_parent.len();
                match per_parent.entry(label.clone()) {
                    Occupied(entry) => Numbering {
                        is_first: false,
                        index: *entry.get()
                    },
                    Vacant(entry) => {
                        entry.insert(children);
                        Numbering {
                            is_first: true,
                            index: children
                        }
                    }
                }
            }
        }
    }
}

*/